\chapter{Experiment}

Aby bylo možné porovnat stávající řešení s nově navrženým řešením na poli rychlosti zpracovávání dotazů a ověřit naše předpoklady, podrobili jsme zmíněná řešení experimentu. 
Vykonaný experiment proběhne na reálných grafech různé velikosti s uměle vygenerovanými vlastnostmi naležící vrcholům. 
Nad danými grafy provedeme vybrané množství dotazů, které nám umožní sledovat a porovnat chování řešení v různých situacích.
Experiment bude zakončen diskuzí nad výsledky. 

\section{Příprava dat}
\label{expr.graphs}

Pro náš experiment jsme použili tři orientované grafy z databáze SNAP\footnote{\citet{snapnets}}.

\begin{table}[!htb]
\centering
\begin{tabular}{lrr}
\toprule
\mc{} & \mc{\textbf{\#Vrcholů}} & \mc{\textbf{\#Hran}} \\
\midrule
Amazon0601     & 403394 & 3387388 \\
WebBerkStan & 685230   & 7600595 \\
As-Skitter    & 1696415   & 11095298 \\
\bottomrule
\end{tabular}

\caption{Vybrané grafy pro experiment}
\label{tab.grafBase}
\end{table}

\begin{itemize}

\item \textbf{Amazon0601:} Jedná se o graf vytvořený procházením webových stránek Amazonu na základě featury „Customers Who Bought This Item Also Bought“ ze dne 1.6.2003. V grafu existuje hrana z $i$ do $j$, pokud je produkt $i$ často zakoupen s produktem $j$.

\item \textbf{WebBerkStan:} Graf popisuje odkazy webových stránek domén \url{https://www.stanford.edu/} a \url{https://www.berkeley.edu/}. Vrcholem je webová stránka a hrana představuje hypertextový odkaz mezi stránkami.

\item \textbf{As-Skitter:} Topologický graf internetu z roku 2005 vytvořený programem \verb+traceroutes+. Ačkoliv je uvedeno, že daný graf je neorientovaný, vnitřní hlavička souboru uvádí opak, proto jsme se daný graf rozhodli přesto využít.

\end{itemize}

Samotné grafy obsahují pouze seznam hran. Abychom mohli dané grafy využít, bylo nutné je transformovat a vygenerovat k nim Properties na vrcholech. 
Při příkladu transformace budeme vycházet z následující ukázky hlavičky (graf Amazon0601):

\begin{code}
# Directed graph (each unordered pair of nodes is saved once): 
    Amazon0601.txt: 
# Amazon product co-purchaisng network from June 01 2003
# Nodes: 403394 Edges: 3387388
# FromNodeId	ToNodeId
0	1
0	2
0	3
0	4
\end{code}

\subsection{Transformace grafových dat}

Výstupem transformace budou soubory popisující schéma vrcholů/hran NodeTypes.txt/EdgeTypes.txt a datové soubory vrcholů/hran Nodes.txt/Edges.txt.
V našem případě graf bude obsahovat pouze jeden typ hrany a jeden typ vrcholu. Dané omezení ovlivňuje pouze vyhledávání vzoru, které není určující pro náš experiment. 

Ukázka zvoleného schématu pro Nodes.txt/Edges.txt:
\begin{code}
Soubor EdgeTypes.txt:
[
{ "Kind": "BasicEdge" }
]

Soubor NodeTypes.txt:
[ 
{ "Kind": "BasicNode" }
]

\end{code}

Generování souborů Edges.txt/Nodes.txt provádí program, který je obsahem přílohy zdrojových kódů \ref{prilohy.kod} v souboru GrapDataBuilder.cs.
Výstupní soubor Edges.txt bude obsahovat hrany v rostoucím pořadí dle položky \verb+FromNodeId+ z originálního souboru s přidělenými \verb+IDs+ od hodnoty \verb+ID+ posledního vrcholu v souboru Nodes.txt.
Samotný soubor Nodes.txt obsahuje setřiděné vrcholy podle \verb+ID+ v rostoucím pořadí. Je nutné zmínit, že setřídění dat podle \verb+ID+ není nežádoucí, jelikož nezaručuje nic o seskupení vrcholů v daném grafu.
Pro připomenutí zmíníme, že prvni sloupeček v datových souborech Edges.txt a Nodes.txt odpovídá unikátnímu \verb+ID+ v rámci celého grafu.

Následuje ukázka výstupních souborů transformace pro graf Amazon0601:  
\begin{code}
Soubor Edges.txt:
403395 BasicEdge 0 1
403396 BasicEdge 0 2
...

Soubor Nodes.txt:
0 BasicNode 
1 BasicNode 
...
\end{code}

\subsection{Generování Properties vrcholů}

Posledním krokem přípravy dat pro experiment je vygenerování Properties vrcholů.
Jsme si vědomi, že nejideálnější způsob testování je graf s reálnými daty. Nicméně, dané omezení jsme se rozhodli aplikovat kvůli problematickému hledání vhodných dat, které nevyžadují netriviální transformaci do vhodného vstupního formátu.
Proto pro každý vrchol náhodně vygenerujeme hodnoty tří Properties. 
\clearpage
\begin{table}[!htb]
\centering
\begin{tabular}{lll}
\toprule
\mc{\textbf{Property}} & \mc{\textbf{Type}}  & \mc{\textbf{Popis}}\\
\midrule
PropOne     & integer &  \verb+Int32+ s rozsahem $[0; 100000]$ \\
PropTwo & integer   & \verb+Int32+ s rozsahem $[$\verb+Int32.MinValue+; \verb+Int32.MaxValue+$]$ \\
PropThree    & string &  délka $[2; 8]$ ASCII znaků s rozsahem $[33; 126]$ \\
\bottomrule
\end{tabular}

\caption{Generované Properties vrcholů}
\label{tab.grafProps}
\end{table}

\begin{itemize}

\item \textbf{PropTwo} hodnoty jsou rovněž generováný střídavě kladně a záporně, aby nastal rovnoměrný počet záporných a kladných hodnot.

\item \textbf{PropThree} hodnoty jsou pouze ASCII znaky z rozsahu $[33; 126]$. Dané omezení výplývá z vlastností dotazovacího enginu, aby bylo možné bez obtíží načíst datový soubor.

\end{itemize}

Na základě tabulky generovaných Properties \ref{tab.grafProps} následuje ukázka upraveného souboru schématu pro vrcholy:
\begin{code}
Soubor NodeTypes.txt:
[
{ 
"Kind": "BasicNode",
"PropOne": "integer",
"PropTwo": "integer",
"PropThree": "string" 
}
]
\end{code}

Výsledné hodnoty Properties do souborů Edges.txt/Nodes.txt jsou vygenerovány pomocí programu, který používá generátor náhodných čísel. Program je obsažen v příloze zdrojových kódů \ref{prilohy.kod} v souboru PropertyGenerator.cs.
Pro každý graf bylo použité jiné \verb+Seed+ pro inicializaci náhodného generátoru. Samotná \verb+Seeds+ byla vygenerována rovněž náhodně.

\begin{table}[!htb]
\centering
\begin{tabular}{lr}
\toprule
\mc{} & \mc{\textbf{Seed}} \\
\midrule
Amazon0601     & 429185 \\
WebBerkStan &  20022 \\
As-Skitter    & 82 \\
\bottomrule
\end{tabular}

\caption{Inicializační hodnoty náhodného generátoru pro PropertyGenerator.cs}
\label{tab.seeds}
\end{table}

Program generuje hodnoty definované ve statické položce \verb+propGenerators+ a zachovává jejich pořadí ve výsledném datovém souboru.
Aby nedocházelo k omylům při opakování experimentů, uvádíme útržek kódu použité inicializace položky dle tabulky generovaných vlastností \ref{tab.grafProps} pro všechny tři grafy:
\clearpage

\begin{code}
    static PropGenerator[] propGenerators = new PropGenerator[]
    {
        new Int32Generator(0, 100_000, false),
        new Int32Generator(true),
        new StringASCIIGenerator(2, 8, 33, 126)
    };
\end{code}


Timto jsme dokončili poslední nutný krok k vygenerování platných vstupních dat pro dotazovací engine. Použité grafy k transformaci a výsledné datové soubory jsou obsahem přílohy grafů pro experiment \ref{prilohy.grafy}

\section{Výběr dotazů}
\label{expr.dotazy}

Dotazy použité při experimentu dělíme do tří kategorií a to Match, Order by a Group by.
Pro připomenutí zmíníme, že proměnné použité v jiných částech než Match způsobují ukládání daných proměnných do tabulky.
Přidělené zkratky dotazům budou uváděný ve výsledcích experimentu namísto celých dotazů. 

\subsection{Dotazy Match}

Každý dotaz provádí vyhledáváním vzoru v grafu.
Níže zmíněné dotazy nám při experimentu pomohou oddělit čas agregací od času stráveném vyhledáváním vzoru.

\begin{table}[!htb]
\centering
\begin{tabular}{ll}
\toprule
\mc{\textbf{Zkratka}} & \mc{\textbf{Dotaz}} \\
\midrule
M\_Q1 & select count(*) match (x) -> (y) -> (z); \\
M\_Q2 & select x match (x) -> (y) -> (z); \\
M\_Q3 & select x, y match (x) -> (y) -> (z); \\
M\_Q4 & select x, y, z match (x) -> (y) -> (z); \\
\bottomrule
\end{tabular}

\caption{Dotazy Match}
\label{tab.dotazM}
\end{table}

\begin{itemize}

\item M\_Q1 testuje pouze dobu strávenou vyhledáváním vzoru.

\item M\_Q2 testuje vyhledávání společně s ukládáním proměnné x do tabulky výsledků.

\item M\_Q3 testuje vyhledávání společně s ukládáním proměnné x a y do tabulky výsledků.

\item M\_Q4 testuje vyhledávání společně s ukládáním proměnné x, y a z do tabulky výsledků.
\end{itemize}

\clearpage

\subsection{Dotazy Order by}

\begin{table}[!htb]
\centering
\begin{tabular}{ll}
\toprule
\mc{\textbf{Zkratka}} & \mc{\textbf{Dotaz}} \\
\midrule
O\_Q1 & select y match (x) -> (y) -> (z) order by y; \\
O\_Q2 & select y, x match (x) -> (y) -> (z) order by y, x;\\
O\_Q3 & select x.PropTwo match (x) -> (y) -> (z) order by x.PropTwo;\\
O\_Q4 & select x.PropThree match (x) -> (y) -> (z) order by x.PropThree \\
\bottomrule
\end{tabular}

\caption{Dotazy Order by}
\label{tab.dotazO}
\end{table}

\begin{itemize}

\item O\_Q1 testuje třídění podle \verb+ID+ vrcholů y. 
\item O\_Q2 přidává do kontextu O\_Q1 overhead za porovnávání a ukládání další proměnné.
\item O\_Q3 testuje třídění náhodně vygenerovaných hodnot Int32 (viz \ref{tab.grafProps}).
\item O\_Q4 testuje třídění náhodně vygenerovaných řetězců (viz \ref{tab.grafProps}).

\end{itemize}


\subsection{Dotazy Group by}

\begin{table}[!htb]
\centering
\begin{tabular}{ll}
\toprule
\mc{\textbf{Zkratka}} & \mc{\textbf{Dotaz}} \\
\midrule
G\_Q1 & select min(y.PropOne), avg(y.PropOne) \_M;\\
G\_Q2 & select min(y.PropOne), avg(y.PropOne) \_M group by y;\\
G\_Q3 & select min(y.PropOne), avg(y.PropOne) \_M group by y, x;\\
G\_Q4 & select min(x.PropOne), avg(x.PropOne) \_M group by x.PropTwo;\\
G\_Q5 & select min(x.PropOne), avg(x.PropOne) \_M group by x;\\
G\_Q6 & select min(x.PropOne), avg(x.PropOne) \_M group by x, y;\\
G\_Q7 & select min(x.PropOne), avg(x.PropOne) \_M group by x.PropOne;\\
\bottomrule
\multicolumn{2}{l}{\footnotesize \textit{Pozn:} \_M = match (x) -> (y) -> (z).}
\end{tabular}

\caption{Dotazy Group by}
\label{tab.dotazG}
\end{table}

Pro výpočet agregačních funkcí jsme zvolili funkce \verb+min+ a \verb+avg+, protože představují netriviální práci narozdíl od funkcí \verb+sum+/\verb+count+.
V případě \verb+min+ v paralelních řešeních dochází k mechanismu \verb+CompareExchange+ a u \verb+avg+ dojde ke dvou atomickým přičtením.

\begin{itemize}

\item G\_Q1 testuje single group Group by. Vše je agregováno pouze do jedné skupiny. 
\item G\_Q2 testuje vytváření skupin podle \verb+ID+ vrcholů y.
\item G\_Q3 přidává k G\_Q2 overhead za ukládání a zpracovávání (hash + compare) další proměnné.
\item G\_Q4 testuje vytváření skupin náhodně vygenerovaných hodnot Int32 (viz \ref{tab.grafProps}). 
\item G\_Q5 testuje situaci, kdy při paralelním zpracování žádné jiné vlákno během vyhledávaní nenajde stejnou hodnotu.
\item G\_Q7 testuje situaci, kdy dojde k rozprostření několika stejných hodnot v grafu. Dodává větší šanci, že nějaké vlákno během paralelního zpracování dostane stejnou skupinu jako vlákno jiné.

\end{itemize}

\section{Metodika}

Pro provedení experimentu jsme připravili jednoduchý benchmark, který je součástí příloh zdrojových kódů \ref{prilohy.kod}.
Paralelizování řešení jsme otestovali při zatížení všech dostupných jader procesoru (argument \verb+ThreadCount = 8+).
Při spuštění programu dojde k navýšení priority procesu, aby docházelo k méně častému vykonávání ostatních procesů na pozadí během testování. 
Pro \verb+ThreadCount = 1+ navíc dochází k navýšení priority hlavního vlákna. 
To není možné u paralelního testování, protože vlákna běží v nativním \verb+ThreadPool+, který neumožňuje navyšování priority vláken.

Následuje ukázka hlavní smyčky benchmarku:

\begin{code}
...
 WarmUp(...);
...
double[] times = new double[repetitions];
for (int i = 0; i < repetitions; i++)
{
    CleanGC(); 
    var q = Query.Create(..., false); 
    timer.Restart();

    q.Compute();

    timer.Stop();
    times[i] = timer.ElapsedMilliseconds;
    ...
}
\end{code}

Hlavní smyčka benchmarku se skládá z 5-ti opakování warm up fáze následovanou 15-ti opakováními měřené části. 
Měřená část obaluje pouze vykonání dotazu bez konstrukce dotazu. 
V konstruktoru \verb+Query.Create(..., false)+ argument \verb+false+ způsobuje, že vykonávaný dotaz neprovede \verb+select+ část dotazu, která není cílem testování.
Výsledná doba je tedy čas strávený částí Match (výhledávání vzoru) společně s částí Group/Order by. 

Před měřením dochází vždy k úklidu haldy. 
\begin{code}
static void CleanGC()
{
    GC.Collect();
    GC.WaitForPendingFinalizers();
    GC.Collect();
}
\end{code}

K měření uplynulé doby  jsme použili nativní třídu C\# \verb+Stopwatch+, protože náš hardware a operační systém podporuje high-resolution performance counter.
Pro interpretaci výsledků jsme zvolili medián naměřených hodnot, který je doprovázen minimem a maximem.


\subsection{Volitelné argumenty konstruktoru dotazu}

Pro měření argumenty \verb+FixedArraySize+ a \verb+VerticesPerThread+ jsme volili následovně:

\begin{table}[!htb]
\centering
\begin{tabular}{lrr}
\toprule
\mc{} & \mc{\textbf{FixedArraySize}} & \mc{\textbf{VerticesPerThread}} \\
\midrule
Amazon0601 &  4194304 & 512 \\
WebBerkStan & 4194304 & 512 \\
As-Skitter & 8388608 & 1024\\
\bottomrule
\end{tabular}

\caption{Výber argumentů konstruktoru dotazu pro grafy}
\label{tab.args}
\end{table}

Dané argumenty se nám nejvíce osvědčili v průběhu vývoje dotazovacího enginu. Vyhledávání vzoru na nich docilovalo nejrychlejších výsledků.

\subsection{Hardwarová specifikace}

Všechny testy proběhly na notebooku Lenovo ThinkPad E14 Gen. 2 verze 20T6000MCK s operačním systémem Windows 10 x64.
\begin{itemize} 
\item 8 jádrový procesor AMD Ryzen 7 4700U (2GHz, TB 4.1GHz)

\item 24GB RAM DDR4 s 3200 MHz
\end{itemize}

\subsection{Příprava hardwaru}

Každému testování předcházel studený reboot systému a odpojení od internetu. 
V průběhu testování neběžel žádný klientský proces kromě benchmarku a nativních systémových procesů. 
Rovněž, použitý notebook byl napájen po celou dobu testování.


\subsection{Překlad}

Benchmark společně s dotazovacím enginem a potřebnými knihovnami byl přeložen v \verb+Release+ módu Visual Studia 2019 pro platformu x64 cílící na .NET Framework 4.8. 

\clearpage

\section{Výsledky a diskuze}

V této sekci prezentujeme naměřená data pro všechny tři grafy (\ref{expr.graphs}), které jsme podrobili dotazům z sekce \ref{expr.dotazy}.

U grafů Group/Order by se držíme značení odpovídající z kapitoly implementace (tj. ve tvaru (mód enginu): (Název řešení) (způsob ukládání výsledků u Group by)? ).
Pokud řešení obsahuje kombinaci módů, pak řešení pro dané módy jsou totožná.
Pro připomenutí zmíníme, že mód Normal vykonává Group/Order by až po dokončení vyhledávání, vylepšené módy Streamed a Half-Streamed je vykonávájí v průběhu vyhledávání.
U paralelního řešení Streamed jsou výsledky zpracovány globálně, zatímco u Half-Streamed řešení dochází k lokálnímu zpracování zakončeném mergováním.

\subsection{Výsledky Match}
\label{matchResults}

Stávající a vylepšené verze Group/Order by jsou značně ovlivněny vyhledáváním vzoru. 
Proto uvádíme výsledky a analýzu dotazů Match zvlášť, aby bylo možné sledovat čas výhradně strávený vyhledáváním a uložením všech nalezených výsledků do tabulky.

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/amazonMatch.pdf}\centering
\caption{Doba vykonání dotazů Match pro graf Amazon0601 (sekce \ref{tab.grafBase}). Jedno vlákno vůči osmi vláknům. Počet nalezených výsledků je 32373599.}
\label{figure.amazonMatch}
\end{figure}

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/webberkstanMatch.pdf}\centering
\caption{Doba vykonání dotazů Match pro graf WebBerkStan (sekce \ref{tab.grafBase}). Jedno vlákno vůči osmi vláknům. Počet nalezených výsledků je 222498869.}
\label{figure.webberkstanMatch}
\end{figure}

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/skitterMatch.pdf}\centering
\caption{Doba vykonání dotazů Match pro graf As-Skitter (sekce \ref{tab.grafBase}). Jedno vlákno vůči osmi vláknům. Počet nalezených výsledků je 453674558.}
\label{figure.skitterMatch}
\end{figure}

\clearpage

Zbytek sekce věnujeme popisu obrázků \ref{figure.amazonMatch}, \ref{figure.webberkstanMatch} a \ref{figure.skitterMatch}. 
Paralelizace startovního prohledávacího vrcholu (tj. každé vlákno dostává opakovaně množství vrcholů k prohledání určené argumentem \verb+VerticesPerThread+, dokud se nevyčerpají všechny vrcholy grafu) dociluje zrychlení v rozmezí $[4,17; 5,56]$-krát pro všechny grafy.
Výsledky pro jednotlivé dotazy dopadly podle našeho očekávání. Dotaz M\_Q1 provádí pouze vyhledávání výsledků bez ukládání do tabulky a je nejrychlejší. 
Všechny ostatní dotazy dosahují zpomalení závíslé na počtu ukládaných proměnných (počet ukládaných proměnných definuje část Select), tedy čím více proměnných k uložení tím je vykonání pomalejší a to platí i pro paralelní verzi. 
Pro představu, každá proměnná (element grafu) je uložena do vlastního sloupečku, který je lokální pro vlákno (\verb+List<Element[FixedArraySize]>+). Lokalita sloupečků vede na potřebu mergování výsledků vláken. 

Nicméně, díky ukládání do polí fixní délky nastává nutnost pouze zarovnat poslední nezaplněná pole, zbytek práce mergování je jen přesunutí několika pointrů na pole. 
Tento proces je paralelizovaný pouze přes sloupečky, tedy v dotazu M\_Q2 mergování beží pouze v jednom vlákně a proto obsahuje nejvyšší skok rychlosti mezi dotazem před a dotazem po. 
Obecně vidíme, že ukládání výsledků nepřináší až tak velkou přítež na dobu vykonávání jako paměťovou, kdy všechny výsledky jsou uloženy v paměti. 
Například, všechny dotazy na grafu As-Skitter (obrázek \ref{figure.skitterMatch}), vygenerují 453674558 výsledků, což představuje na x64 platformě 3.629 GB pro jeden sloupeček.
Zmíněné poznatky použijeme při analýze experimentů pro Group/Order by.

\subsection{Výsledky Order by}

Z důvodu časové a prostorové složitosti třídění na grafu As-Skitter jsme se rozhodli jej vynechat pro Order by dotazy.

Vylepšená řešení při přichozím výsledku jej uloží do tabulky (stejné tabulky jako v řešení Normal) a následně vloží index výsledku v tabulce do indexovací struktury, tj. v našem případě $(a, b)$-strom\footnote{\citet[03. (a,b)-trees]{dataLecture}}, kde $b=2a$. 
Používáme $b=256$.
V řešení ABTree se jedná o obecný $(a, b)$-strom, zatímco řešení ABTreeValueAccumulator výsledky (indexy) mající stejnou hodnotu klíčů třídění uloží do \verb+List<int>+.
Zástupce Normal řešení je Merge sort\footnote{\citet{hpcsharp}}.

Začneme řešením běžícím v jednom vlákně, tj. obrázky  \ref{figure.amazonOrderST} a \ref{figure.webberkstanOrderST}.
Můžeme si všimnout, že výsledky vypadají v rámci daných grafů konzistentně pro každý dotaz.
Ani jedno z vylepšených řešení nedokázalo porazit mód Normal, což odpovídá našim předpokladům. 
Je to protože daný strom podléhá režii za \verb+Insert+ $\Theta(\log n \cdot (a/\log a))$ (\citet[03. (a,b)-trees str. 6]{dataLecture}), kdy dochází k častému alokování nových vrcholů a překopírovávání prvků při splitu.
Nejproblematičtější část je množství tříděných výsledků, kdy počet samotných hodnot klíčů třídění je omezen počtem vrcholů v grafu (tabulka \ref{tab.grafBase}). 
Daná situace vede k opakovanému zatřizování výsledků se stejnou hodnotou a tím navyšování velikosti stromu společně s počtem porovnání na \verb+Insert+.
Celý problém jsme vyřešelili v řešení ABTreeValueAccumulator, kdy se duplicitní hodnoty ukládají do zmíněného pole a tím omezujeme velikost výsledného stromu. 
Jak vidíme na obrázcích, řešení se přibližuje rychlosti řešení Normal.

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/amazonOrderByST.pdf}\centering
\caption{Doba vykonání dotazů Order by pro graf Amazon0601 (sekce \ref{tab.grafBase}). Běh v jednom vláknu. Počet tříděných výsledků je 32373599.}
\label{figure.amazonOrderST}
\end{figure}

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/webberkstanOrderByST.pdf}\centering
\caption{Doba vykonání dotazů Order by pro graf WebBerkStan (sekce \ref{tab.grafBase}). Běh v jednom vláknu. Počet tříděných výsledků je 222498869.}
\label{figure.webberkstanOrderST}
\end{figure}

\clearpage

Dle našich předpokladů se ukázalo, že třídění podle \verb+ID+ (O\_Q1 a O\_Q2) vůči Properties (O\_Q3 a O\_Q4) vede ke znatelnému overheadu.
Je to způsobeno nutným přístupem k databázi, při kterém se ověřuje, jestli daná vlastnost existuje na daném elementu a následném čtení hodnoty ze struktury obsahující ji.

Paralelní zpracování aplikuje použité verze $(a, b)$-stromů ze zpracování pro jedno vlákno. 
Half-Streamed řešení obsahuje lokální tabulku a indexační strom pro každé běžící vlákno. 
Po dokončení vyhledávání se obsahy stromů překopírují do pole a dojde k paralelnímu 2-way merge používající stejnou funkci jako paralelní Merge sort. 
Streamed řešení rozdělí rozsah prvního třídícího klíče do přihrádek rovnoměrné velikosti. 
Při příchozím výsledku se získá hodnota prvního klíče třídění a určí se jeho přihrádka. 
Počet přihrádek je heuristicky zvolen jako $m=t^2$, kde $t=\#vláken$. 
Samotná přihrádka obsahuje opět tabulku a indexační strom přistupné pomocí zámku. 
Při porovnávání je nutné mít na paměti, že lokálně bežící části používájí cachování popsané v sekci (TODO).  

Nyní budeme prezetovat výsledky paralelizace (obrázky \ref{figure.amazonOrderPar} a \ref{figure.webberkstanOrderPar}).
Pro dotazy O\_Q1 a O\_Q2 vidíme u Streamed řešení mnohonásobný rozdíl vůči ostatním řešením, protože přihrádky jsou rozděleny na základě rozsahu typu klíče (např. pro O\_Q3 $[$\verb+Int32.MinValue+; \verb+Int32.MaxValue+$]$).
Avšak, hodnoty třídění spadaní do rozsahu \verb+ID+ vrcholů grafu, což představuje rozsah $\approx [0; \#vrcholů]$. 
Rozsah hodnot třídění spadá vždy do jedné přihrádky a výsledná doba je rovna době single thread řešení s overheadem za přistupovaný zámek.
U dotazů O\_Q3 a O\_Q4 je tříděno pomocí hodnot vygenerovaných náhodně spadající do celého rozsahu typu klíče a zde Streamed řešení předčilo všechna ostatní. 
Pro budoucí rozšíření by bylo nutné zvážit vytvoření statistik rozsahů jednotlivých Properties, aby bylo možné lépe vytvořit rozdělení přihrádek.

Half-Streamed řešení se přibližuje Normal řešení v prvních dvou dotazech a překonává jej ve třetím i čtvrtém dotazu pro řešení používající ABTreeValueAccumulator.
U třetího a čtvrtého dotazu se porovnává pomocí Properties. V single thread zpracovávání jsme viděli overhead za dané porovnání.
V druhém kroku u daného Half-Streamed řešení dochází k mergování pouze akumulovaných skupin, což rapidně sníží počet porovnávání při mergi a odtud výhoda oproti Normal Merge sort řešení. 
To samé platí u Streamed řešení, protože počáteční rozhašování způsobí vkládání do mnohonásobně menší skupiny výsledků. 
Celá situace je navíc umocněna zmíněným cachovaním porovnávaných hodnot. 

Zajímavý výsledek testování je rozsah zrychlení vylepšených módů (tabulka \ref{tab.OrderByZrychleni}), který jsme neočekávali. 
Zrychlení Merge sortu zaostavá. Maximální zrychlení u ostatních řešení je až pětinásobné. 
Implementace paralelního Merge sortu funguje na principu postupného recurzivního rozdělování, při kterém se vytváří nové \verb+Tasks+ pro \verb+ThreadPool+.
U vylepšených řešení běži jedna metoda pro každé vlákno po dobu celého zpracování. Jestli se jedná o hlavní důvod poznatku by vyžadovalo dalšího testování. 

Jako důsledek testování můžeme konstatovat, že třídění v průběhu vyhledávání nepřináší předpokládané výhody.
Zrychlení nastává pouze u paralelizace řešení při dostatečně náhodném rozložení dat třídění, pokud samotná porovnání jsou drahá.

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/amazonOrderByPar.pdf}\centering
\caption{Doba vykonání dotazů Order by pro graf Amazon0601 (sekce \ref{tab.grafBase}).  Běh osmi vláken. Počet tříděných výsledků je 222498869.}
\label{figure.amazonOrderPar}
\end{figure}

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/webberkstanOrderByPar.pdf}\centering
\caption{Doba vykonání dotazů Order by pro graf WebBerkStan (sekce \ref{tab.grafBase}).  Běh osmi vláken. Počet tříděných výsledků je 222498869.}
\label{figure.webberkstanOrderPar}
\end{figure}

\clearpage

\begin{table}[!htb]
\centering
\begin{tabular}{lr}
\toprule
\mc{} & \mc{\textbf{Zrychlení}} \\
\midrule
Merge sort &  $[3,33; 4,42]$-krát \\
Half-Streamed: ABTree & $[4,36; 4,81]$-krát  \\
Half-Streamed: ABTreeValueAccumulator & $[3,76; 5,18]$-krát \\
Streamed: ABTree & $[0,78; 5,3]$-krát  \\
Streamed: ABTreeValueAccumulator & $[0,81; 5,72]$-krát \\
\bottomrule
\end{tabular}

\caption{Rozsah zrychlení paralelizovaných řešení pomocí osmi vláken v ramci grafů pro dotazy Order by.}
\label{tab.OrderByZrychleni}
\end{table}

\subsection{Výsledky Group by}

Analýzu výsledků dotazu G\_Q1 uvádíme samostatně, protože testuje pouze agregační funkce a nikoliv seskupování.
Po levé straně je běh v jednom vlákně a na pravé straně běh osmi vláken.

\begin{figure}[!htp]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{../img/amazonGroupByQ1ST.pdf} % first figure itself
        \caption{Doba vykonání dotazu G\_Q1 pro graf Amazon0601 (sekce \ref{tab.grafBase}). Běh v jednom vláknu. Počet seskupovaných výsledků je 32373599.}
        \label{figure.amazonGQ1ST}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{../img/amazonGroupByQ1Par.pdf} % second figure itself
        \caption{Doba vykonání dotazu G\_Q1 pro graf Amazon0601 (sekce \ref{tab.grafBase}). Běh osmi vláken. Počet seskupovaných výsledků je 32373599.}
        \label{figure.amazonGQ1Par}
    \end{minipage}
\end{figure}

\begin{figure}[!htp]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{../img/webberkstanGroupByQ1ST.pdf} % first figure itself
        \caption{Doba vykonání dotazu G\_Q1 pro graf WebBerkStan (sekce \ref{tab.grafBase}). Běh v jednom vláknu. Počet seskupovaných výsledků je 222498869.}
        \label{figure.webberkstanGQ1ST}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{../img/webberkstanGroupByQ1Par.pdf} % second figure itself
        \caption{Doba vykonání dotazu G\_Q1 pro graf WebBerkStan (sekce \ref{tab.grafBase}). Běh osmi vláken. Počet seskupovaných výsledků je 222498869.}
        \label{figure.webberkstanGQ1Par}
    \end{minipage}
\end{figure}

\clearpage

\begin{figure}[!htp]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{../img/skitterGroupByQ1ST.pdf} % first figure itself
        \caption{Doba vykonání dotazu G\_Q1 pro graf As-Skitter (sekce \ref{tab.grafBase}). Běh v jednom vláknu. Počet seskupovaných výsledků je 453674558.}
        \label{figure.skitterGQ1ST}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{../img/skitterGroupByQ1Par.pdf} % second figure itself
        \caption{Doba vykonání dotazu G\_Q1 pro graf As-Skitter (sekce \ref{tab.grafBase}). Běh osmi vláken. Počet seskupovaných výsledků je 453674558.}
        \label{figure.skitterGQ1Par}
    \end{minipage}
\end{figure}

Na obrázcích \ref{figure.amazonGQ1ST} až \ref{figure.skitterGQ1Par} lze vidět značnou konzistenci mezi výsledky testování při nárustu počtu výsledků vyhledávání.
Half-Streamed a Streamed řešení zde neukládá výsledky vyhledávání do tabulky, ale pouze na aktuální výsledek aplikuje agregační funkce a následně jej zahodí.
To způsobuje značnou výhodu oproti Normal řešení, které drží všechny výsledky v paměti.
Použijeme-li poznatky z sekce \ref{matchResults} o zpomalení způsobeném ukládáním výsledků do tabulky zjistíme (v našem případě jedné proměnné), že rozdíl mezi Normal a Half-Streamed řešením se pohybuje právě v rozsahu onoho zpomalení.
To platí pro běh jednoho vlákna i běhu osmi vláken. 
Problem představuje paralelní Streamed řešení, jelikož k jednomu výsledku přistupuje osm vláken najednou, což způsobuje značné zpomalení kvůli nutné synchronizaci při výpočtu funkcí \verb+min+ a \verb+avg+. 
Zrychlení je zde pouze v rozsahu $[1,81; 2,64]$-krát, zatímco u zbylých řešení je $[3,67; 4,61]$-krát.

Než postoupíme dál připomeneme hlavní rozdíly řešení a značení u zobrazených grafů. 
Každé řešení používá k Group by mapu (\verb+Dictionary<key, value>+).
Normal řešení ukládá všechny výsledky vyhledávání vzoru do tabulky a po dokončení vykoná Group by. 
Half-Streamed řešení vykonává Group by v průběhu hledání a ukládá do tabulky pouze výsledky, pro které ještě neexistuje skupina v použité mapě.
Pro zmíněná řešení se jako \verb+key+ používá index do tabulky a následně výpočet hodnoty klíče.
Streamed řešení nepoužívá tabulku, ale hodnoty klíče ukládá rovnou do mapy. 
Objevující se značení Bucket a List určuje způsob ukládání výsledků agregačních funkcí (\verb+min+, \verb+avg+...) jako \verb+value+ záznam v mapě:

\begin{code}
Bucket:
Dictionary<key, BucketResult[]> map; // Used map.
class BucketResult {}
class BucketResult<T>: BucketResult { T value; }

List:
Dictionary<key, tableIndex> map; // Used map.
ListResults aggResults; // Agg. func. values of a group 
                        // are accessed via tableIndex.
class ListResults { ListHolder[] holders; }
class ListHolder {}
class ListHolder<T> : ListHolder { List<T> values }
\end{code}

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/amazonGroupByST.pdf}\centering
\caption{Doba vykonání dotazů Group by pro graf Amazon0601 (sekce \ref{tab.grafBase}). Běh v jednom vláknu. Počet seskupovaných výsledků je 32373599.}
\label{figure.amazonGroupByST}
\end{figure}

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/webberkstanGroupByST.pdf}\centering
\caption{Doba vykonání dotazů Group by pro graf WebBerkStan (sekce \ref{tab.grafBase}). Běh v jednom vláknu. Počet seskupovaných výsledků je 222498869.}
\label{figure.webberkstanGroupByST}
\end{figure}

\begin{figure}[!htp]
\includegraphics[width=\linewidth]{../img/skitterGroupByST.pdf}\centering
\caption{Doba vykonání dotazů Group by pro graf As-Skitter (sekce \ref{tab.grafBase}). Běh v jednom vláknu. Počet seskupovaných výsledků je 453674558.}
\label{figure.skitterGroupByST}
\end{figure}

Na obrázcích \ref{figure.amazonGroupByST}, \ref{figure.webberkstanGroupByST} a \ref{figure.skitterGroupByST} vidíme výsledky Group by pro běh v jednom vlákně.
Dvojice dotazů G\_Q3/G\_Q6, G\_Q2/G\_Q5 a G\_Q4/G\_Q7 jsou pouze mírně rozličná a můžeme u nich vidět konzistenci výsledků pro použité grafy.
Řešení vykonávající Group by v průběhu vyhledávání překonávají Normal řešení. 
Nejznačnější zrychlení nastává u Streamed řešení, kdy není použita tabulka výsledků vyhledávání.
Velice mírné zrychlení můžeme vidět u Half-Streamed řešení.
Je to způsobeno implementací použité tabulky pro výsledky vyhledávání. 
Ačkoliv se ukládá výsledek jen pokud pro něj neexistuje skupina, tak reference na pole obsahující výsledek vyhledávání se uloží do položky \verb+temporaryRow+ (sekce TODO).
A ve výsledku částečně simuluje kopírování jedné proměnné do tabulky. 
Největší skok pak právě nastává v dotazech G\_Q3 a G\_Q6, kdy se ukládají dvě proměnné.
Platí, že použité ukládání List je pomalejší než Bucket, kvůli indirekci navíc. 
To neplatí v dotazech G\_Q3 a G\_Q6, kde je zastoupeno nejvíce vytvářených skupin mezi ostatními dotazy.
Přehození rolí si vysvětlujeme overheadem za množství vytvářených polí, které se vyrovná použité indirekci.

Paralelní řešení používají doposud zmíněná značení.
Global řešení seskupuje výsledky globálně pomocí paralelní mapy (\verb+ConcurrentDictionary+).
Two-Step řešení seskupuje výsledky nejdříve lokálně pomocí mapy a následném mergi do paralelní mapy.

