\chapter{Implementace}
\label{impl}
   
Dokončili jsme analýzu, návrh a návrh úprav dotazovacího enginu.
V této kapitole popíšeme implementaci.
Začneme výběrem jazyka, obecným rozložením aplikace, popisu hlavních bloků a skončíme konkrétnějším pohledem na vybrané části aplikace.

\section{Výběr jazyka}

Aplikaci jsme se rozhodli implementovat v jazyce C\# pro .NET Framework 4.8.
K výběru jazyka jsme měli několik důvodů.
Framework nabízí množství knihoven, modulů a základních datových struktur.
Dále také poskytuje nástroje pro práci ve vícevláknovém prostředí.
Uvažovali jsme ještě o jazyku C++, který nabízí množství technik a možností optimalizace k získání rychlosti při vykonávání aplikace. 
Nyní zmíníme, že hlavním cílem práce není vyvinou co nejrychlejší dotazovací engine, ale otestovat obecný koncept vykonávání Group by a Order by v průběhu prohledávání grafu.
Myslíme, že tento koncept se dá implementovat v každém jazyce.
Navíc, v průběhu analýzy jsme si zkoušeli již implementovat určité koncepty v daném jazyce C\#, abychom měli lepší předhled o způsobech vykonání.
Z tohoto důvodu jsme měli určité části již naimplementovány.
Výsledně jsme se rozhodli z výše zmíněných důvodu použít C\# pro .NET Framework 4.8.

\section{Značení módů}

Než přistoupíme k popisu aplikace, tak si musíme vyjasnit základní značení módů.
Určili jsme, že engine bude pracovat v několika módech, které uživatel bude moct měnit.
Jsou to módy:

\begin{itemize}

\item \textbf{Normal:} reprezentuje původní způsob vykonávání.
V prvním kroku dojde k prohledání grafu a uložení výsledků do tabulky.
Teprve po dokončení dojde vykonání Group by a Order by.

\item \textbf{Half-Streamed:} Reprezentuje upravené vykonávání. 
Tento mód v paralelním vykonání ukládá výsledky nejdříve lokálně a po dokončení dojde ke slévání.

\item \textbf{Streamed:} Reprezentuje upravené vykonávání. 
Tento mód v paralelním vykonání zpracovává výsledky globálně.
\end{itemize}

Samotná individuální řešení se pro upravené módy \textbf{Half-Streamed} a \textbf{Streamed} liší pouze v paralelním vykonávání.
V určitých případech nastane, že i jednovláknová řešení jsou rozdílná.
V takovou chvíli na to upozorníme.
V průběhu této kapitoly se budeme držet tohoto značení.




\section{Rozložení aplikace}

Při implementaci aplikace jsme vycházeli z analýzy a návrhu z předchozí kapitoly.
Aplikaci jsme vyvíjeli jako projekt konzolové aplikace pro .NET Framework 4.8 v prostředí Visual Studia 2019.
Samotný projekt je rozdělený na tři hlavní řešení:

\begin{itemize}

\item \texttt{QueryEngine}, který představuje implementaci dotazovacího enginu.
\item \texttt{HPCsharp} \citep{hpcsharp} je doprovodné řešení, které poskytuje sadu mnoha výkonných jednovláknových i paralelních algoritmů.
\item \texttt{Benchmark}, který jsme implementovali pro porovnání upraveného a původního způsobu zpracování dotazu. 

\end{itemize}

V průběhu celé kapitoly se budeme věnovat pouze řešení \texttt{QueryEngine}, protože obsahuje hlavní část práce.
Řešení \texttt{Benchmark} je popsáno podrobněji v kapitole \ref{expr}. Experiment, ve které se věnujeme porovnání implementovaných řešení.
Z \texttt{HPCsharp} řešení jsme využili pouze určité algoritmy při implementaci části Order by.
Samotná implementace algoritmů lze nalézt v odkazu citovaného zdroje. 
Nyní popíšeme podrobněji rozložení řešení \texttt{QueryEngine}.

\subsection{Rozložení řešení QueryEngine}

Řešení neobsahuje další podřešení, ale pouze adresáře.
Níže popsané adresáře rozdělují engine práve na hlavní části výstavby z kapitoly analýzy.
Hlavní adresáře jsou:

\begin{itemize}

\item \texttt{DB}: obsahuje objekty grafových elementů, struktury reprezentace grafu, objekty vlastností elementů a objekty k načítání grafových dat. 

\item \texttt{DataFiles}: obsahuje datové soubory, které se při překladu projektu ve Visual Studiu překopírují k binárním souborům.

\item \texttt{Parser}: obsahuje metody parsování uživatelského dotazu, definované tokeny, objekty parsovacího stromu a objekty k procházení daného stromu.

\item \texttt{Query}: obsahuje objekty zpracování dotazu. 
Obecně představuje část, která vykonává Group by a Order by po dokončení prohledávání grafu. 

\item \texttt{QueryStreamed}: obsahuje objekty upraveného zpracování dotazu. 
Obecně představuje část, která vykonává Group by a Order by v průběhu prohledávání grafu.
Adresář částečně kopíruje strukturu adresáře \texttt{Query}.
Pokud jsou názvy složek stejné znamená to, že objekty ve složce rozšiřují právě objekty ze stejnojmenné složky uvnitř \texttt{Query}. 
Obsahuje řešení pro Streamed i Half-Streamed módy.

\end{itemize}

Podrobnější popis adresářové struktury:

\clearpage
\dirtree{%
.1 /.
.2 DB.
.3 Creator \DTcomment{Definuje api čtení vstupních souborů.}. 
.3 GraphElement \DTcomment{Definuje objekty elementů grafu.}.
.3 Processor \DTcomment{Definuje tvorbu objektů grafu.}.
.3 Table \DTcomment{Definuje typ v Property grafu.}.
.4 Property \DTcomment{Definuje vlastnosti typu v Property grafu.}.
.2 DataFiles. 
.2 Parser.
.3 ParsedPattern \DTcomment{Definuje objekty parsovaných posloupností části Match.}.
.3 Parser.
.4 ParseTree \DTcomment{Definuje objekty použité k tvorbě parsovacího stromu.}.
.5 Visitor \DTcomment{Definuje objekty procházení parsovacího stromu.}.
.4 ParserComponent \DTcomment{Definuje metody parsování tokenů dotazu.}.
.3 Tokenizer \DTcomment{Definuje tokeny a způsob tokenizace vstupu.}.
.2 Query.
.3 Expression \DTcomment{Obsahuje logiku výrazů.}.
.4 ExpressionComparer \DTcomment{Definuje porovnávání hodnot dvou výrazů.}.
.4 Reference \DTcomment{Defunuje výrazy odkazů na proměnné, jejich vlastnosti a agregační funkce.}.
.3 GroupBy \DTcomment{Definuje objekty důležité k vykonání Group by.}.
.4 Aggregate.
.5 AggregateFunction \DTcomment{Definuje logiku agregačních funkcí.}.
.4 AggregateInternalResults \DTcomment{Definuje úložiště hodnot agregačních funkcí.}.
.4 MultiGroupGroupBy \DTcomment{Definuje řešení, pokud je zadano Group by.}.
.5 EqualityComparer \DTcomment{Definuje porovnání záznamů v hašovací tabulce.}.
.5 Hasher \DTcomment{Definuje hašování výrazů.}.
.5 ParallelSolutions \DTcomment{Definuje paralelní vykonání Group by.}.
.6 GlobalGroupBy.
.6 LocalGroupByLocalTwoWayMerge.
.6 TwoStepGroupBy.
.5 ReferenceSingleThreadSolutions \DTcomment{Definuje jednovláknové vykonání Group by.}.
.4 SingleGroupGroupBy \DTcomment{Definuje řešení, pokud není zadáno Group by.}.
.3 Match \DTcomment{Definuje objekty důležité k vykonání Match.}.
.4 DFSMatch \DTcomment{Definuje obejekty DFS prohledávání.}.
.5 BaseMatch \DTcomment{Definuje objekty vzoru.}.
.5 Matcher \DTcomment{Definuje objekty algoritmu prohledávání.}.
.6 DFSParallelPatternMatcher \DTcomment{Definuje paralelní prohledávání.}.
.6 DFSPatternMatcher \DTcomment{Definuje jednovláknové prohledávání.}.
.5 Pattern \DTcomment{Definuje api vzoru.}.
.4 MatchInternalResults \DTcomment{Definuje interní struktury Match pro ukládání výsledků prohledávání.}.
.3 OrderBy \DTcomment{Definuje objekty důležité k vykonání Order by.}.
.4 Comparer \DTcomment{Definuje porovnání řádků tabulky pomocí proxy třídy.}.
.5 Wrappers \DTcomment{Definuje porovnání řádků tabulky pomocí indexu.}.
.4 Sorter \DTcomment{Definuje algoritmy třídění.}.
.6 TableSorter \DTcomment{Definuje algoritmy třídění tabulky.}.
.3 Results \DTcomment{Definuje tabulky výsledků.}.
.4 GroupByResults \DTcomment{Definuje formát tabulky výsledků Group by.}.
.4 TableResults \DTcomment{Definuje formát tabulky pouze pro elementy grafu.}.
.3 Select \DTcomment{Definuje objekty důležité k vykonání Select.}.
.4 ExpressionToStringWrapper  \DTcomment{Definuje objekt převodu hodnoty výrazu na řetězec.}.
.4 Formater  \DTcomment{Definuje formát výstupu.}.
.4 Printer  \DTcomment{Definuje kam se má výstup vypsat.}.
.2 QueryStreamed.
.3 GroupBy  \DTcomment{Definuje objekty důležité pro upravené vykonání Group by.}.
.4 AggregateInternalResults  \DTcomment{Definuje upravené úložište agregačních funkcí pro Streamed mód.}.
.4 MultiGroupGroupBy  \DTcomment{Definuje Streamed a Half-Streamed řešení, pokud je zadáno Group by.}.
.5 BucketKeyValueFactory  \DTcomment{Definuje výrobu klíče hašovací tabulky pro Streamed mód.}.
.5 Comparers  \DTcomment{Definuje porovnání využité Half-Streamed a Streamed módem.}.
.4 SingleGroupGroupBy \DTcomment{Definuje Streamed a Half-Streamed vykonání, pokud není zadáno Group by.}.
.3 Match  \DTcomment{Definuje objekty důležité pro upravené vykonání Group by.}.
.4 DFSMatch  \DTcomment{Definuje pozměněná api pro předávání výsledků částem v průběhu hledání.}.
.5 Matcher.
.6 DFSParallelPatternMatcher.
.6 DFSPatternMatcher.
.3 OrderBy \DTcomment{Definuje objekty důležité pro upravené vykonání Order by.}.
.4 ABTree \DTcomment{Definuje použité vyhledávací stromy.}.
.4 Sorter \DTcomment{Definuje Half-Streamed a Streamed vykonání pomocí vyhledávacích stromů.}.
.5 ABTreeSorterHalfStreamed.
.5 ABTreeSorterStreamed.
.6 Comparer.
.7 Wrapper \DTcomment{Definuje porovnání akumulovaných skupin pomocí proxy třídy.}.
.4 TypeRangeHasher \DTcomment{Obsahuje objekty, které rozdělují rozsah typu na přihrádky.}.
.3 Results \DTcomment{Definuje upravené fotmáty tabulek výsledků.}.
.4 GroupByResults.
.4 TableResults.
.5 ABTree \DTcomment{Formát tabulky pro řešení s normálním (a, b)-stromem.}.
.5 ABTreeAccum \DTcomment{Formát tabulky pro řešení s (a, b)-stromem, který akumuluje shodné řádky.}.
}

\section{Programátorská dokumentace}

V této sekci popíšeme postupně klíčové objekty, položky a způsoby vypracování aplikace.  

\subsection{Třída Element}

Budeme postupovat dle analýzy.
Všechny elementy grafu dědí od abstraktní třídy \texttt{Element}.
Hlavní vlastnosti jsou:
\begin{itemize}
\item \texttt{int ID} je inikátní identifikátor elementu. Definuje jej uživatel ve vstupním souboru. Není to vlastnost v Property grafu.
\item \texttt{Table Table} odkaz na typ v Property grafu.
\item \texttt{int PositionInList} pozice v \texttt{List<T>}, kde \texttt{T} je potomek třídy \texttt{Element}, protože každý potomek je obsažen v poli.
\end{itemize}

Potomci abstraktní třídy jsou \texttt{Vertex} a \texttt{Edge}.
\texttt{Edge} přidává novou položku \texttt{Vertex EndVertex}, která odkazuje na koncový vrchol hrany.
Z dané třídy vznikají potomci \texttt{InEdge} a \texttt{OutEdge}.
Hrany jsou orientované a spojují dva vrcholy.
Mějme hranu z vrcholu x do y.
Položka \texttt{Endvertex} pro \texttt{OutEdge} zde odkazuje na vrchol y.
Pro \texttt{InEdge} to je x.
Tedy pro každou definovanu hranu v grafu existují obě instance tříd. 
Instance sdílejí \texttt{ID}, ale záznam v \texttt{Table} je pouze jeden, tedy sdílejí hodnoty vlastností. 
\texttt{Vertex} přidává položky dvou dvojic indexů, o kterých jsme mluvili v analýze.
První dvojice je \texttt{int OutEdgesStartPosition} a \texttt{int OutEdgesEndPosition}, které označují rozsah hran v poli \texttt{OutEdge} náležících vrcholu.
Druhá dvojice je pro typ \texttt{InEdge} ekvivalentí.

\subsection{Třída Table}

Třída \texttt{Table} určuje typ elementu v Property grafu.
Hlavní vlastnosti jsou:
\begin{itemize}
\item Položka \texttt{string IRI} je název typu.
\item Položka \texttt{Dictionary<int, int> IDs}, kde klíčem je \texttt{ID} elementu a hodnota je pozice hodnot vlastností ve struktuře, která je obsahuje.
\item Položka \texttt{Dictionary<int, Property>}, kde klíč je \texttt{ID} vlastnosti a hodnota je třída reprezentující vlasnost.
\item \texttt{bool TryGetPropertyValue<T>(int id,int propID, out T retValue)}\\* 
je metoda, která se pokusí získat hodnotu vlastnosti \texttt{propID} pro daný element s daným \texttt{id}.
Hodnota se vrací v \texttt{retValue}. Úspěšně dokončená vrací \texttt{true}, jinak \texttt{false}.
\end{itemize}

\subsection{Třída Property}

Samotné vlastnosti jsou reprezentovány abstraktní třídou \texttt{Property}, která má svůj nazev \texttt{string IRI}.
Z třídy vznikají abstraktní generické třídy \texttt{Property<T>}, kde \texttt{T} je typ hodnot vlastnosti.
Třída obsahuje pole hodnot \texttt{List<T> propHolder}.
Z třídy pak vznikají konkrétní třídy:
\begin{itemize}
\item \texttt{StringProperty}, kde \texttt{T} je \texttt{string}. Odpovídá typu \texttt{string} ve vstupním JSON schématu.
\item \texttt{IntProperty}, kde \texttt{T} je \texttt{Int32}. Odpovídá typu \texttt{integer} ve vstupním JSON schématu.
\end{itemize}
V analýze jsme se rozhodli implementovat pouze tyto dva typy. 
Což znamená, že v celém enginu bude možno pracovat \textbf{pouze s těmito dvěma typy}.
Tyto třídy mají metodu \texttt{void ParsePropFromStringToList(string strProp)}, která se používá při načítání hodnot ze vstupních souborů.
Převede hodnotu \texttt{strProp} na svůj typ \texttt{T} a uloží na konec pole \texttt{propHolder}.
Každý element v \texttt{Table} má svou hodnotu vlastnosti v poli na pozici \texttt{IDs[Element.ID]}.
Třídy vlastností se vytvářejí pomocí třídy \texttt{PropertyFactory}, která implementuje Factory metodu \citep[str. 107]{patterns} \texttt{Property CreateProperty(string token, string name)}.
Kde \texttt{token} je typ vlastnosti a \texttt{name} je její název.

\subsection{Třída Graph}
Třída \texttt{Graph} pak reprezentuje celý graf.
Načítá grafová data během inicializace.
Zároveň dělá kontrolu načtených vlastností a jejich typů během načítání.
Obsahuje pole všech typů elementů. Tedy \texttt{List<Vertex>}, \texttt{List<InEdge>} a \texttt{List<OutEdge>}.
Obsahuje dále:
\begin{itemize}
\item \texttt{Dictionary<string, Table> nodeTables} všechny typy vrcholů Property grafu. To samé pro hrany.
\item \texttt{Dictionary<string, Tuple<int, Type> > labels} mapa, kde klíč je název vlastnosti a \texttt{int} je její přiřaděný unikátní identifikátor, abychom nemuseli v enginu používat řetězce jako \texttt{ID} vlastnosti.
\texttt{Type} je pak typ vlastnosti, slouží pro kontrolu, protože dvě stejnojmenné vlastnosti musí mít stejný typ. 
\end{itemize}

\subsection{Čtení vstupních souborů}

Rozdhodli jsme se použít totožný vstupní formát dat jako při analýze.
Při spuštění program očekává čtyři soubory.
Dva soubory se zmiňovaným JSON formátem \textit{EdgeTypes.txt} (schéma hran) a \textit{NodeTypes.txt} (schéma vrcholů), které definují typy Property grafu a jejich vlastnosti.
Další dva soubory \textit{Edge.txt} a \textit{Nodes.txt} obsahují samotná data s mezerami jako oddělovače.
Jediná úprava formátu je ta, že hrany v datovém souboru musí být seřazeny podle \texttt{ID} počátečního vrcholu hrany tak, jak jsou vrcholy seřazeny v jejich datovém souboru.
To zmanená, že pokud máme v souboru vrcholů za sebou vrcholy s \texttt{ID} 1, 2 a 3, tak soubor hran musí nejdříve obsahovat hrany začínající vrcholem s \texttt{ID} 1, pak s \texttt{2} apod.

Načítání je implementováno následovně.
\texttt{interface Creator<T>} s metodou \texttt{T Create()} je rozhraní pro tvorbu objektů \texttt{T}.
Tento vzor rozšíříme na třídu \texttt{CreatorFromFile<T>}, která symbolizuje tvorbu objektu \texttt{T} postupným čtením souboru.
Třída očekává při incializaci rozhraní \texttt{IReader} čtoucí vstupní soubor metodou \texttt{string Read()}, která přečte vždy určitý úsek souboru.
Dále třídu vytvářející iterativně \texttt{T} na základě poskytnutých částí souboru rozhraním \texttt{IProcessor}.
Protože text je čtený po částech, tak \texttt{IProcessor} implementuje návrhový vzor State \citep[str. 305]{patterns}.
V našem případě nejdříve zpracujeme soubory schémat pomocí třídy \texttt{TableDictProcessor}, která vytváří třídy \texttt{Table}.
Následně čtením datového souboru \textit{Nodes.txt} vytvoříme pole vrcholů pomocí třídy \texttt{VerticesListProcessor}.
A posledně čtením datového souboru \textit{Edges.txt} vytvoříme dva pole \texttt{InEdge} a \texttt{OutEdge} třidou \texttt{EdgeListsProcessor}. 
Všechny tyto třídy implementují \texttt{IProcessor}.

\subsection{Třída Tokenizer}

Implementaci jsme provedli přesně podle analýzy.
V prvním kroku dojde k tokenizaci uživatelského dotazu pomocí třídy \texttt{Tokenizer}.
Uživatel zadá do konzole svůj dotaz a třída provede tokenizaci.
Výstupem tokenizace je pole \texttt{List<Token>}, které obsahuje všechny nalezené tokeny.
Tokenem zde myslíme \texttt{struct Token}, který obsahuje dvě položky.
První je \texttt{TokenType type}, což je typ tokenu.
Druhá je \texttt{string strValue}, která obsahuje hodnotu tokenu, pokud se jedná o token \texttt{Identifier}.
Tomu odpovída například název proměnné.
Pole tokenů se předá statické třídě \texttt{Parser}.

\subsection{Třída Parser}

Třída postupně z tokenů vytváří parsovací stromy každé hlavní části dotazu, jak jsme popsali v analýze.
Parsování se vyvolá uživatel veřejnou metodou \texttt{Parse(List<Token> tokens)}.
Parsování tokenů probíhá po částech.
Každá hlavní část dotazu má svou separátní metodu.
Například \texttt{ParseMatch(ref int position, .. tokens)} parsuje část Match. 
V průběhu parsování částí se rekurzivně volájí další metody.
V průběhu rekurze se používá parametr \texttt{position}, který udržuje pozici aktuálně parsovaného tokenu.

Parsovací stromy jsou tvořeny potomky asbtraktní třídy \texttt{Node}, která implementuje návrhový vzor Visitor, tj. metodu \texttt{Accept<T>(IVisitor<T>)}.
Rozhraní \texttt{IVisitor<T>} implementuje druhou část vzoru, tj. metody \texttt{Visit(..)}.
Každá část dotazu má svůj objekt implementující \texttt{IVisitor<T>}, například Match má objekt \texttt{MatchVisitor}.
Parametr \texttt{T} je zde návratová hodnota procházení parsovacího stromu.
Výstupem třídy \texttt{Parser} je množina všech vzniklých parsovacích stromů.
Samotná tokenizace a parsování se provádí při inicializaci třídy \texttt{Query}.
Procházení parsovacích stromů je rovněž prováděno při inicializaci dané třídy.

\subsection{Třída Query}

Třída reprezentuje celý dotaz.
Obsahuje všechny struktury, které se využívají pro vykonání dotazu.
Objekt je používán uživatelem.
Poskytuje statické veřejné metody \texttt{Query Create(..)} a \texttt{void Compute()}.
Metoda \texttt{void Compute()} spustí vykonání dotazu.
Metoda \texttt{Query Create(..)} vytváří dotaz.
Daná metoda dostává množství argumentů, vypíšeme ty hlavní:
\begin{itemize}
\item \texttt{string/TextReader inputQuery}: definuje dotaz uživatele, který se má vykonat. \texttt{string} zde reprezentuje vstup jako řetězec. \texttt{TextReader} představuje vstup z konzole.
\item \texttt{QueryMode mode}: definuje jaký mód vykonávání se má provádět.
\item \texttt{Graph graph}: definuje graf, nad kterým se má dotaz provést.
\item \texttt{ThreadCount threadCount}: definuje počet vláken, které se mají využít při vykonávání.
\item \texttt{GrouperAlias grouperAlias}: definuje jaké řešení se má použít při vykonávání Group by.
\item \texttt{SorterAlias sorterAlias}: definuje jaké řešení se má puužít při vykonávání Order by.
\end{itemize}
Při zavolání metody dojde k tokenizaci \texttt{inputQuery} a konrole všech argumentů metodou \texttt{CheckArgs}.
Zkontrolované argumenty a pole \texttt{List<Token>} se předají privátnímu konstruktoru třídy \texttt{Query}.
Upravené módy sdílí konstruktor. Mód \textbf{Normal} má separátní konstruktor.
Uvnitř obou konstruktorů dochází k parsování pole tokenů třídou \texttt{Parser}.
Výstupem jsou stromové struktury hlavních částí dotazu, které jsou dále použity k inicializaci privátních položek a exekučního plánu:
\begin{itemize}
\item \texttt{VariableMap variableMap}: je seznam proměnných vyskytujících se v dotazu. Seznam obsahuje jejich přidělený identifikátor a typ, pokud byl definován.
\item \texttt{QueryObject query}: je exekuční plán. Obsahuje řetězec objektů, které postupně vykonávají dotaz.
\item \texttt{QueryExecutionHelper qEhelper}: obsahuje informace o způsobu vykonání dotazu. Převážne obsahuje argumenty konstruktoru. 
\item \texttt{QueryExpressionInfo exprInfo}: obsahuje všechny výrazy (expressions) v dotazu.
\end{itemize}
Po inicializaci, v moment volání metody \texttt{Compute()} dojde k vyvolání metody \texttt{Compute(..)} na exekučním plánu.

\subsection{Třída QueryObject}

Třídu jsme navrhli v analýze.
Jedná se o abstraktní třídu.
Každá hlavní část dotazu je reprezentována potomkem dané třídy (\texttt{MatchObject}, \texttt{SelectObject}, ...).
Třída definuje rozhraní exekučního plánu.
Obsahuje:
\begin{itemize}
\item Položku \texttt{QueryObject next}, která propojuje objekt s dalším objektem.
\item Metodu \texttt{void Compute(out ITableResults r,} \texttt{out GroupByResults g)}, která rekurzivné volá stejnou metodu na dalším objektu.
Každý potomek třídy si implementuje vlastní logiku zpracování této metody.
Všimněme si, že tato metoda definuje rozhraní pro předávání výsledků zpracování.
\texttt{ITableResults} definuje obecné rozhraní tabulky výsledků hledání, pokud není zadáno Group by.
\texttt{GroupByResults} definuje formát výsledků Group by.
\item Metodu \texttt{void AddToEnd(QueryObject queryObject)}, která připojí \\*poskytnutý objekt na konec řetězce.
\end{itemize}
Konkrétní potomci třídy jsou vytvářeny v konstruktoru třídy \texttt{Query}.
Navíc, každý potomek očekává v konstruktoru parsovací strom.
Uvnitř kontruktoru dojde k vytvoření adekvátního \texttt{IVisitor<T>} objektu.
Návratová hodnota \texttt{T} se využije ke konstrukci privátních objektů pro vykonání dotazu.

\subsection{Třída MatchObject}

Třída reprezentuje Match část dotazu.
Je potomkem třídy \texttt{MatchObjectBase}, která je potomkem \texttt{QueryObject}.
Daný mezikrok vznikl, protože objekt části Match upraveného zpracování používá stejnou motodu ke kontrole vzoru uživatele \texttt{ParsedPatternCorrectness}.
Metoda kontroluje uživatelem zadaný vzor, jestli splňuje podmínky jazyka PGQL. 
Metoda očekává na vstupu pole tříd, které je výstupem procházení parsovací stromové struktury objektem \texttt{MatchVisitor}. 

\subsubsection{Třída ParsedPattern}
\texttt{MatchVisitor} vytváří procházením stromu pole tříd \texttt{List<ParsedPattern>}.
Třída \texttt{ParsedPattern} reprezentuje jednu vyhledávací posloupnost Match části (např. \texttt{(x) -> (y)}).
V poli je tolik tříd, kolik je v dotazu posloupností oddělených čárkou.
Třída bsahuje:
\begin{itemize}
\item Pole abstraktních tříd \texttt{List<ParsedPatternNode>}.
Třída reprezentuje jeden hledaný element v posloupnosti, tj. hrana nebo vrchol (\texttt{(x)}/\texttt{-[e]>}).
Obsahuje položky \texttt{string Name}, pokud je element označen proměnnou (např. vrchol \texttt{(x)}), a \texttt{Table Table} pokud je definován typ elementu (např. vrchol \texttt{(:Type)}).
Potomci specifikují konkrétní případy vrcholů a hran.

\item Položka \texttt{string splitBy}, která označuje jméno proměnné, podle které posloupnost budeme dělit na dvě posloupnosti v průběhu vytváření objektu vzoru.
Výsledkem dělení budou tedy dvě třídy \texttt{ParsedPattern}.
Část před proměnnou bude tvořit posloupnost převrácenou.
To znamená, pokud máme posloupnost tříd \texttt{ParsedPatternNode} \texttt{(x) -> (y) -> (z)} a dělíme podle \texttt{(y)}, pak výsledkem dělení jsou posloupnosti 
\texttt{(y) <- (x)} a \texttt{(y) -> (z)}.

\item Metodu\\* \texttt{bool TryFindEqualVariable(ParsedPattern p, out string n)}, která \\*vrátí název první sdílené proměnné s posloupností \texttt{p}, pokud nějaká existuje.
Pokud existuje, metoda vrací \texttt{true} a název v \texttt{n}.

\item Metodu \texttt{void TrySplitParsedPattern()}, která zkusí provést rozdělení posloupnosti.
Rozdělení se nemusí provést, pokud je rozdělováno podle první položky \texttt{List<ParsedPatternNode>}. 
Pokud je rozdělováno podle poslední, posloupnost se pouze převrátí.

\end{itemize}
Z daného formátu se během vytváření struktur Match části vytvoří finální hledaný vzor s pomocí zmíněný metod a položek.

\subsection{Třída DFSPattern}

Třída reprezentuje hledaný vzor.
Konstruktor dostane pole \texttt{ParsedPattern}.
V analýze jsme řekli, že se z posloupnosti vytvoří souvislé kompomenty.
Aplikováním výše zmíněných metod nalezneme sdílené proměnné.
Pole, která sdílejí proměnnou, seskupíme k sobě a samotné posloupnosti rozdělíme pomocí položky \texttt{splitBy}.
Výsledkem bude pole posloupností a souvislé komponenty v něm budou obsaženy postupně za sebou.
Příklad seskupení a rozdělení:
\begin{code}
Původní List<ParsedPattern> a unitř List<ParsedPatternNode>:
[[(x), ->, (z)], [(r), ->, (q)], [(y), ->, (x), ->, (w)]]
Pole po zpracovní:
[[(x), ->, (z)], [(x), <-, (y)], [(x), ->, (w)], [(r), ->, (q)]]
\end{code}
Zde vidíme, že první tři posloupnosti po zpracování tvoří souvislou komponentu, ale v původně nebyli v poli za sebou.
V průběhu hledání budeme vždy iterovat po daných posloupnostech.
V moment nalezení vhodného elementu se posuneme na další prvek posloupnosti nebo novou posloupnost.
To symbolizuje DFS krok zanoření.
Opačně se posouváme doleva a zkoušíme ještě neprohledané elementy grafu.
Díky rozdělení můžeme při přesouvání na začátek další posloupnosti vždy navázat již nalezenou proměnnou, pokud existuje a jedná o součást aktuální komponenty.
Z pole posloupnosti nyní vytvoříme pole \texttt{DFSBaseMatch[][] patterns}.
\texttt{patterns[i]} znamená přístup k \textit{i}-té posloupnosti a \texttt{patterns[i][j]} přístup k \textit{j}-té položce  \textit{i}-té posloupnosti. 

Vzor kromě \texttt{patterns} obsahuje pole \texttt{Element[] scope}.
Pole obsahuje každou proměnnou hledání právě jednou. 
Pokud ve vzoru není žádná proměnná, tak je pole vždy prázdné.
Každá proměnná má svou pozici.
Tyto pozice budeme chápat jako \texttt{ID} proměnných v celém dotazu.
V moment nalezení vhodného elementu proměnné se element uloží do daného pole na pozici proměnné.
V moment vynořování z DFS se element z pozice smaže.
Položka se používá ke kopírování do tabulky nebo k dalšímu zpracování.

Vzor dále implementuje rozhraní \texttt{IDFSPattern} spolu s \texttt{IPattern}, které slouží k posouvání po posloupnosti.
Mají množství metod, ale vypíšeme pouze hlavní:
\begin{itemize}
\item Položka \texttt{int CurrentPatternIndex} je index aktuální posloupnosti procházení.
\texttt{patterns[CurrentPatternIndex]} vrátí aktuální posloupnost.

\item Položka \texttt{int CurrentMatchNode} je aktuální objekt \texttt{DFSBaseMatch} v posloupnosti.
\texttt{patterns[CurrentPatternIndex][CurrentMatchNode]} je aktuální objekt \texttt{DFSBaseMatch}.

\item Metoda \texttt{void PrepareNextSubPattern()} připraví k procházení následující posloupnost.
\item Metoda \texttt{void PreparePreviousSubPattern()} připraví k procházení předchozí posloupnost.
\item Metoda \texttt{void PrepareNextNode()} připraví k procházení následující objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{void PreparePreviousNode()} připraví k procházení předchozí objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{Element[] GetMatchedVariables()} vrátí \texttt{scope} vzoru.
\end{itemize}

\subsubsection{Třída DFSBaseMatch}

\texttt{DFSBaseMatch} je abstraktní třída, reprezentující jeden element procházení grafu.
Třída obsahuje:
\begin{itemize}
\item Položku \texttt{bool isAnonnymous} která říká, jestli se jedná o proměnnou.
\item Položku \texttt{bool isFirstAppearance} která říká, pokud se jedná o proměnnou, jestli už je to její první nález.
\item Položku \texttt{int positionOfRepeatedField} která říká, pokud to není první nález proměnné, tak kde v \texttt{scope} se nachází. 
\item Metodu \texttt{bool Apply(Element e, Element[] map)}, která ověřuje jestli \\*element \texttt{e} se dá použit v aktuálním kroku hledání.
\texttt{map} je pak \texttt{scope} vzoru, kde se případně ověří rovnost elementů opakující se proměnné. Při úspěchu vrací \texttt{true}.
\end{itemize}
Potomci pak specifikují, jestli se jedná o \texttt{Vertex}, \texttt{InEdge}, \texttt{OutEdge} nebo \texttt{AnyEdge}
Nyní popíšeme struktury ukládání výsledků vláken v průběhu hledání.

\subsubsection{Třída MatchFixedResultsInternal}

Třída obsahuje lokální tabulku výsledků vlákna při prohledávání grafu.
Každé vlákno ma odkaz na vlastní třídu v průběhu hledání.
\begin{itemize}
\item Položka \texttt{int ColumnCount} je počet sloupečků tabulky. 
\item Položka \texttt{int FixedArraySize} velikost bloků uvnitř tabulky.
\item Položka \texttt{List<Element[][]> ResTable} je tabulka výsledků. 
Je složená z bloků \texttt{Element[][FixedArraySize] block} kostantní velikosti.
\texttt{block[i]} přistupuje k \textit{i}-tému sloupečku a \texttt{block[i][j]} přistupuje k \textit{j}-té pozici \textit{i}-tého sloupečku.
\item Položka \texttt{Element[][] LastBlock} je odkaz na poslední nezaplněný blok.
\item Položka \texttt{int CurrentPosition} je odkaz na první volný index v posledním bloku.
\item Metoda \texttt{void AddRow(Element[] row)} přidá nový výsledek do tabulky.
Pokud je poslední blok zaplněn, vytvoří se nový.
Očekává se, že \texttt{row} je položka \texttt{scope} vzoru. 

\end{itemize}

\subsubsection{Třída MatchFixedResults}

Drží všechny lokální tabulky vláken v poli \texttt{MatcherFixedResultsInternal[] matcherResults}.
Třída zároveň poskytuje rozhraní pro slévání sloupečků tabulek vláken v metodě \texttt{void MergeColumn(int columnIndex)}, která slévá jeden sloupeček.
Výsledky jsou slévány do položky \texttt{List<Element[]>[] FinalMerged}.

\subsubsection{Třída DFSPatternMatcherBase}

Abstraktní třída reprezentuje základní jednovláknový algoritmus DFS prohledávání grafu.
Prohledání jsme implementovali přesně podle analýzy.
Samotný algoritmus nebudeme popisovat, ale popíšeme jen základní položky.
Třída v konstruktoru očekává vzor \texttt{DFSPattern} a graf \texttt{Graph}.
Obsahuje dva indexy \texttt{int startVerticesIndex} a \texttt{int startVerticesEndIndex}.
Dva indexy určují rozsah vrcholů z pole vrcholů \texttt{List<Vertex>}, ze kterých se má spouštět prohledávání.
Dané položky jsou inicializovány na celý rozsah pole, což odpovídá jednovláknovému zpracování.
Třída obsahuje rozhraní \texttt{void SetStartingVerticesIndeces( int start, int end)}, které nastaví daný rozsah.
Daná metoda se používá v paralelním zpracování, kdy je přidělováno malé množství vrcholů z grafu k prohledání.
Metodou \texttt{void Search()} se spustí prohledávání.
Prohledávání prochází všechny vrcholy v definovaném rozsahu a pak se ukončí.
V tento moment lze nastavit zmíněnou metodou další rozsah a opět spustit hledání.
V moment nalezení finálního výsledku se zavolá abstraktní metoda \texttt{void ProcessResult()}.
Rozhraní prohledávání neposkytuje návrat nalezených výsledků.
Pokud se výsledky mají ukládat, tak potomek dané třídy musí dostat v konstruktoru objekt úložiště.
Způsob zpracování výsledku si definují potomci.

\subsubsection{Třída DFSPatternMatcher}

Třída reprezentuje prohledává, které ukládá výsledky do tabulky v moment jejich nalezení.
Obsahuje lokální tabulku výsledků \\*\texttt{MatchFixedResults.MatcherFixedResultsInternal results}.
Přepisuje \\*metodu \texttt{void ProcessResult()} tak, že se získá pole proměnných \texttt{scope} vzoru, jehož obsah se překopíruje do tabulky.

\subsubsection{Třída DFSParallelPatternMatcher}

Třída představuje paralelní prohledávání grafu, které ukládá výsledky v moment nalezení do tabulky.
K paralelizaci prohledávání využívá instance třídy \texttt{DFSPatternMatcher}.
V konstruktoru dostává počet vláken, vzor \texttt{DFSPattern}, graf \texttt{Graph} a instanci úložiště výsledků \texttt{MatchFixedResults}.
Tento počet definuje počet instancí algoritmu prohledávání.
Implementace je jak jsme uvedli v analýze.
Obsahuje dvě hlavní položky:
\begin{itemize}
\item \texttt{MatchFixedResults results} obsahuje lokální tabulky výsledků vláken.
\item \texttt{DFSPatternMatcher[] matchers} obsahuje instance tříd algoritmů prohledávání.
Každá instance má svou lokální kopii vzoru a odkaz na tabulku výsledků.
\end{itemize}
Třída obsahuje metodu \texttt{void Search()}, která spustí práci vláken.
Vlákna při spuštění vykonávají \texttt{void WorkMultiThreadSearch(object o)} s lokálním objektem \texttt{JobMultiThreadSearch}.
Ten obsahuje instanci prohledávání a objekt \texttt{VertexDistributor}.
Objek jsme definovali v analýze. 
Drží odkaz na pole vrcholů grafu \texttt{List<Vertex>} a index posledního přiděleného vrcholu.
Množství přidělených vrcholů je definovám v jeho položce \texttt{int verticesPerRound}.
Vlákna žádají daný objekt o rozsah vrcholů k prohledávání pomocí \texttt{void DistributeVertices (ref int start, ref int end)}.
Po dokončení hledání dojde k paralelnímu slévání sloupečků tabulek.
Přidělování sloupečků ke slévání je implementováno tototožně, jako přidělování vrcholů, pomocí třídy \texttt{ColumnDistributor}.  
Třída si pamatuje index prvního nepřiděleného sloupečku \texttt{int firstFreeColumn}.
V moment dokončení metody \texttt{Search} jsou finální výsledky v \texttt{results.FinalMerged}.




\subsection{Expressions}

Návratová hodnota \texttt{ExpressionVisitor}, je ExpressionBase.
ExpressionBase představuje abtrakci výrazu (expression), kterým jsme v analýze věnovali značnou pozornost.
Samotná implementace je takměr totožná.

