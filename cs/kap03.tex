\chapter{Implementace}
\label{impl}
   
Dokončili jsme analýzu, návrh a návrh úprav dotazovacího enginu.
V této kapitole popíšeme implementaci.
Začneme výběrem jazyka, obecným rozložením aplikace, popisu hlavních bloků a skončíme konkrétnějším pohledem na vybrané části aplikace.

\section{Výběr jazyka}

Aplikaci jsme se rozhodli implementovat v jazyce C\# pro .NET Framework 4.8.
K výběru jazyka jsme měli několik důvodů.
Framework nabízí množství knihoven, modulů a základních datových struktur.
Dále také poskytuje nástroje pro práci ve vícevláknovém prostředí.
Uvažovali jsme ještě o jazyku C++, který nabízí množství technik a možností optimalizace k získání rychlosti při vykonávání aplikace. 
Nyní zmíníme, že hlavním cílem práce není vyvinou co nejrychlejší dotazovací engine, ale otestovat obecný koncept vykonávání Group by a Order by v průběhu prohledávání grafu.
Myslíme, že tento koncept se dá implementovat v každém jazyce.
Navíc, v průběhu analýzy jsme si zkoušeli již implementovat určité koncepty v daném jazyce C\#, abychom měli lepší předhled o způsobech vykonání.
Z tohoto důvodu jsme měli určité části již naimplementovány.
Výsledně jsme se rozhodli z výše zmíněných důvodu použít C\# pro .NET Framework 4.8.

\section{Značení módů}

Než přistoupíme k popisu aplikace, tak si musíme vyjasnit základní značení módů.
Určili jsme, že engine bude pracovat v několika módech, které uživatel bude moct měnit.
Jsou to módy:

\begin{itemize}

\item \textbf{Normal:} reprezentuje původní způsob vykonávání.
V prvním kroku dojde k prohledání grafu a uložení výsledků do tabulky.
Teprve po dokončení dojde vykonání Group by a Order by.

\item \textbf{Half-Streamed:} Reprezentuje upravené vykonávání. 
Tento mód v paralelním vykonání ukládá výsledky nejdříve lokálně a po dokončení dojde ke slévání.

\item \textbf{Streamed:} Reprezentuje upravené vykonávání. 
Tento mód v paralelním vykonání zpracovává výsledky globálně.
\end{itemize}

Samotná individuální řešení se pro upravené módy \textbf{Half-Streamed} a \textbf{Streamed} liší pouze v paralelním vykonávání.
V určitých případech nastane, že i jednovláknová řešení jsou rozdílná.
V takovou chvíli na to upozorníme.
V průběhu této kapitoly se budeme držet tohoto značení.




\section{Rozložení aplikace}

Při implementaci aplikace jsme vycházeli z analýzy a návrhu z předchozí kapitoly.
Aplikaci jsme vyvíjeli jako projekt konzolové aplikace pro .NET Framework 4.8 v prostředí Visual Studia 2019.
Samotný projekt je rozdělený na tři hlavní řešení:

\begin{itemize}

\item \texttt{QueryEngine}, který představuje implementaci dotazovacího enginu.
\item \texttt{HPCsharp} \citep{hpcsharp} je doprovodné řešení, které poskytuje sadu mnoha výkonných jednovláknových i paralelních algoritmů.
\item \texttt{Benchmark}, který jsme implementovali pro porovnání upraveného a původního způsobu zpracování dotazu. 

\end{itemize}

V průběhu celé kapitoly se budeme věnovat pouze řešení \texttt{QueryEngine}, protože obsahuje hlavní část práce.
Řešení \texttt{Benchmark} je popsáno podrobněji v kapitole \ref{expr}. Experiment, ve které se věnujeme porovnání implementovaných řešení.
Z \texttt{HPCsharp} řešení jsme využili pouze určité algoritmy při implementaci části Order by.
Samotná implementace algoritmů lze nalézt v odkazu citovaného zdroje. 
Nyní popíšeme podrobněji rozložení řešení \texttt{QueryEngine}.

\subsection{Rozložení řešení QueryEngine}

Řešení neobsahuje další podřešení, ale pouze adresáře.
Níže popsané adresáře rozdělují engine práve na hlavní části výstavby z kapitoly analýzy.
Hlavní adresáře jsou:

\begin{itemize}

\item \texttt{DB}: obsahuje objekty grafových elementů, struktury reprezentace grafu, objekty vlastností elementů a objekty k načítání grafových dat. 

\item \texttt{DataFiles}: obsahuje datové soubory, které se při překladu projektu ve Visual Studiu překopírují k binárním souborům.

\item \texttt{Parser}: obsahuje metody parsování uživatelského dotazu, definované tokeny, objekty parsovacího stromu a objekty k procházení daného stromu.

\item \texttt{Query}: obsahuje objekty zpracování dotazu. 
Obecně představuje část, která vykonává Group by a Order by po dokončení prohledávání grafu. 

\item \texttt{QueryStreamed}: obsahuje objekty upraveného zpracování dotazu. 
Obecně představuje část, která vykonává Group by a Order by v průběhu prohledávání grafu.
Adresář částečně kopíruje strukturu adresáře \texttt{Query}.
Pokud jsou názvy složek stejné znamená to, že objekty ve složce rozšiřují právě objekty ze stejnojmenné složky uvnitř \texttt{Query}. 
Obsahuje řešení pro Streamed i Half-Streamed módy.

\end{itemize}

Podrobnější popis adresářové struktury:

\clearpage
\dirtree{%
.1 /.
.2 DB.
.3 Creator \DTcomment{Definuje api čtení vstupních souborů.}. 
.3 GraphElement \DTcomment{Definuje objekty elementů grafu.}.
.3 Processor \DTcomment{Definuje tvorbu objektů grafu.}.
.3 Table \DTcomment{Definuje typ v Property grafu.}.
.4 Property \DTcomment{Definuje vlastnosti typu v Property grafu.}.
.2 DataFiles. 
.2 Parser.
.3 ParsedPattern \DTcomment{Definuje objekty parsovaných posloupností části Match.}.
.3 Parser.
.4 ParseTree \DTcomment{Definuje objekty použité k tvorbě parsovacího stromu.}.
.5 Visitor \DTcomment{Definuje objekty procházení parsovacího stromu.}.
.4 ParserComponent \DTcomment{Definuje metody parsování tokenů dotazu.}.
.3 Tokenizer \DTcomment{Definuje tokeny a způsob tokenizace vstupu.}.
.2 Query.
.3 Expression \DTcomment{Obsahuje logiku výrazů.}.
.4 ExpressionComparer \DTcomment{Definuje porovnávání hodnot dvou výrazů.}.
.4 Reference \DTcomment{Defunuje výrazy odkazů na proměnné, jejich vlastnosti a agregační funkce.}.
.3 GroupBy \DTcomment{Definuje objekty důležité k vykonání Group by.}.
.4 Aggregate.
.5 AggregateFunction \DTcomment{Definuje logiku agregačních funkcí.}.
.4 AggregateInternalResults \DTcomment{Definuje úložiště hodnot agregačních funkcí.}.
.4 MultiGroupGroupBy \DTcomment{Definuje řešení, pokud je zadano Group by.}.
.5 EqualityComparer \DTcomment{Definuje porovnání záznamů v hašovací tabulce.}.
.5 Hasher \DTcomment{Definuje hašování výrazů.}.
.5 ParallelSolutions \DTcomment{Definuje paralelní vykonání Group by.}.
.6 GlobalGroupBy.
.6 LocalGroupByLocalTwoWayMerge.
.6 TwoStepGroupBy.
.5 ReferenceSingleThreadSolutions \DTcomment{Definuje jednovláknové vykonání Group by.}.
.4 SingleGroupGroupBy \DTcomment{Definuje řešení, pokud není zadáno Group by.}.
.3 Match \DTcomment{Definuje objekty důležité k vykonání Match.}.
.4 DFSMatch \DTcomment{Definuje obejekty DFS prohledávání grafu.}.
.5 BaseMatch \DTcomment{Definuje objekty vzoru.}.
.5 Matcher \DTcomment{Definuje objekty algoritmu prohledávání grafu .}.
.6 DFSParallelPatternMatcher \DTcomment{Definuje paralelní prohledávání grafu.}.
.6 DFSPatternMatcher \DTcomment{Definuje jednovláknové prohledávání grafu.}.
.5 Pattern \DTcomment{Definuje api vzoru.}.
.4 MatchInternalResults \DTcomment{Definuje interní struktury Match pro ukládání výsledků prohledávání grafu.}.
.3 OrderBy \DTcomment{Definuje objekty důležité k vykonání Order by.}.
.4 Comparer \DTcomment{Definuje porovnání řádků tabulky pomocí proxy třídy.}.
.5 Wrappers \DTcomment{Definuje porovnání řádků tabulky pomocí indexu.}.
.4 Sorter \DTcomment{Definuje algoritmy třídění.}.
.6 TableSorter \DTcomment{Definuje algoritmy třídění tabulky.}.
.3 Results \DTcomment{Definuje tabulky výsledků.}.
.4 GroupByResults \DTcomment{Definuje formát tabulky výsledků Group by.}.
.4 TableResults \DTcomment{Definuje formát tabulky pouze pro elementy grafu.}.
.3 Select \DTcomment{Definuje objekty důležité k vykonání Select.}.
.4 ExpressionToStringWrapper  \DTcomment{Definuje objekt převodu hodnoty výrazu na řetězec.}.
.4 Formater  \DTcomment{Definuje formát výstupu.}.
.4 Printer  \DTcomment{Definuje kam se má výstup vypsat.}.
.2 QueryStreamed.
.3 GroupBy  \DTcomment{Definuje objekty důležité pro upravené vykonání Group by.}.
.4 AggregateInternalResults  \DTcomment{Definuje upravené úložište agregačních funkcí pro Streamed mód.}.
.4 MultiGroupGroupBy  \DTcomment{Definuje Streamed a Half-Streamed řešení, pokud je zadáno Group by.}.
.5 BucketKeyValueFactory  \DTcomment{Definuje výrobu klíče hašovací tabulky pro Streamed mód.}.
.5 Comparers  \DTcomment{Definuje porovnání využité Half-Streamed a Streamed módem.}.
.4 SingleGroupGroupBy \DTcomment{Definuje Streamed a Half-Streamed vykonání, pokud není zadáno Group by.}.
.3 Match  \DTcomment{Definuje objekty důležité pro upravené vykonání Group by.}.
.4 DFSMatch  \DTcomment{Definuje pozměněná api pro předávání výsledků částem v průběhu prohledávání grafu.}.
.5 Matcher.
.6 DFSParallelPatternMatcher.
.6 DFSPatternMatcher.
.3 OrderBy \DTcomment{Definuje objekty důležité pro upravené vykonání Order by.}.
.4 ABTree \DTcomment{Definuje použité vyhledávací stromy.}.
.4 Sorter \DTcomment{Definuje Half-Streamed a Streamed vykonání pomocí vyhledávacích stromů.}.
.5 ABTreeSorterHalfStreamed.
.5 ABTreeSorterStreamed.
.6 Comparer.
.7 Wrapper \DTcomment{Definuje porovnání akumulovaných skupin pomocí proxy třídy.}.
.4 TypeRangeHasher \DTcomment{Obsahuje objekty, které rozdělují rozsah typu na přihrádky.}.
.3 Results \DTcomment{Definuje upravené fotmáty tabulek výsledků.}.
.4 GroupByResults.
.4 TableResults.
.5 ABTree \DTcomment{Formát tabulky pro řešení s normálním (a, b)-stromem.}.
.5 ABTreeAccum \DTcomment{Formát tabulky pro řešení s (a, b)-stromem, který akumuluje shodné řádky.}.
}

\section{Programátorská dokumentace}

V této sekci popíšeme postupně klíčové objekty, položky a způsoby vypracování aplikace.  

\subsection{Reprezentace grafu}
V této sekci popíšeme hlavní objekty, které jsme použili k reprezentaci grafových dat.
Při implementaci jsme postupovali dle návrhu z sekce analýzy \ref{anal.grafrep}.

\subsubsection{Třída Element}

Všechny druhy elementů v grafu (vrchol a hrana) dědí od abstraktní třídy \texttt{Element}.
Představuje obený základ všech elementů.
Hlavní vlastnosti jsou:
\begin{itemize}
\item \texttt{int ID} je unikátní identifikátor elementu. Definuje jej uživatel ve vstupním souboru. Není to vlastnost v Property grafu.
\item \texttt{Table Table} odkaz na typ v Property grafu.
\item \texttt{int PositionInList} pozice v \texttt{List<T>}, kde \texttt{T} je potomek třídy \texttt{Element}, protože každý potomek je obsažen ve vlastním poli.
Určili jsme v analýze, kvůli jednoduché možnosti iterace elementů.
Pole jsou pak obsažená v třídě \texttt{Graph}.
\end{itemize}

Potomek abstraktní třídy je třída \texttt{Vertex} (vrchol) a abstraktní třída \texttt{Edge} (hrana).
\texttt{Edge} přidává novou položku \texttt{Vertex EndVertex}, která odkazuje na koncový vrchol hrany.
Z dané třídy vznikají konkrétní potomci \texttt{InEdge} a \texttt{OutEdge}.
Hrany jsou orientované a spojují dva vrcholy.
Mějme hranu z vrcholu x do y.
Položka \texttt{EndVertex} pro \texttt{OutEdge} zde odkazuje na vrchol y.
Pro \texttt{InEdge} to je x.
Tedy pro každou definovanu hranu v grafu existují obě instance tříd. 
Instance sdílejí \texttt{ID}, ale záznam v \texttt{Table} je pouze jeden, tedy sdílejí i hodnoty vlastností. 
\texttt{Vertex} přidává položky dvou dvojic indexů, o kterých jsme mluvili v analýze.
První dvojice je \texttt{int OutEdgesStartPosition} a \texttt{int OutEdgesEndPosition}, které označují rozsah hran v poli \texttt{OutEdge} náležících vrcholu.
Ekvivalentně pro typ \texttt{InEdge}.
Celkově tedy třída \texttt{Graph} bude obsahovat pole \texttt{List<T>} pro každého neabstraktního potomka třídy \texttt{Element}.

\subsubsection{Třída Table}

Třída \texttt{Table} určuje typ elementu v Property grafu.
Hlavní vlastnosti jsou:
\begin{itemize}
\item Položka \texttt{string IRI} je název typu.
\item Položka \texttt{Dictionary<int, int> IDs}, kde klíčem je \texttt{ID} elementu a hodnota je pozice hodnot vlastností ve struktuře, která je obsahuje (tj. třídě \texttt{Property}).
\item Položka \texttt{Dictionary<int, Property> Properties}, kde klíč je \texttt{ID} vlastnosti a hodnota je třída reprezentující vlastnost.
\item \texttt{bool TryGetPropertyValue<T>(int id,int propID, out T retValue)}\\* 
je metoda, která se pokusí získat hodnotu vlastnosti \texttt{propID} pro daný element s daným \texttt{id}.
Hodnota se vrací v \texttt{retValue}. Úspěšně dokončená vrací \texttt{true}, jinak \texttt{false}.
Pro získání hodnoty vlastnosti tedy musíme znát její typ.
\end{itemize}

\subsubsection{Třída Property}

Samotné vlastnosti jsou reprezentovány abstraktní třídou \texttt{Property}, která má svůj název \texttt{string IRI}.
Z třídy vznikají abstraktní generické třídy \texttt{Property<T>}, kde \texttt{T} je typ hodnot vlastnosti.
Třída obsahuje pole hodnot \texttt{List<T> propHolder}.
Z třídy pak vznikají konkrétní třídy:
\begin{itemize}
\item \texttt{StringProperty}, kde \texttt{T} je \texttt{string}. Odpovídá typu \texttt{string} ve vstupním JSON schématu.
\item \texttt{IntProperty}, kde \texttt{T} je \texttt{Int32}. Odpovídá typu \texttt{integer} ve vstupním JSON schématu.
\end{itemize}
V analýze jsme se rozhodli implementovat pouze tyto dva typy. 
Což znamená, že v celém enginu bude možno pracovat \textbf{pouze s těmito dvěma typy}.
Tyto třídy mají metodu \texttt{void ParsePropFromStringToList(string strProp)}, která se používá při načítání hodnot ze vstupních souborů.
Převede hodnotu \texttt{strProp} na svůj typ \texttt{T} a uloží na konec pole \texttt{propHolder}.
Každý element v \texttt{Table} má svou hodnotu vlastnosti v poli na pozici \texttt{IDs[Element.ID]}.
Třídy vlastností se vytvářejí pomocí třídy \texttt{PropertyFactory}, která implementuje Factory metodu \citep[str. 107]{patterns} \texttt{Property CreateProperty(string token, string name)}.
Kde \texttt{token} je typ vlastnosti a \texttt{name} je její název.

\subsubsection{Třída Graph}

Třída \texttt{Graph} pak reprezentuje celý graf.
Můžeme se dívat na ni spíše jako na objekt držící data grafu a ne objekt se složitou logikou.
Načítá grafová data během inicializace.
Zároveň dělá kontrolu načtených vlastností a jejich typů během načítání.
Obsahuje pole všech typů elementů. Tedy \texttt{List<Vertex>}, \texttt{List<InEdge>} a \texttt{List<OutEdge>}.
Obsahuje dále:
\begin{itemize}
\item \texttt{Dictionary<string, Table> nodeTables} všechny typy vrcholů Property grafu. To samé pro hrany v položce \texttt{edgeTables}.
\item \texttt{Dictionary<string, Tuple<int, Type> > labels} mapa, kde klíč je název vlastnosti a \texttt{int} je její přiřaděný unikátní identifikátor, abychom nemuseli v enginu používat řetězce jako \texttt{ID} vlastnosti.
\texttt{Type} je pak typ vlastnosti, slouží pro kontrolu, protože dvě stejnojmenné vlastnosti musí mít stejný typ. 
\end{itemize}


\subsection{Čtení vstupních souborů}

Máme imlementován graf a nyní jej potřebujeme načíst.
Budeme vycházet z kapitoly analýzy sekce \ref{anal.vstup}.
Rozhodli jsme se použít totožný vstupní formát dat jako při analýze.
Při spuštění program očekává čtyři soubory.
Dva soubory se zmiňovaným JSON formátem \textit{EdgeTypes.txt} (schéma hran) a \textit{NodeTypes.txt} (schéma vrcholů), které definují typy Property grafu a jejich vlastnosti.
Další dva soubory \textit{Edge.txt} (data hran) a \textit{Nodes.txt} (data vrcholů) obsahují samotná data s mezerami jako oddělovače.
Jediná úprava formátu je ta, že hrany v datovém souboru musí být seřazeny podle \texttt{ID} počátečního vrcholu hrany tak, jak jsou vrcholy seřazeny v jejich datovém souboru.
To zmanená, že pokud máme v souboru vrcholů za sebou vrcholy s \texttt{ID} 1, 2 a 3, tak soubor hran musí nejdříve obsahovat hrany začínající vrcholem s \texttt{ID} 1, pak s \texttt{2} apod.
Důvodem je zjednodušení procesu načítání.

Načítání je implementováno následovně.
\texttt{interface Creator<T>} s metodou \texttt{T Create()} je rozhraní pro tvorbu objektů \texttt{T}.
Rozhraní bude implementovat třída \texttt{CreatorFromFile<T>}, která symbolizuje tvorbu objektu \texttt{T} postupným čtením souboru.
Třída očekává při incializaci rozhraní \texttt{IReader} čtoucí vstupní soubor metodou \texttt{string Read()}, která přečte vždy určitý úsek souboru.
Dále rozhraní \texttt{IProcessor} vytvářející iterativně \texttt{T} na základě poskytnutých částí souboru.
Protože text je čtený po částech, tak \texttt{IProcessor} implementuje návrhový vzor State \citep[str. 305]{patterns}.
V našem případě nejdříve zpracujeme soubory schémat pomocí třídy \texttt{TableDictProcessor}, která vytváří třídy \texttt{Table}.
Následně čtením datového souboru \textit{Nodes.txt} vytvoříme třídou \texttt{VerticesListProcessor} pole vrcholů.
A posledně čtením datového souboru \textit{Edges.txt} vytvoříme dva pole \texttt{InEdge} a \texttt{OutEdge} třidou \texttt{EdgeListsProcessor}. 
Rozhraní \texttt{IProcessor} implementují všechny tyto třídy.
Samotné čtení souborů je vyvoláno při inicializaci třídy \texttt{Graph}.

\subsection{Parsování uživatelského dotazu} \label{impl.parsing}

Při parsování jsme vycházeli z sekce analýzy \ref{anal.parsing}.
Nejdřive dojde k tokenizaci a následně vytváření parsovacího stromu.

\subsubsection{Třída Tokenizer}

V prvním kroku dojde k tokenizaci uživatelského dotazu třídou \texttt{Tokenizer}.
Uživatel zadá aplikaci svůj dotaz a třída provede tokenizaci.
Výstupem tokenizace je pole \texttt{List<Token>}, které obsahuje všechny nalezené tokeny.
Tokenem zde myslíme \texttt{struct Token}, který obsahuje dvě položky.
První je \texttt{TokenType type}, což je typ tokenu.
Druhá je \texttt{string strValue}, která obsahuje hodnotu tokenu, pokud se jedná o token \texttt{Identifier}.
Tomu odpovída například token názvu proměnné.
Pole tokenů se předá statické třídě \texttt{Parser}.

\subsubsection{Třída Parser}

Třída postupně z tokenů vytváří parsovací stromy každé hlavní části dotazu (Match, Select, Order by a Group by).
Parsování se vyvolá veřejnou metodou \texttt{Parse(List<Token> tokens)}.
Parsování tokenů probíhá po částech.
Každá hlavní část dotazu má svou separátní metodu.
Například \texttt{ParseMatch(ref int position, List<Token> tokens)} parsuje část Match. 
Během parsování tokenů se rekurzivně volájí další metody.
Při rekurzi se používá parametr \texttt{position}, který udržuje pozici aktuálně parsovaného tokenu.

Parsovací stromy jsou tvořeny potomky asbtraktní třídy \texttt{Node}, která implementuje návrhový vzor Visitor \citep[str. 331]{patterns}, tj. definuje metodu \texttt{Accept<T>(IVisitor<T> visitor)}.
Rozhraní \texttt{IVisitor<T>} implementuje druhou část vzoru, tj. metodu \texttt{Visit(...)}, kde vstupem ja každý neabstraktní potomek třídy \texttt{Node}.
Každá část dotazu má svůj objekt implementující \texttt{IVisitor<T>}, například Match má objekt \texttt{MatchVisitor}.
Parametr \texttt{T} je zde návratová hodnota procházení parsovacího stromu.
Výstupem třídy \texttt{Parser} je množina všech vzniklých parsovacích stromů.
Samotná tokenizace a parsování se provádí při inicializaci třídy \texttt{Query}.
Procházení parsovacích stromů je rovněž prováděno při inicializaci dané třídy.

\subsection{Reprezentace dotazu}
Celý dotaz jsme reprezentovali třídou \texttt{Query}.
Exekuční plán a samotné zpracování pak bude odpovídat popisu z sekce analýzy \ref{anal.vykonanidotazu}.

\subsubsection{Třída Query}

Třída reprezentuje celý dotaz.
Obsahuje všechny struktury, které se využívají pro vykonání dotazu.
Objekt je používán uživatelem.
Poskytuje statické veřejné metody \texttt{Query Create(...)} a \texttt{void Compute()}.
Metoda \texttt{void Compute()} spustí vykonání dotazu.
Metoda \texttt{Query Create(...)} vytváří dotaz.
Daná metoda dostává množství argumentů, vypíšeme ty hlavní:
\begin{itemize}
\item \texttt{string/TextReader inputQuery}: definuje dotaz uživatele, který se má vykonat. \texttt{string} zde reprezentuje vstup jako řetězec. \texttt{TextReader} představuje vstup z konzole.
\item \texttt{QueryMode mode}: definuje jaký mód vykonávání se má provádět.
\item \texttt{Graph graph}: definuje graf, nad kterým se má dotaz provést.
\item \texttt{ThreadCount threadCount}: definuje počet vláken, které se mají využít při vykonávání.
\item \texttt{GrouperAlias grouperAlias}: definuje jaké řešení se má použít při vykonávání Group by.
\item \texttt{SorterAlias sorterAlias}: definuje jaké řešení se má puužít při vykonávání Order by.
\end{itemize}
Při zavolání metody dojde k tokenizaci \texttt{inputQuery} a kontrole všech argumentů metodou \texttt{CheckArgs}.
Zkontrolované argumenty a pole \texttt{List<Token>} se předají privátnímu konstruktoru třídy \texttt{Query}.
Upravené módy sdílí konstruktor. Mód \textbf{Normal} má separátní konstruktor.
Uvnitř obou konstruktorů dochází k parsování pole tokenů třídou \texttt{Parser}.
Výstupem jsou stromové struktury hlavních částí dotazu, které jsou dále použity k inicializaci privátních položek a exekučního plánu:
\begin{itemize}
\item \texttt{VariableMap variableMap} je seznam proměnných vyskytujících se v dotazu. Seznam obsahuje jejich přidělený identifikátor a typ, pokud byl definován.
\item \texttt{QueryObject query} je exekuční plán. Obsahuje řetězec objektů, které postupně vykonávají dotaz.
\item \texttt{QueryExecutionHelper qEhelper} obsahuje informace o způsobu vykonání dotazu. Převážne obsahuje argumenty konstruktoru. 
\item \texttt{QueryExpressionInfo exprInfo} obsahuje všechny výrazy (expressions) v dotazu.
\end{itemize}
Po inicializaci, v moment volání metody \texttt{Compute()} dojde k vyvolání metody \texttt{Compute(...)} na exekučním plánu.

\subsubsection{Třída QueryObject}

Jedná se o abstraktní třídu.
Každá hlavní část dotazu je reprezentována potomkem dané třídy (\texttt{MatchObject}, \texttt{SelectObject}, ...).
Třída definuje rozhraní exekučního plánu.
Obsahuje:
\begin{itemize}
\item Položku \texttt{QueryObject next}, která propojuje objekt s dalším objektem.
\item Metodu \texttt{void Compute(out ITableResults r,} \texttt{out GroupByResults g)}, která rekurzivné volá stejnou metodu na dalším objektu v \texttt{next}.
Každý potomek třídy si implementuje vlastní logiku zpracování této metody.
Všimněme si, že tato metoda definuje rozhraní pro předávání výsledků zpracování.
\texttt{ITableResults} definuje obecné rozhraní tabulky výsledků prohledávání, pokud není zadáno Group by.
\texttt{GroupByResults} definuje formát výsledků Group by.
\item Metodu \texttt{void AddToEnd(QueryObject queryObject)}, která připojí \\*poskytnutý objekt na konec řetězce.
\end{itemize}
Konkrétní potomci třídy jsou vytvářeny v konstruktoru třídy \texttt{Query}.
Navíc, každý potomek očekává v konstruktoru parsovací strom.
Uvnitř kontruktoru dojde k vytvoření adekvátního \texttt{IVisitor<T>} objektu.
Návratová hodnota \texttt{T} se využije ke konstrukci privátních objektů pro vykonání dotazu.

\subsection{Match}

Budeme vzcházet z sekce analýzy \ref{anal.match}.
Třída \texttt{MatchObject} reprezentuje Match část dotazu.
Je potomkem třídy \texttt{MatchObjectBase}, která dědí z \texttt{QueryObject}.
Obecně třída \texttt{MatchObject} obsahuje odkaz na tabulku výsledků prohledávání \texttt{MatchFixedResults} a odkaz na objekt reprezentující DFS algoritmus prohledávání \texttt{DFSParallelPatternMatcher}.
V konstruktoru třídy se vytváří vzor a objekt prohledávání.
Objekt prohledávání obrží vzor a tabulku pro ukládání výsledků.
Třída dědí z \texttt{MatchObjectBase}, protože objekt části Match upraveného zpracování používá stejnou metodu \texttt{ParsedPatternCorrectness} ke kontrole vzoru uživatele.
Metoda kontroluje uživatelem zadaný vzor, jestli splňuje podmínky jazyka PGQL. 
Metoda očekává na vstupu pole tříd, které je výstupem procházení parsovací stromové struktury objektem \texttt{MatchVisitor}. 

\subsubsection{Třída ParsedPattern}

\texttt{MatchVisitor} vytváří procházením stromu pole tříd \texttt{List<ParsedPattern>}.
Třída \texttt{ParsedPattern} reprezentuje jednu vyhledávací posloupnost Match části (např. \texttt{(x) -> (y)}).
V poli je tolik tříd, kolik je v dotazu posloupností oddělených čárkou.
Třída obsahuje:
\begin{itemize}
\item Pole abstraktních tříd \texttt{List<ParsedPatternNode> pattern}.
Abstraktní \\*třída reprezentuje jeden hledaný element v posloupnosti, tj. hrana  (\texttt{-[e]>}) nebo vrchol (\texttt{(x)}).
Obsahuje položky \texttt{string Name}, pokud je element označen proměnnou (např. vrchol \texttt{(x)}), a \texttt{Table Table} pokud je definován typ elementu (např. vrchol \texttt{(:Type)}).
Potomci specifikují konkrétní případy vrcholů a hran. Pokud vezmeme příklad výše \texttt{(x) -> (y)}, tak pole bude obsahovat tří třídy.
\texttt{pattern[0]} je třída vrcholu \texttt{x}, \texttt{pattern[1]} je třída \texttt{OutEdge} hrany a \texttt{pattern[2]} je třída vrcholu \texttt{y}.

\item Položku \texttt{string splitBy}, která označuje jméno proměnné, podle které posloupnost budeme dělit na dvě posloupnosti v průběhu vytváření objektu vzoru.
Výsledkem dělení budou tedy dvě třídy \texttt{ParsedPattern}.
Část před proměnnou, podle které dělíme, bude tvořit posloupnost převrácenou.
To znamená, pokud máme posloupnost tříd \texttt{ParsedPatternNode} \texttt{(x) -> (y) -> (z)} a dělíme podle \texttt{(y)}, pak výsledkem dělení jsou posloupnosti 
\texttt{(y) <- (x)} a \texttt{(y) -> (z)}.

\item Metodu\\* \texttt{bool TryFindEqualVariable(ParsedPattern p, out string n)}, která \\*vrátí název první sdílené proměnné s posloupností \texttt{p}, pokud nějaká existuje.
Pokud existuje, metoda vrací \texttt{true} a název v \texttt{n}.

\item Metodu \texttt{void TrySplitParsedPattern()}, která zkusí provést rozdělení posloupnosti.
Rozdělení se nemusí provést, pokud je rozdělováno podle první položky \texttt{List<ParsedPatternNode>}. 
Pokud je rozdělováno podle poslední, posloupnost se pouze převrátí.

\end{itemize}
Z daného formátu se během vytváření struktur Match části vytvoří finální hledaný vzor \texttt{DFSPattern} s pomocí zmíněný metod a položek.

\subsubsection{Třída DFSPattern}

Třída reprezentuje hledaný vzor (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{Pattern}).
Konstruktor dostane pole \texttt{ParsedPattern}.
V analýze jsme řekli, že se z posloupností vytvoří souvislé kompomenty.
Aplikováním výše zmíněných metod nalezneme sdílené proměnné.
Pole, která sdílejí proměnnou, seskupíme k sobě a samotné posloupnosti rozdělíme pomocí položky \texttt{splitBy}.
Výsledkem bude pole posloupností a souvislé komponenty v něm budou obsaženy postupně za sebou.
Příklad seskupení a rozdělení:
\begin{code}
Původní List<ParsedPattern> a unitř List<ParsedPatternNode>:
[[(x), ->, (z)], [(r), ->, (q)], [(y), ->, (x), ->, (w)]]
Pole po zpracovní:
[[(x), ->, (z)], [(x), <-, (y)], [(x), ->, (w)], [(r), ->, (q)]]
\end{code}
Zde vidíme, že první tři posloupnosti po zpracování tvoří souvislou komponentu, protože sdílejí proměnnou \texttt{x}, ale původně nebyli v poli za sebou.
Nulté a druhé pole sdílejí proměnnou \texttt{x}, podle které jsme druhou posloupnost dělili.
V průběhu prohledávání grafu budeme vždy iterovat po daných posloupnostech.
V moment nalezení vhodného elementu se posuneme na další prvek posloupnosti (doprava) nebo na novou posloupnost.
To symbolizuje DFS krok zanoření.
Opačně se posouváme doleva a zkoušíme ještě neprohledané elementy grafu.
Díky rozdělení můžeme při přesouvání na začátek další posloupnosti vždy navázat již nalezenou proměnnou, pokud existuje a jedná o součást aktuální komponenty.
Z pole posloupnosti nyní vytvoříme pole \texttt{DFSBaseMatch[][] patterns}.
\texttt{patterns[i]} znamená přístup k \textit{i}-té posloupnosti a \texttt{patterns[i][j]} přístup k \textit{j}-té položce  \textit{i}-té posloupnosti. 

Vzor kromě \texttt{patterns} obsahuje pole \texttt{Element[] scope}.
Pole obsahuje každou proměnnou prohledávání právě jednou. 
Pokud ve vzoru není žádná proměnná, tak je pole vždy prázdné.
Každá proměnná má svou pozici.
Tyto pozice budeme chápat jako \texttt{ID} proměnných v celém dotazu.
Toto pořadí je uchováváno v třídě \texttt{QueryVariableMap}.
V moment nalezení vhodného elementu proměnné se element uloží do daného pole na pozici proměnné.
V moment vynořování z DFS se element z pozice smaže.
Položka se používá ke kopírování do tabulky nebo k dalšímu zpracování.

Vzor dále implementuje rozhraní \texttt{IDFSPattern} spolu s \texttt{IPattern}, které slouží k posouvání po posloupnosti.
Mají množství metod, ale vypíšeme pouze hlavní:
\begin{itemize}
\item Položka \texttt{int CurrentPatternIndex} je index aktuální posloupnosti procházení.
\texttt{patterns[CurrentPatternIndex]} vrátí aktuální posloupnost.

\item Položka \texttt{int CurrentMatchNode} je aktuální objekt \texttt{DFSBaseMatch} v posloupnosti.
\texttt{patterns[CurrentPatternIndex][CurrentMatchNode]} je aktuální objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{void PrepareNextSubPattern()} připraví k procházení následující posloupnost.
\item Metoda \texttt{void PreparePreviousSubPattern()} připraví k procházení předchozí posloupnost.
\item Metoda \texttt{void PrepareNextNode()} připraví k procházení následující objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{void PreparePreviousNode()} připraví k procházení předchozí objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{Element[] GetMatchedVariables()} vrátí \texttt{scope} vzoru.
\item Metoda \texttt{bool Apply(Element[] e)} slouží ke zjištění, zda držený element je použitelný pro aktuální pozici ve vzoru.
Vyvolá stejnojmennou funkci na třídě \texttt{DFSBaseMatch}.
\end{itemize}
Nyní popíšeme třídu vytvářející pole posloupností.

\subsubsection{Třída DFSBaseMatch}

\texttt{DFSBaseMatch} je abstraktní třída, reprezentující jeden element procházení grafu.
Třída obsahuje:
\begin{itemize}
\item Položku \texttt{bool isAnonnymous} která říká, jestli se jedná o proměnnou.
\item Položku \texttt{bool isFirstAppearance} která říká, pokud se jedná o proměnnou, jestli už je to její první nález.
\item Položku \texttt{int positionOfRepeatedField} která říká, pokud to není první nález proměnné, tak kde v \texttt{scope} se nachází. 
\item Metodu \texttt{bool Apply(Element element, Element[] map)}, která ověřuje jestli element \texttt{element} se dá použit v aktuálním kroku prohledávání.
\texttt{map} je pak \texttt{scope} vzoru, kde se případně ověří rovnost elementů opakující se proměnné. Při úspěchu vrací \texttt{true}.
\end{itemize}
Potomci pak specifikují, jestli se jedná o \texttt{Vertex} (vrchol), \texttt{InEdge} (hrana vedouci do vrcholu), \texttt{OutEdge} (hrana vedouci z vrcholu) nebo \texttt{AnyEdge} (jakýkoliv druh hrany).
Ještě než popíšeme struktury algoritmu prohledávání, tak popíšeme struktury pro ukládání výsledků vláken v průběhu prohledávání grafu.

\subsubsection{Třída MatchFixedResultsInternal}

Máme implementován vzor a metody k procházení vzoru.
Nyní popíšeme implementaci ukládání výsledků prohledávání.
Třída obsahuje lokální tabulku výsledků vlákna při prohledávání grafu (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{Výsledky}). 
Každé vlákno má odkaz na vlastní třídu v průběhu prohledávání grafu.
Za finální výsledek prohledávání se považují hodnoty v poli \texttt{scope}.
Sloupečky zde tedy odpovídají unikáním proměnným v grafu.
Řádek je pak kopie daného pole.
Ukládáme pouze elementy grafu.
Uvnitř je:
\begin{itemize}
\item Položka \texttt{int ColumnCount}, která udává počet sloupečků tabulky. 
\item Položka \texttt{int FixedArraySize}, která udává velikost bloků uvnitř tabulky.
\item Položka \texttt{List<Element[][]> ResTable} je tabulka výsledků. 
Je složená z bloků \texttt{Element[][FixedArraySize] block} kostantní velikosti.
\texttt{block[i]} přistupuje k \textit{i}-tému sloupečku a \texttt{block[i][j]} přistupuje k \textit{j}-té pozici \textit{i}-tého sloupečku.
\item Položka \texttt{Element[][FixedArraySize] LastBlock} je odkaz na poslední nezaplněný blok.
\item Položka \texttt{int CurrentPosition} je odkaz na první volný index v posledním bloku.
\item Metoda \texttt{void AddRow(Element[] row)} přidá nový výsledek do tabulky.
Pokud je poslední blok zaplněn, vytvoří se nový.
Při vytváření nového bloku nemusí docházet k překopírovávání výsledků prohledávání, protože pole \texttt{ResTable} drží odkazy na zmíněné bloky.
Rozšířením pak překopíruje pouze odkazy na pole.
Očekává se, že \texttt{row} je položka \texttt{scope} vzoru. 

\end{itemize}

\subsubsection{Třída MatchFixedResults}

Třída obsahuje lokální vabulky všech vláken v položce \texttt{matcherResults}.
Takto budeme moct přistoupit k lokálním výsledkům po dokončení prohledávání grafu.
Třída zároveň poskytuje rozhraní pro slévání sloupečků tabulek vláken v metodě \texttt{void MergeColumn(int columnIndex)}, která slévá jeden sloupeček.
Výsledky jsou slévány do položky \texttt{List<Element[]>[] FinalMerged}.

\subsubsection{Třída DFSPatternMatcherBase}

Implementovali jsme vzor a ukládání výsledků.
Naní popíšeme implementaci algoritmu procházení (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{Matcher}).
Abstraktní třída reprezentuje základní jednovláknový algoritmus DFS prohledávání grafu.
Prohledání jsme implementovali přesně podle analýzy.
Samotný algoritmus nebudeme popisovat, ale popíšeme jen základní položky.
Třída v konstruktoru očekává vzor \texttt{DFSPattern} a graf \texttt{Graph}.
Obsahuje dva indexy \texttt{int startVerticesIndex} a \texttt{int startVerticesEndIndex}.
Dva indexy určují rozsah vrcholů z pole vrcholů \texttt{List<Vertex>}, ze kterých se bude spouštět prohledávání.
Dané položky jsou inicializovány na celý rozsah pole, což odpovídá jednovláknovému zpracování.
Třída má rozhraní \texttt{void SetStartingVerticesIndeces( int start, int end)} nastavující dané indexy rozsahu.
Daná metoda se používá v paralelním zpracování, kdy je přidělováno malé množství vrcholů z grafu k prohledání.
Metodou \texttt{void Search()} se spustí prohledávání grafu.
Prohledávání prochází všechny vrcholy v definovaném rozsahu a pak se ukončí.
V tento moment lze nastavit zmíněnou metodou další rozsah a opět spustit prohledávání grafu.
V moment nalezení finálního výsledku se zavolá abstraktní metoda \texttt{void ProcessResult()}, která zpracuje výsledek.
Rozhraní prohledávání neposkytuje návrat nalezených výsledků.
Pokud se výsledky mají ukládat, tak potomek dané třídy musí dostat v konstruktoru objekt úložiště a přepsat metodu \texttt{void ProcessResult()}.
Způsob zpracování výsledku si definují potomci.

\subsubsection{Třída DFSPatternMatcher}

Třída je potomkem třídy výše.
Reprezentuje algoritmus prohledávání grafu, který ukládá výsledky do tabulky v moment jejich nalezení.
V konstruktoru dostane tabulku \texttt{MatcherFixedResultsInternal}, kam ukládá své výsledky prohledávání.
Metoda \texttt{ProcessResult} tedy ukládá výsledky do dané tabulky.

\subsubsection{Třída DFSParallelPatternMatcher}

Třída představuje paralelní prohledávání grafu, které ukládá výsledky v moment nalezení do tabulky.
Paralelizaci jsme popsali v sekci \ref{anal.matchPar}.
V konstruktoru dostává počet vláken \texttt{ThreadCount}, vzor \texttt{DFSPattern}, graf \texttt{Graph} a instanci úložiště výsledků \texttt{MatchFixedResults}.
K paralelizaci prohledávání grafu využívá instance třídy \texttt{DFSPatternMatcher} a počet instancí odpovídá hodnotě \texttt{ThreadCount}.
Tedy v konstruktoru vytvoří tyto instance a každé přidělí kopii vzoru, graf a její lokální úložiště.
Výsledně obsahuje položky:
\begin{itemize}
\item \texttt{MatchFixedResults results} obsahuje lokální tabulky výsledků vláken.
\item \texttt{DFSPatternMatcher[] matchers} obsahuje instance tříd algoritmů prohledávání grafu.
Každá instance má svou lokální kopii vzoru a odkaz na tabulku výsledků.
\end{itemize}
Paralelní prohledávání je spuštěno metodou \texttt{void Search()}.
Zde využíváme nativní \texttt{ThreadPool}.
Je vytvořeno \texttt{ThreadCount} instancí \texttt{Task} vykonávají práci \texttt{WorkMultiThreadSearch(object o)}, kde \texttt{o} je lokální \texttt{JobMultiThreadSearch}.
Ten obsahuje instanci prohledávání a objekt \texttt{VertexDistributor}.
Objekt jsme definovali v analýze (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{VertexDistributor}).
Drží odkaz na pole vrcholů grafu a index posledního přiděleného vrcholu.
Množství přidělených vrcholů je definováno v položce \texttt{int verticesPerRound}.
Vlákna jej žádají o rozsah vrcholů metodou \texttt{void DistributeVertices(out int start, out int end)} a následně spustí prohledávání z daných vrcholů.

Po dokončení prohledávání dojde k paralelnímu slévání tabulek.
Rozhodli jsme se použít metodu slévání po sloupečcích tabulek, protože slévání celých tabulek po dvojicích bylo pomalejší.
Paralelizace probíhá podobným způsobem jako paralelizace prohledávání.
Je vytvořeno $n$ instancí \texttt{Task}, kde $n$ je počet sloupečků v tabulce, které vykonávají práci \texttt{ParallelMergeColumnWork(object o)}, kde \texttt{o} je lokální \texttt{ParallelMergeColumnJob}.
Ten obsahuje odkaz na \texttt{MatchInternalResults} a \texttt{ColumnDistributor}.
Vlákna žádají objekt \texttt{ColumnDistributor} o sloupeček ke slévání.
Interně objekt funguje totožně jako \texttt{VertexDistributor} s rozdílem, že si objekt pamatuje index prvního nepřiděleného sloupečku.
Slévání probíha voláním metody \texttt{MergeColumn} na instanci \texttt{results}.
V moment dokončení slévání jsou finální výsledky v položce \texttt{results.FinalMerged}.
Tato položka je předána konstruktoru \texttt{TableResults}, která implementuje rozhraní \texttt{ITableResults}.
Třída představuje tabulku výsledků, kterou si objekty částí dotazu (\texttt{QueryObjekt}) předávají ke zpracování.

\subsection{Tabulka výsledků}

Objekty exekučního plánu si předávají tabulku výsledků prohledávání rozhraním \texttt{ITableResults}.
Ačkoliv jsme navrhli rozhraní, tak obecně používáme pouze jednu třídu \texttt{TableResults}, která rozhraní implementuje.
Tabulku jsme implementovali dle sekce analýzy \ref{anal.tables}.
Zároveň jsme ji upravili rovnou k možnosti použití pro ukládání pouze reprezentantů skupin popsaném v sekci \ref{anal.uprava.Groupby.table}.
Hlavní vlastnosti jsou:
\begin{itemize}
\item \texttt{int ColumnCount} je počet sloupečků v tabulce.
Sloupeček zde odpovídá jedné proměnné dotazu, tj. na jeden řádek se díváme jako na hodnoty v poli \texttt{scope} z průběhu prohledávání.
Tedy počet sloupečků je roven počtu unikátních proměnných v dotazu.
Pokud chceme přistoupit k proměnné výsledku prohledávání, musíme znát jeji pozici v poli \texttt{scope}.

\item \texttt{int RowCount} je počet řádků v tabulce.
\item \texttt{int FixedArraySize} je velikost bloků v tabulce.
Tabulka opět využívá princip ukládání výsledků do bloků fixní délky.
Stejný princip jsme použili při ukládání výsledků v průběhu prohledávání grafu.
To nám umožní v moment dokočení slévání pouze přesunou výsledky do kostruktoru této třídy.
\item \texttt{List<Element[FixedArraySize]>[] resTable} je tabulka výsledků prohledávání.
\texttt{resTable[i]} je \textit{i}-tý sloupeček.
\texttt{resTable[i][j]} je \textit{j}-tý blok ve sloupečku.
\texttt{resTable[i][j][k]} je \textit{k}-tý výsledek v bloku.
\item \texttt{Element[] tmpRow} představuje odkaz na pole elementů, ke kterému lze přistoupit skrze rozhraní tabulky, aniž by bylo pole elementů v tabulce.
\item Metoda \texttt{void StoreRow(Element[])} překopíruje hodnoty do tabulky. Funguje ekvivalentně jako \texttt{AddRow} ve třídě \texttt{MatcherFixedResultsInternal}.
\item Metoda \texttt{void StoreTemporaryRow()} vyvolá metodu výše pro uložení pole \texttt{tmpRow} do tabulky.
\item Metoda indexeru \texttt{RowProxy this[int i]}, která vrátí proxy třídu řádku.
\item Položka \texttt{int[] order} umožní definovat vlastní pořadí řádků v tabulce bez nutnosti přesouvat řádky.

\end{itemize}
V průběhu analýzy jsme navrhli způsob práce s řádky. 
Místo abychom pracovali konkrétně s řádky, tak jsme implementovali proxy třídu řádku \texttt{struct RowProxy}.
Třída obsahuje pouze dvě položky. 
První je index řádku \texttt{int index}, který reprezentuje, a druhá je odkaz na tabulku \texttt{TableResults resTable}.
Získá se voláním indexeru na tabulce.
Na struktuře se pak voláním metody \texttt{Element this[int c]} přistoupí k proměnné na řádku tabulky (\texttt{c} je zde sloupeček tabulky).
Danou třídu pak budeme používat k vyhodnocení výrazů a výpočtům agregačních funkcí.
Kdykoliv budeme předávat strukturu do funkce, tak ji budeme předávat pomocí parametru \texttt{in}, který vyvolá předání odkazem.
Tím vyloučíme zbytečné kopírování položek struktury.
Na struktuře existuje statická metoda \texttt{AreIdenticalVars}, která porovná dvě proxy třídy řádků, zda obsahují stejné elementy grafu na základě jejich \texttt{ID}.

\subsection{Expressions}

Než přistoupíme k implementaci Order by a Group by musíme implementovat způsob vyhodnocení výrazů.
K výpočtu výrazů jsme implementovali vlastní jednochý systém.
Postupovali jsme přesně podle sekce analýzy \ref{anal.expressions}, proto popíšeme jen tvorbu a základní objekty.

\subsubsection{Tvorba výrazů}

V části parsování dotazu \ref{impl.parsing} jsme uvedli, že výstupem parsování jsou parsovací stromy každé části dotazu.
Tyto stromy obsahují i podstromy výrazů.
Každá část dotazu má svůj objekt implementující rozhraní \texttt{IVisitor<T>}, kterým se sbírají důležitá data.
Pokud v průběhu procházení dojde k nalezení podstromu výrazu, tak dojde k vytvoření speciálního objektu \texttt{ExpressionVisitor}.
Tento objekt procházením podstromu vytvoří stromovou strukturu výrazu, pomocí které se bude vyhodnocovat daný výraz v průběhu vykonávání dotazu.
Objekt implementuje \texttt{IVisitor<ExpressionBase>}, kde \texttt{ExpressionBase} reprezentuje výsledný výraz.
Všechny výrazy se globálně udržují v třídě \texttt{QueryExpressionInfo}, která jim přiděluje \texttt{ID} na základě jejich pořadí vytvoření.
Třída si také pamatuje výrazy agregačních funkcí a přiděluje jim rovněž \texttt{ID} na základě pořadí vzniku.

\subsubsection{Třídy výrazů}

Implementace tříd výrazů je totožná jako v analýze.
\texttt{ExpressionBase} je abstraktní třída, která definuje základní rozhraní struktur výrazů.
Definuje:
\begin{itemize}
\item Položku \texttt{int ExprPosition} je \texttt{ID} výrazu dle pořadí vytvoření.
\item Metodu \texttt{Type GetExpressionType()}, která vrací navratový typ výrazu.
\item Metodu \texttt{void CollectUsedVars(ref List<int> v)}, která vratí \texttt{ID} proměnných potřebných k vyhodnocení stromové struktury výrazu.
\end{itemize}
Z třídy vzniká abstraktní potomek \texttt{ExpressionReturnValue<T>}, který definuje návratovou hodnotu funkce v parametru \texttt{T}.
Třída definuje rozhraní výpočtu výrazu metodami \texttt{bool TryEvaluate( ... x, out T returnValue)}.
Kde \texttt{x} jsou položky nutné k vyhodnocení výrazu, což jsou zde řádky z tabulky výsledků.
Mezi hlavní patří \texttt{Element[]} a \texttt{RowProxy}.
Z třídy následně dědí nová abstraktní třída \texttt{VariableReference<T>}, která představuje přístup k proměnné.
\texttt{ID} přistupované proměnné je uloženo v položce \texttt{int VariableIndex}.
Z třídy finálně dědí dvě třídy.
Konkrétní třída \texttt{VariableIDReference}, která vrací \texttt{ID} elementu grafu představující proměnnou.
Druhá třída je \texttt{VariablePropertyReference<T>}, která představuje přístup k vlastnosti elementu grafu představující proměnnou a \texttt{T} je zde typ vlastnosti.
\texttt{ID} vlastnosti je uloženo v položce \texttt{int PropertyID}. 

\subsubsection{Výraz agregační funkce}

Při implementaci výrazu agregační funkce jsme postupovali jako v analýze.
Vytvořili jsme dva koncepty.
První koncept představuje logiku agregační funkcí.
Tu představuje asbtraktní třída \texttt{Aggregate}, jejíž potomci implementují specifickou logiku výpočtu funkcí. 
Druhý koncept představuje odkaz na vypočtenou hodnotu funkce, ke které se může přistupovat v jiných částech dotazu.
Tento koncept představuje třída \texttt{AggregateReference<T>: ExpressionReturnValue<T>}.
Třída reprezentuje hodnotu již vypočtené agregační funkce a typ hodnoty je parametr \texttt{T}.
\texttt{ID} funkce, kterou reprezentuje, je uloženo v položce \texttt{int AggrPosition}.

Obecně jsme vytvořili třídu \texttt{ExpressionHolder}, která udržuje odkaz na třídu \texttt{ExpressionBase}.
Tato třída je používaná k předávání výrazů do funkcí a konstruktorů.

\subsection{Order by}

Implementovali jsme části nutné ke zpracování Order by a Group by.
Nyní popíšeme implementaci jejich řešení.
Začneme částí Order by.

U implementace jsme vycházeli z sekce analýzy \ref{anal.orderby}.
Část Order by je reprezentována objektem \texttt{OrderByObject: QueryObject}.
Order by musí setřídit tabulku \texttt{TableResults} pomocí výrazů zadaných uživatelem (klíčů třídění).
Klíče jsou vytvořeny v konstruktoru objektu při procházení parsovacího stromu objektem \texttt{OrderByVisitor<List<ExpressionComparer> >}.
Výstup procházení obsahuje pole porovnávačů, které se musí použít k porovnaní řádků tabulky.

\subsubsection{Třída ExpressionComparer}

\texttt{ExpressionComparer} je abstraktní třída definující rozhraní porovnávače jednoho klíče třídění.
Jejím úkolem je vypočíst a porovnat hodnoty jednoho klíče třídění dvou řádků.
Definuje:
\begin{itemize}
\item Abstraktní metodu \texttt{int Compare(in RowProxy x, in RowProxy y)} porovnávající dva řádky tabulky.
\texttt{in} parametr zde představuje předání argumentu odkazem, aby nedokázelo ke zbytečnému kopírování struktur.
\item Položku \texttt{int[] usedVars}, která obsahuje \texttt{ID} proměnných nutných k výpočtu hodnot klíče.
\item Položku \texttt{bool isAscending}, která určuje, jestli se třídí sestupně nebo vzestupně.
\item Položku \texttt{ExpressionHolder expr}, která obsahuje výraz porovnávání.
\item Položku \texttt{bool CacheResults}, která určuje, zda se má se má použít optimalizace.
\texttt{true} označuje využití optimalizace.

\end{itemize}
Potomky třídy jsou třídy \texttt{ExpressionComparer<T>}, které představují porovnání konkrétních typů návratoých hodnot výrazů.
Potomci budou také implementovat zmíněné optimalizace z sekce analýzy \ref{anal.orderby}.

\subsubsection{Třída ExpressionComparer<T>}

Třída konkretizuje návratovou hodnotu výrazu porovnání v parametru \texttt{T}.
Obsahuje výraz \texttt{ExpressionReturnValue<T>}, který se vyhodnotí porovnávanými řádky.
Implementuje metodu \texttt{Compare( ... x, ... y)} rodiče.
Nyní popíšeme způsob porovnání společně s optimalizacemi:

\begin{enumerate}
\item Dojde k porovnání proxy tříd pomocí statické metody \\*\texttt{RowProxy.AreIdenticalVars(in x, in y, this.usedVars)}, \\*která
porovnává elementy na řádcích tabulky dle jejich \texttt{ID}.
Avšak, porovnáváme zde jen elementy proměnných, které se používají k výpočtu výrazu (položka \texttt{usedVars}).
Pokud jsou totožné, nemusíme vypočítávat hodnotu výrazu.
Tím vyřešíme optimalizaci porovnání stejných elementů z sekce \ref{anal.orderby.opt2}.

\item Následuje vypočtení hodnot výrazů řádků a jejich porovnání.
Pokud byla \texttt{CacheResults == false}, tak nic dalšího se neprovádí.
Opačně, při výpočtu hodnot si uložíme pozici řádku \texttt{x.index} do \texttt{int lastXRow}, zda se výraz vyhodnotil správně do \texttt{bool lastXSuccess} a hodnotu výrazu do \texttt{T lastXValue}.
To samé pro řádek \texttt{y}: \texttt{int lastYRow}, \texttt{bool lastYSuccess} a \texttt{T lastYValue}.
Pokud při příštím porovnání budou \texttt{x} nebo \texttt{y} totožné řádky, tak již máme vypočtené hodnoty výrazů. 
Tím vyřešíme optimalizaci porovnání stejných vlastností z sekce \ref{anal.orderby.opt1}.
\end{enumerate}

Optimalizace v druhém kroku je nefunkční v paralelním prostředí.
Protože by se vlákna snažila ukládat výsledky na sdílené pozice a došlo by k souběhu.
Snažili jsme se problém vyřešit třídou \texttt{ThreadLocal} (lokální úložiště vlákna).
Každá ukládaná položka by byla obsažena v dané tříde a vlákna by tak měla svá úložiště.
Dalším zkoušeným řešením bylo uzavřít celou třídu porovnávače do \texttt{ThreadLocal}.
Avšak, tyto způsoby způsobili zpomalení vykonávání a proto jsme se rozhodli optimalizaci využívat pouze v jednovláknovém prostředí.

\subsubsection{Třída RowComparer a IndexToRowProxyComparer}

Všechny třídy porovnávače využívané k porovnání dvou proxy tříd jsme uzavřeli do třídy \texttt{RowComparer}, která postupně zkouší vykonat porovnání porovnávači, než dojde ke stanovéní rovnosti řádků.
Protože jsme v analýze stanovili, že se budou porovnávat pouze indexy řádků, tak jsme vytvořili třídu, která obalí \texttt{RowComparer} a umožní porovnávat řádky pomocí indexů. 
Třída se jmenuje \texttt{IndexToRowProxyComparer}.
Drží odkaz na tabulku \texttt{ResultTable} a zmíněnou \texttt{RowComparer}.
Volání metody \texttt{int Compare(int x, int y)} na třídě dojde k získání proxy tříd řádků \texttt{x} a \texttt{y}.
Následně dojde k jejich porovnání pomocí \texttt{RowComparer}.
Implementaci třídy jsme dále rozšířili dle návrhu porovnávání řádků tabulky při vkládání řádků do vyhledávacího stromu z sekce analýzy \ref{anal.improvement.orderby.storeindex}.
Existuje zde nově položka \texttt{bool allowDuplicities}.
Pokud položka je nastavená na \texttt{false}, tak při určení shodnosti hodnot klíčů dvou řádků se výsledně použije k porovnání jejich index v tabulce (což jsou zde hodnoty \texttt{x} a \texttt{y}).
Čili, položka nastavená na \texttt{true} porovnává pouze podle klíčů třídění.
\texttt{true} je nastaveno tedy vždy, pokud je třída používá s vyhledávacími stromy. 

\subsubsection{Řešení Normal: Merge sort}

Připravili jsme všechny nutné podklady pro vykonání třídění.
Samotné vykonání třídění je implementováno v třídě \texttt{MultiColumnTableSorter} v metodě \texttt{Sort}.
Třída drží odkaz na \texttt{IndexToRowProxyComparer}, který bude sloužit jako porovnávač při třídění.
Metoda vytvoří pole indexů \texttt{int[]} velikosti odpovídající počtu řádků v tabulce.
K třídění indexů v poli používáme knihovnu HPCsharp \citep{hpcsharp}.
Konkrétně využíváme algoritmus Merge sort pro jednovláknové zpracování a pro paralelní používáme paralelní verzi Merge sort.
Výsledně se pole indexu předá tabulce na položku \texttt{ResultTable.order}.
Pole nyní slouží jako indexační struktura tabulky.
Toto řešení budeme označovat v průběhu testování paralelního i jednovláknového zpracování jako \textbf{Normal: Merge sort}.
První slovo určuje mód, kterému řešení přináleží.

\subsection{Group by}

U implementace Group by jsme vycházeli z sekce analýzy \ref{anal.groupby}.
Část Group by je reprezentována objektem \texttt{GroupByObject: QueryObject}.
Group by musí seskupit výsledky v tabulce prohledávání \texttt{TableResults} pomocí výrazů zadaných uživatelem (klíčů seskupení).
Zároveň musí provést výpočet agregačních funkcí.
Klíče seskupování jsou vytvořeny v kostruktoru objektu při procházení parsovacího stromu objektem \texttt{GroupByVisitor<List<ExpressionHolder> >}.
Výsledné pole obsahuje výrazy, které se musí použít k seskupování.
V průběhu sestavování dalších částí dotazu dochází k vytváření objektů logiky výpočtu agregačních funkcí.
Logika je obsažena v potomcích objektu \texttt{Aggregate}.
Výsledný objekt části Match tedy obsahuje pole výrazů a pole objektů logiky agregačních funkcí.
Nejdříve popíšeme implementaci seskupování a následně implementaci agregačních funkcí.

\subsubsection{Dictionary a ConcurrentDictionary}

Abychom pochopili implementaci seskupování musíme se podívat na způsob práce s hašováním výrazů.
V analýze jsme určili, že výsledky prohledávání budeme seskupovat pomocí hašovací tabulky, ať už v jednovláknovém nebo paralelním zpracování.
Jazyk C\# obsahuje hašovací tabulku \texttt{Dictionary<Key, Value>} pro jednovláknové zpracování a \texttt{ConcurrentDictionary<Key, Value>} pro paralelní zpracování.
\texttt{ConcurrentDictionary} je thread-safe verze \texttt{Dictionary}. 
\texttt{Key} zde chápeme jako řádek tabulky a \texttt{Value} úložiště hodnot agregačních funkcí. 
\texttt{Key} zde nebude proxy třída, ale pouze index řádku.
Porovnání vyvolá získání proxy třídy jako v předchozí sekci u třídění.
Obvyklé vkládání prvků do \texttt{Dictionary} vypadá následovně:
\begin{code}
Dictionary<int, int> dict = new Dictionary<int, int>();
int x = 5;
if (!dict.TryGetValue(x, out int y)) dict.Add(x, 42);
\end{code}
Nejdříve se v podmínce otestuje, jestli vkládaný prvek ve struktuře existuje.
To znamená, že se vypočte haš prvku a nalezne se místo vložení.
Jestli na místě nějaký prvek již leží, tak dojde k porovnání hodnot a jinak funkce vrací \texttt{false}.
Funkce vrátí \texttt{true} při úspěchu porovnání prvků a při neúspěchu vratí \texttt{false}.
Při vrácení \texttt{false} dojde k vložení funkcí \texttt{Add}, která opět vypočte haš a případně porovná prvky.
Obvyklé vkládání prvku pro \texttt{ConcurrentDictionary} vypadá následovně:
\begin{code}
ConcurrentDictionary<int, int> dict = 
    new ConcurrentDictionary<int, int>();
int x = 5;
var retVal = dict.GetOrAdd(x, 42);
\end{code}
Nyní neuvažujme žádné synchronizační koncepty.
Funkce \texttt{GetOrAdd} vypočte haš, získá místo vložení a pokud na místě jiný prvek není rovnou ho vloží.
Zde tedy dochází k hašování a porovnání pouze jednou.
V prvním případě \texttt{Dictionary} bychom byli nuceni vyhodnotit ten samý výraz 4-krát.
Obecně obě struktury pro dva rozdílné prvky se stejnou haš hodnotou mohou vytvářet spojový seznam daných prvků.
Výsledně bychom museli vypočítávat výrazy při každém porovnání v seznamu.
Navíc, pokud by docházelo ke slévání výsledků dvou hašovacích tabulek do jedné, tak bychom opět museli počítat haš a porovnávat.
Interně obě struktury používají k výpočtu haš hodnoty a porovnání objekt s rozhraním \texttt{IEqualityComparer<T>}.
Kde \texttt{T} je \texttt{Key}. 
Objekt má metodu \texttt{int GetHashCode(T o)} a \texttt{bool Equals(T x, T y)}.
První vypočte haš vkládaného objektu a při porovnání se vyvolá metoda \texttt{Equals}.
Strukturám se dá v konstruktoru poskytnou vlastní implementaci rozhraní.
Díky této implementaci jsme vymysleli dvě optimalizace:
\begin{enumerate}
\item V moment kdy dochází k použití \texttt{Dictionary} nebo aktu slévání hašovacích tabulek budeme jako \texttt{Key} používat strukturu \texttt{GroupDictKey}.
Struktura obsahuje dvě položky \texttt{int hash} a \texttt{int position}. 
\texttt{hash} je zde haš řádku a \texttt{position} je index řádku v tabulce výsledků.
Tedy jsme rozšířili \texttt{Key} o haš hodnotu řádku, kterou můžeme znovu použít, pokud to bude nutné.
Budeme implementovat vlastní \texttt{IEqualityComparer<T>}, který jen použije haš hodnotu ze struktury.
Tímto vypočteme haš pouze jednou za celý cyklus vkládání nebo slévání.
Pokud používáme \texttt{ConcurrentDictionary} a nedochází ke slévání, tak stačí jako \texttt{Key} volit index řádku.
\item Při výpočtu haš hodnoty se vypočítávají hodnoty výrazů.
Abychom nepočítali stejné výrazy opětovně při porovnání, tak budeme používat dvě třídy.
V prvním případě vytvoříme \texttt{ExpressionHasher}, který počítá haš hodnotu jednoho výrazu.
Třídu propojíme s již existující \texttt{ExpressionComparer<T>}.
Třída \texttt{ExpressionHasher} při výpočtu výrazu pak jen aktualizuje vnitřní hodnoty položek (\texttt{lastYRow}, \texttt{lastYValue} a \texttt{lastYSuccess}) uvnitř porovnávače a ten je následně využije.
Nastavujeme položky argumentu \texttt{y} (dle metody \texttt{Compare(x, y)}), protože vkládaný prvek při porovnání je vždy uchováván v \texttt{y}.
Toto odpovída navržené optimalizaci z sekce analýzy \ref{anal.groupby.opt1}.
\end{enumerate}
Problémem u druhé optimalizace je opět sdílení položek v paralelním prostředí.
Jelikož jsme se v předchozí sekci Order by rozhodli nevyužívat při paralelním zpracování optimalizaci ukládání výsledků výrazů.
Tak ani zde ji nebudeme implementovat pro paralelní zpracování. 

\subsubsection{Třída ExpressionHasher a třídy ExpressionHasher<T>}

\texttt{ExpressionHasher} je abstraktní třída reprezentující jeden klíč seskupení.
Definuje:
\begin{itemize}
\item Položku \texttt{ExpressionHolder expr}, která obsahuje výraz seskupení.
\item Abstraktní metodu \texttt{int Hash(in RowProxy row)}, která vypočte haš výrazu pro řádek tabulky. 
V průběhu výpočtu dojde k nastavení položek porovnávače.
\item Abstraktní metodu \texttt{SetCache(ExpressionComparer cache)}, ve které si potomci nastaví odkaz na \texttt{ExpressionComparer<T>}.
To umožní následně při výpočtu hodnoty výrazu přiřadit výsledky dané třídě.
\end{itemize}
Potomky třídy jsou třídy \texttt{ExpressionHasher<T>}.
Implementují výpočet výrazu pro konkrétní návratový typ \texttt{T} a výpočet haše výrazu.
Třída obsahuje položku \texttt{ExpressionComparer<T> exprComp}, která je odkaz na porovnávač. 
Skrze odkaz se třídě přepíšou položky při výpočtu výrazu.
Dále obsahuje výraz seskupení \texttt{ExpressionReturnValue<T> exprR}.
Všechny klíče seskupení jsou obsaženy v třídě \texttt{RowHasher}, která vypočte finální haš kombinací všech haš hodnot výrazů. 

\subsubsection{Rozhraní IEqualityComparer<T>}

V aplikaci jsme vytvořili dva objekty:
\begin{itemize}
\item \texttt{RowEqualityComparerInt: IEqualityComparer<int>} definuje porovnání a výpočet haš hodnot pomocí indexu řádku tabulky.
Třída drží odkaz na tabulku \texttt{TableResults} pro získání proxy třídy řádku indexem.
Dále má porovnávače \texttt{ExpressionComparer[]} pro zjištění rovnosti dvou prvků v hašovací tabulce a finálně \texttt{RowHasher} pro výpočet haše.
Položka \texttt{bool cacheResults} určuje zda se má použít druhá optimalizace.
\item \texttt{RowEqualityComparerGroupDictKey:} \\*\texttt{IEqualityComparer<GroupDictKey>}, který je totožný s předchozím, ale neobsahuje \texttt{RowHasher}, protože haš je uložev v objektu porovnání.
\end{itemize}

\subsubsection{Logika agregačních funkcí}

Implementovali jsme způsob seskupování.
Nyní budeme implementovat objekty logiky agregačních funkcí.
V sekci implementace výrazů jsme řekli, že logika je reprezentována abstraktní třídou \texttt{Aggregate}.
Tyto třídy jsou tvořeny v průběhu procházení parsovacích podstromů výrazů a jsou uloženy v poli \texttt{List<Aggregate>} uvnitř třídy \texttt{QueryExpressionInfo}.
Indexy funkcí v daném poli slouží jako \texttt{ID} daných funkcí.
Každá funkce potřebuje úložiště hodnot.
Úložiště pak musí být používány pro spravnou funkci na základě jejich \texttt{ID}.

Každá uživatelem zadaná funkce je tedy reprezentována třídou \texttt{Aggregate}.
Třída obsahuje položku \texttt{ExpressionHolder expr}, která představuje výraz, jehož hodnota se použije k výpočtu funkce.
Dále třída definuje metody, které slouží k aplikování logiky pro specifické úložiště.
Popíšeme je obecně:
\begin{itemize}
\item Metoda \texttt{void Apply(x, druh\_úložiště y)} vypočte hodnotu výrazu \texttt{expr} pomocí \texttt{x} (\texttt{RowProxy} nebo \texttt{Element[]}), hodnotu zpracuje definovanou logikou a výsledek uloží do úložiště \texttt{y}.
Pro každé úložiště pak existuje daná metoda.
Zároveň pro úložiště existují thread-safe verze metod opatřených příponou \texttt{ThreadSafe}.

\item Metoda \texttt{void Merge(druh\_úložiště\_X x, druh\_úložiště\_Y y)}\\* sloučí výsledky dvou úložišť \texttt{x} a \texttt{y}. 
Výsledek sloučení je uložen v úložišti \texttt{x}.
Pro každé úložiště pak existuje daná metoda a opět i thread-safe verze opatřených příponou \texttt{ThreadSafe}.
\end{itemize}
Konkrétní implementace logiky je přesunuta na potomky.
Z dané třídy dědí abstraktní třída \texttt{Aggregate<T>}, která konkretizuje návratovou hodnotu výrazu parametrem \texttt{T}.
Obsahuje položku \texttt{ExpressionReturnValue<T>} pro výpočet hodnoty výrazu.
Z třídy následně vznikají už konkrétní implementace logiky.
Funkce \texttt{sum} a \texttt{avg} mohou na vstupu obsahovat pouze číselnou hodnotu.
To v našem případě je pouze \texttt{int}, protože jsme omezili typy vlastností ve vstupních souborech.
Funkce \texttt{count}, \texttt{min} a \texttt{max} mohou navíc mít i řetězec:
\begin{itemize}
\item Třída \texttt{IntSum: Aggregate<int>} reprezentuje funkci \texttt{sum}.
Obecně metoda \texttt{Apply} vypočte hodnotu výrazu a přičte ji k hodnotě v úložišti.
Úložiště musí obsahovat sumu již vypočtených výrazů.
Thread-safe verze používá k přičtení atomickou operaci přičtení \texttt{Interlocked.Add(...)}.
\texttt{Merge} pak pouze přičte hodnotu v \texttt{y} do \texttt{x} stejným způsobem.
\item Třída \texttt{IntAvg: Aggregate<int>} reprezentuje funkci \texttt{avg}.
Úložiště musí obsahovat sumu již vypočtených výrazů společně s jejich počtem.
Zpracování pak pouze přičte hodnotu výrazu k sumě a navýší jejich počet.
Přičítání je implementováno shodně jako v \texttt{IntSum}.
\item Třída \texttt{Count<T>: Aggregate<T>} představuje funkci \texttt{count}.
Přebírá v definici parametr \texttt{T}, protože v případě nepoužití \texttt{count(*)} musí být schopna pracovat se všemi druhy návratových hodnot výrazů.
Úložiště musí obsahovat počet správně vyhodnocených výrazů a v případě \texttt{count(*)} to je pouze počet prvků skupiny.
Implementace metod je stejná jako u \texttt{IntSum}.
\item Třída \texttt{MinMaxBase<T>: Aggregate<T>} představuje logiku funkcí \texttt{min} a \texttt{max}.
Očekává se, že úložiště bude mít \texttt{bool}, který říká zda již byla hodnota inicializována.
Dále má aktuální minimum nebo maximum hodnot výrazu. 
V threa-safe verzích metod je využito \texttt{Interlocked.CompareExchange(..)} jako princip Compare and Exchange. 
\end{itemize}

\subsubsection{Úložiště hodnot agregačních funkcí}

Objekty \texttt{Aggregate} pracují s úložišti.
V analýze jsme definovali dva druhy úložišť.
První bylo úložiště Bucket a druhé List.
V aplikaci jsme implementovali řešení reprezentující úložiště Bucket a řešení úložiště List přesně podle analýzy.
Samotná logika tříd je společná všem řešením, proto popíšeme pouze podrobněji řešení Bucket.
Zbylá řešení implementují stejnou logiku s tím, že místo jedné hodnoty obsahují pole hodnot.
Samotná úložiště jsou použita jako \texttt{value}, při vkládání do \texttt{Dictionary<key, value>} nebo \texttt{ConcurrentDictionary<key, value>}.
To zmamená, že každá skupina má své úložiště.

\subsubsection{Třída AggregateBucketResult}

Představuje abstraktní třídu používající způsob ukládání Bucket.
Potomci definují typ ukládané hodnoty.
Každý potomek je využívaný určitou agregační funkcí.
Třída definuje:
\begin{itemize}
\item Metodu \\*\texttt{AggregateBucketResult Factory(Type type, string funcName)}, \\*která implementuje návrhový vzor Factory metoda \citep[str. 107]{patterns}.
\texttt{type} zde určuje typ ukládané hodnoty v úložišti a \texttt{funcName} představuje druh agregační funkce, která s úložištěm bude pracovat.
\item Metodu \\*\texttt{AggregateBucketResult[] CreateBucketResults(Aggregate[] ags)}, \\*která vytváří výsledné úložiště hodnot na základě počítaných agregačních funkcí.
Pro Bucket jsme úložiště definovali jako pole tříd, ve kterém každá třída obsahuje hodnotu počítané funkce.
Výsledek funkce označme \texttt{x}. 
Přístup \texttt{x[i]} odpovídá úložišti funkce \texttt{ags[i]}.
\end{itemize}
Z třídy dále dědí \texttt{AggregateBucketResult<T>}, která definuje ukládanou hodnotu \texttt{T aggResult}.
Třída se používá při výpočtech funkcí \texttt{count} a \texttt{sum}.
Z této třídy dědí dvě třídy:
\begin{itemize}
\item První je \texttt{AggregateBucketResultWithSetFlag<T>}, která přidává položku \texttt{bool isSet}.
Položka určuje zda byla hodnota již inicializována.
Třída se použíje při výpočtu funkcí \texttt{min} a \texttt{max}.
\item Druhá je \texttt{AggregateBucketAvgResult<T>}, která se použije při výpočtu \texttt{avg} a definuje počet vypočtených výrazů \texttt{int eltsUsed}.
\end{itemize}

Pro řešení List je návrh totožný.
Názvy místo \texttt{Bucket} obsahují \texttt{List}.
A definované položky jsou pole místo jedné hodnoty (např. \texttt{List<T> aggResults} místo \texttt{T aggResult}).
Výsledně při používání úložiště Bucket vkládáme jako \texttt{value} do hašovací tabulky odkaz na pole vytvořené metodou \texttt{CreateBucketResult(..)}.
Při použití List nemůžeme použít odkazy na pole, protože hlavní myšlenka List je mít úložiště mimo hašovací tabulku, abychom nemuseli vytvářet spoustu tříd jako u Bucket.
V tomto případě budeme vkládat jako \texttt{value} pozici hodnot v úložišti pro danou skupinu.
Každá skupina tedy obdrží unikátní index (typ \texttt{int}).
Výsledky agregačních funkcí pro danou skupinu jsou tedy uloženy na daném indexu v úložišti.

\subsubsection{Group by zpracování}

Implementovali jsme všechny potřebné objekty k vykonání seskupení.
Nyní krátce popíšeme řešení zpracování, protože jsme zde postupovali dle analýzy.
Každému řešení roněž přiřadíme název, kterým řešení označíme v průběhu testování.
Název bude opět obsahovat název módu, za kterým následuje název řešení.
Zde navíc uvedeme za název řešení do závorky druh úložiště, tj. Bucket nebo List.
Začneme jednovláknovým zpracováním (sekce analýzy \ref{anal.groupby.singlethread}):
\begin{itemize}

\item Řešení \textbf{Normal: SingleThreadSolution (Bucket)} odpovídá jednovláknovému zpracování Group by pomocí úložiště Bucket.
Řešení je v třídě \texttt{GroupByWithBuckets}.
K seskupení je použit \texttt{Dictionary<key, value>}, proto je zde využit \texttt{GroupDictKey} jako \texttt{key}.
\texttt{value} je zde odkaz na pole úložiště \texttt{AggregateBucketResult[]}.
Pole úložiště hodnot agregačních funkcí se vytváří pouze v momentě, kdy je vytvářen nový záznam do hašovaví tabulky.
\texttt{RowEqualityComparerGroupDictKey} je zde rozhraní pro určení rovnosti skupin.
Využívají se obě optimalizace.

\item  Řešení \textbf{Normal: SingleThreadSolution (List)} odpovídá jednovláknovému zpracování Group by pomocí úložiště List.
Řešení je obsaženo v třídě \texttt{GroupByWithList}.
Řešení využívá \texttt{Dictionary<key, value>}, tudíž je zdě opět \texttt{GroupDictKey} jako \texttt{key}.
Úložiště výsledků agregačních funkcí je vytvořeno na začátku v položce \texttt{aggResults}.
\texttt{value} je \texttt{int}, protože úložiště hodnot agregačních funkcí leži mimo hašovací tabulku.
Při přidávání nové skupiny do hašovací tabulky je určena nová pozice pro skupinu v úložisti \texttt{aggResults} pomocí \texttt{Dictionary.Count}.
Tato hodnota se vkládá s klíčem do hašovací tabulky a skrze ni se přistoupí k výsledkům funkcí pro skupinu.
\end{itemize}
Všechna paralelní řešení využívají nativní třídu \texttt{ThreadPool}.
\texttt{Tasks} vykonávají statickou metodu \texttt{SingleThreadGroupByWork(object o)}, kde \texttt{o} je objekt obsahující lokální položky vláken.
Obecně pro všechna řešení daný objekt obsahuje odkaz na pole \texttt{Aggregate}, odkaz na tabulku výsledků prohledávání \texttt{TableResults} a dva indexy určující rozsah výsledků z tabulky ke zpracování.
Každé řešení je reprezetováno třídou, která implementuje vlastní logiku zpracování.

\begin{itemize}
\item Řešení \textbf{Normal: Global (Bucket)} odpovídá paralelnímu zpracování z sekce \ref{anal.groupby.global}.
Řešení je obsaženo v třídě \texttt{GlobalGroupByBucket}.
K seskupení vlákna využívají sdílenou hašovací tabulka \texttt{ConcurrentDictionary<key, value>}.
Není zde druhá optimalizace a \texttt{key} je zde pouze index řádku (\texttt{int}). 
\texttt{value} je zde odkaz na pole úložiště \texttt{AggregateBucketResult[]}.
Metoda \texttt{GetOrAdd(key, value)} je použita k vkládání.
Při úspěšném vložení nového záznamu vrátí odkaz na námi vkládané pole úložišť (\texttt{value}).
Při neúspěchu vrací odkaz na již dříve vložené pole.
Zda k tomu došlo ověříme pomocí rovnosti referencí na vkládané a vrácené pole. 
Samotná logika funkcí vykonává jejich thread-safe verze. 
Rozhraní pro určení rovnosti řádků je zde \texttt{RowEqualityComparerInt}.
Úložiště List jsme se snažili implementovat, ale nepodařilo se nám vytvořit efektivní řešení.
Hlavní problémem byla synchronizace při přístupu k úložišti hodnot agregačních funkcí.
Zde jsme zkoušeli využít nativní třídu \texttt{Semaphor} k omezení vstupu do kritické sekce.
Ta však při přístupu pracuje se zámky a ve výsledku řešení bylo značně pomalé.
Řešení proto nebudeme dále uvádět.

\item Řešení \textbf{Normal: Two-tep (Bucket)} odpovídá paralelnímu zpracování z sekce \ref{anal.groupby.twostep} s úložištěm Bucket.
Řešení je v třídě \texttt{TwoStepGroupByBucket}.
První část je implementována stejně jako jednovláknové řešení s Bucket.
Každé vlákno drží odkaz na svou lokální tabulku \texttt{Dictionary}.
Druhá část funguje jako Global řešení výše s rozdílem, že klíčem je zde \texttt{GroupDictKey}.
Zde vlákná sdílejí \texttt{ConcurrentDictionary}.

\item Řešení \textbf{Normal: Two-step (List) }odpovídá paralelnímu zpracování z sekce \ref{anal.groupby.twostep} s úložištěm List.
Řešení je v třídě \texttt{TwoStepGroupByList}.
První část je implementována stejně ja jednovláknové řešení s List.
Druhá část byla problematická, jelikož se jedná o stejný problém s úložištěm List jako u Global řešení.
Proto jsme se rozhodli v druhé části výsledky z List přeložit do Bucket.
To znamená, že pro zaznamy v List vytvoříme nová pole \texttt{AggregateBucketResult[]}, které vložíme do \texttt{ConcurrentDictionary}.
Výsledně je druhá část implementována stejně jako Global řešení výše s rozdílem, že klíčem je zde \texttt{GroupDictKey}.

\item \textbf{Normal: LocalGroupByLocalTwoWayMerge (Bucket)}\textbf{/(List)} odpovídájí paralelním zpracováním z sekce \ref{anal.groupby.local} s úložištěm Bucket/List.
Řešení jsou v třídách \texttt{LocalGroupByLocalTwoWayMerge} s příponou \texttt{Bucket} nebo \texttt{List}.
V prvním kroku jsou implementovány stejně jako jednovláknová řešení.
Vlákna zde drží odkaz na svou lokální tabulku \texttt{Dictionary}.
Při slévání dvou tabulek dochází k překopírování záznamů z jedné hašovací tabulky do druhé.
První je poté zahozena.
Výsledně existuje pouze jedna tabulka. 
Zde má značnou výhodu Bucket řešení, protože při slévání dochází k přesunutí odkazu na pole.
Zatímco u List dochází překopírovávání prvků mezi poli. 

\item \textbf{Normal: SingleGroupGroupBy} odpovídájí módu Single Group Group by zpracování z sekce \ref{anal.groupby.singlegroup}.
Řešení je v třídě \texttt{SingleGroupGroupBy}.
Třída je využívaná pro jednovláknové i paralelní zpracování.
Každé vlákno drží odkaz na lokální pole \texttt{AggregateBucketResult[]}, do kterého ukláda hodnoty funkcí.
Není zde úložiště List, protože pro každé vlákno existuje jen jedna skupina.

\end{itemize}
\textit{Implementovali jsme řešení, která zpracovávají výsledky po dokončení prohledávání grafu.
Nyní budeme implementovat řešení, která vykonávají Order by a Group by v průběhu prohledávání grafu.}

\subsection{Úprava propojení}

K realizaci zpracování v průběhu prohledávání grafu jsme postupovali podle sekce analýzy \ref{anal.improvement}.
Celý dotaz je reprezentován již existující třídou \texttt{Query}.
Samotný způsob vykonání se definuje v metodě \texttt{Create(...)}, kde jeden vstupní argument je mód.
Při vybrání upravaného módu se spustí rozdílný privatní konstruktor.
V konstruktoru dojde k vytvoření exekučního plánu.
V analýze jsme určili, že objekt části Select s novým objektem Match části \texttt{MatchObjectStreamed} je propojen původním způsobem.
Nyní pouze vytvoříme objekty \texttt{ResultProcessor} implementující nový způsob zpracování a nový objekt části Match \texttt{MatchObjectStreamed}. 

\subsubsection{Třída ResultProcessor}

Části dotazu Order/Group by budou nyní reprezentovány potomky třídy \texttt{ResultProcessor}.
Metody jsou použity ke zpracování výsledků v průběhu prohledávání grafu.
Třída definuje metody dle obrázku z analýzy \ref{figure.diaStreamedResultProcessor}.
Definuje:
\begin{itemize}
\item Abstraktní metodu \texttt{void Process(int matcherID, Element[] result)}, která implementuje logiku zpracování jednoho výsledku prohledávání.
První parametr \texttt{matcherID} je zde \texttt{ID} instance algoritmu prohledávání grafu, které se použije při přístupu k lokálním výsledkům v paralelních řešeních.
Očekává se, že instance algoritmu prohledávání grafu v moment dokončení prohledávání signalizují situaci pomocí této metody s \texttt{result == null}.
Po této signalizaci může dojít k finálním úpravám výsledků.
\item Absatraktní metodu \\*\texttt{RetrieveResults(out ITableResults t, out GroupByResults g)},\\* která získá finální zpracované výsledky v podobě tabulek. 
\end{itemize}
Z dané třídy dědí dvě abstraktní třídy.
První je třída \texttt{OrderByResultProcessor} představující část dotazu Order by.
Díváme se na ni jako na ekvivalent třídy \texttt{OrderByObject}. 
Druhá je třída \texttt{GroupByResultProcessor} představující část dotazu Group by.
Díváme se na ni jako na ekvivalent třídy \texttt{GroupByObject}.
Samotná konstrukce daných tříd je rovněž totožná s původními.
To znamená, že při konstrukci opět dochází k procházení parsovacích stromů a tvorbě totožných výsledných struktur.
Rozdíl je ten, že potomci tříd specifikují algoritmy zpracování v metodě \texttt{ProcessResult}.   

\subsubsection{Třída MatchObjectStreamed}

Třída dědí z třídy \texttt{MatchBaseObject}.
Třídě jsme přídali položku držící odkaz na třídu zpracovávající výsledky v \texttt{ResultsProcessor resultProcessor}.
Dále jsme třídě přidali metodu \texttt{PassResultProcessor}, která uloží odkaz na objekt zpracování do dané položky.
To odpovídá návrhu z obrázku \ref{figure.diaStreamedQueryObjects}.
Abychom mohli vykonávat zpracování v průběhu, tak nyní musíme upravit i samotné objekty prohledávání grafu.
Řekli jsme, že původní třída části Match obsahuje odkaz na objekt prohledávání grafu a tabulku výsledků.
Nyní vlastní pouze odkaz na objekt zpracování \texttt{ResultsProcessor} a odkaz na nový objekt algoritmu prohledávání grafu \texttt{DFSParallelPatternMatcherStreamed}.
Objekt algoritmu musíme také upravit a předat mu odkaz na objekt zpracování.

\subsubsection{Třída DFSParallelPatternMatcherStreamed}

Tato třída představuje upravené chování třídy \texttt{DFSParallelPatternMatcher}.
V konstruktoru se nepředává tabulka výsledků  \texttt{MatchFixedResults} a nedochází zde ke slévání výsledků.
Při inicializaci objektů jednovláknového prohledávání grafu se vytvářejí nově instance třídy \texttt{DFSParallelPatternMatcherStreamed}. 
Tyto instance obdrží nově \texttt{ID} na základě jejich pořadí vzniku.
Samotná paralelizace zpracování prohledávání funguje totožně jako v původní třídě.
Třídu jsme dále rozšířili o metodu \texttt{PassResultProcessor}, která předá odkaz na objekt zpracování instancím jednovláknového prohledávání.

\subsubsection{Třída DFSPatternMatcherStreamed}

Třída reprezentuje jednovláknový DFS algoritmus prohledávání.
Třída je potomkem třídy \texttt{DFSPatternMatcherBase}.
V konstruktoru očekává nově \texttt{ID} objektu \texttt{int matcherID}.
To znamená, že implementuje stejný algoritmus prohledávání, ale přepisuje metodu zpracování výsledků \texttt{ProcessResult()}.
Nově třída drží odkaz na objekt zpracování Order by a Group by v položce \texttt{ResultProcessor resultProcessor}.
Třídě jsme opět přidali metodu \texttt{PassResultProcessor}, která uloží odkaz objektu zpracování do zmíněné položky.
Finálně upravená metoda \texttt{ProcessResult()} vyvolá předání nalezeného výsledku (pole \texttt{Element[] scope} vzoru) spolu se svým \texttt{ID} pomocí metody \\*\texttt{ResultProcessor.ProcessResult(Element[] result, int matcherID)}.

Toto propojení vyplává z sekce \ref{anal.improvement.con2}.
Tímto jsme dokončili úpravu objektu části Match pro pozměněné zpracování.
Nyní přistoupíme ke konkrétním implementacím zpracování a potomkům třídy \texttt{resultProcessor}.

\subsection{Upravé Order by}

Část dotazu order je reprezentována třídou \texttt{OrderByResultProcessor}.
Potomci specifikují navržené přístupy zpracování dle sekce analýzy \ref{anal.improvement.orderby}.
Nejdříve popíšeme implementaci použitých vyhledávacích stromů a následně konkrétní třídy zpracování.

Implementovali jsme vlastní (a, 2a)-strom, protože jsme nedokázali nalézt již existující knihovnu.
Obecně při zpracovávání budeme využívat dva druhy stromů.
První je obecný (a, 2a)-strom a druhý je optimalizovaný strom z sekce \ref{anal.improvement.orderby.storeindex}, který seskupuje totožné prvky do pole místo aby je vložil do vrcholu.
Oba stromy implementují rozhraní \texttt{IABTree<T>}, který definuje metodu vložení prvku \texttt{void Insert(T key)} a položku počtu prvků ve stromě \texttt{itn Count}.
Toto rozhraní použijeme pro vytvoření obecného algoritmu zpracování, kterému budeme jednoduše moct změnit druh stromu.
Při zpracování očekáváme, že vkládané prvky jsou indexy řádků tabulky.
Potřebujeme setřídit i prvky se shodnými klíči, proto u všech řešení je použit \texttt{IndexToRowProxyComparer} s \texttt{allowDuplicities == false}.
To způsobí porovnání při shodnosti klíčů pomocí indexů řádků a navíc \texttt{cacheResults == true}, protože se stromem vždy bude pracovat jedno vlákno.

\subsubsection{Třída ABTree<T>}

Třída představuje (a, 2a)-strom.
Strom jsme implementovali dle přednášky Datových struktur I \citep[03. (a, b)-trees str. 6]{dataLecture}.
\texttt{T} je zde typ vkládaných prvků.
V konstruktoru obdrží parametr 2a.
Struktura definuje:
\begin{itemize}
\item Metodu \texttt{void Insert(T key)}, která vloží prvek \texttt{key} do stromu.
Prvky, které již jsou ve stromě nejsou vloženy.
\item Položku \texttt{int Count}, která určuje počet prvků ve stromě.
\end{itemize}
Strom implementuje pouze metodu vkládání \texttt{Insert}, protože pro naše zpracování funkce mazání \texttt{Delete} není potřebná.
Při vkládání je hledání správného podstromu realizováno binárním vyhledáváním.
Strom je interně složen z tříd \texttt{ABTreeNode<T>}, reprezentující vrcholy stromu.
Vrcholy obsahují odkaz na rodiče, abychom při iterování a procházení stromu nemuseli zaznamenávat cestu z kořene.
Vrchol obsahuje:
\begin{itemize}
\item \texttt{List<ABTreeNode<T> > children} je pole potomků. Každý potomek je zde chápán jako podstrom.
\item \texttt{List<T> keys} je pole vkládaných hodnot.
\item \texttt{ABTreeNode<T> parent} je odkaz na rodiče vrcholu.
\item \texttt{int index} je pozice vrcholu v jeho rodičovském vrcholu.
\end{itemize}
Třída implementuje rozhraní \texttt{IABTree<T>} a \texttt{IEnumerable<T>}.
Rozhraní procházení \texttt{IEnumerable<T>} iteruje prvky stromu od nejmenšího po největší.

\subsubsection{Třída ABTreeAccumulator<T>}

Třída představuje optimalizovaný (a, 2a)-strom z sekce analýzy \ref{anal.improvement.orderby.storeindex}.
Třída interně funguje totožně jako třída \texttt{ABTree<T>} a implementuje \texttt{IABTree<T>}.
Vrchol stromu \texttt{ABTreeNode<T>} nově vlastní položku \texttt{List<List<T> > accumulations}.
Každému prvku v poli \texttt{keys} na indexu \texttt{i} náleží právě jedno pole v \texttt{accumulations} na stejném indexu.
Metoda \texttt{Insert} chybějící prvek vloží do pole \texttt{keys} na index \texttt{i} a vytvoří prázdné pole v \texttt{accumulations} na indexu \texttt{i}.
Pokud se v budoucnu vkládaný prvek rovná již vloženému prvku v poli \texttt{keys} na indexu \texttt{i}, tak je vkládaný prvek vložen do pole na pozici \texttt{i} v poli \texttt{accumulations}.
Třída implementuje rozhraní \texttt{IEnumerable<ValueAccumulation<T> >}.
\texttt{ValueAccumulation<T>} je struktura, která obsahuje prvek z pole \texttt{keys} (\texttt{T value}) a jaho naležité pole v \texttt{accumulations} (\texttt{List<T> accumulation}).

\subsubsection{Řešení Half-Streamed}

Řešení je obsaženo v třídě \texttt{ABTreeSorterHalfStreamed} a odpovídá sekci analýzy \ref{anal.improvement.orderby.halfstreamed}.
Třída je abstraktním potomkem \texttt{OrderByResultProcessor}.
Potomci této třídy jsou řešení specializované na druh vyhledávacího stromu.
Definuje:
\begin{itemize}

\item Položku \texttt{SortJob[] sortJobs}, která obsahuje lokální výsledky vláken. \\*
Každému vláknu v průběhu prohledávání grafu náleží objekt algoritmu DFS \texttt{DFSPatternMatcherStreamed} s identifikátorem v položce \texttt{int matcherID}.
Tyto \texttt{ID} vznikly na základě pořadí vytvoření objektů.
Tedy vlákno vždy při volání metody \texttt{ProcessResult} přistupuje k objektu \texttt{sortJobs[matcherID]}. 
Objekt interně obsahuje \texttt{ITableResults resTable} (lokální tabulka výsledků prohledávání) a \texttt{IABTree<int> tree} (lokální indexační struktura).

\item Položku \texttt{int sortJobsFinished}, která určuje kolik vláken již dokončilo prohledávání grafu.
Vlákna při dokončení prohledávání grafu vyvolají atomické navýšení \texttt{Interlocked.Increment} na této položce.
Poslení vlákno zahájí paralelní slévání výsledků.

\item Metodu \texttt{SortJob CreateJob(..)}, kterou implemetují potomci a vytváří v ní specializovaný druh vyhledávacího stromu.

\item Implementuje \texttt{ProcessResult(Element[] result, int matcherID)}.\\*
V první části vlákno přistoupí k \texttt{sortJobs[matcherID]}. 
Následně překopíruje výsledek \texttt{result} do tabulky \texttt{resTable} a zatřídí index nového řádku tabulky (\texttt{tree.Insert(resTable.RowCount-1)}).
V této části fungují obě optimalizace porovnání.
Po dokončení prohledávání všech vláken dochází k paralelnímu dvoucestnému slévání.
Slévání je implementováno v objektu \texttt{MergeObject<T>} v metodě \texttt{T[] Merge()}.
\item Objekt \texttt{MergeObject<T>}, který implementuje paralelní dvoucestné slévání.
Interně používá metodu knihovny HPCsharp \citep{hpcsharp}.
Rozraní metody pracuje s dvěma pol. 
\texttt{T[] source} a \texttt{T[] destination}.
V prvním kroku slévání dochází k překopírování výsledků uvnitř stromů do pole \texttt{source}.
Na pole se tedy díváme jako na několik posloupností výsledků vláken.
Posloupnosti jsou slévány knihovní metodou do pole \texttt{destination}.
V této části nefunguje druhá optimalizace z důvodu paralelizace.
\end{itemize}
Toto je implementace obecné části.
Z třídy \texttt{ABTreeSorterHalfStreamed} dědí dvě třídy, které představují dva řešení.
Specifikují pouze implementaci \texttt{IABTree} a typ \texttt{T} třídy \texttt{MergeObject<T>}.
Budeme se držet definovaného značení:
\begin{itemize}
\item Řešení \textbf{Half-Streamed: ABTree}: využívá \texttt{ABTree} jako \texttt{IABTree}.
\texttt{T} třídy \texttt{MergeObject} je \texttt{RowProxy}, protože sléváme několik tabulek najednou a tedy použitím pouze \texttt{int} bychom nedokázali rozeznat, které tabulce index patří.
Řešení je obsaženo v třídě \texttt{ABTreeGenSorterHalfStreamed}.

\item Řešení \textbf{Half-Streamed: ABTreeAcccumulator}: využívá interně strom \texttt{ABTreeAccumulator} jako \texttt{IABTree}.
\texttt{T} třídy \texttt{MergeObject} je \texttt{RowProxyAccum}.
Jedná se o strukturu shodnou s \texttt{ValueAccumulation<int>}. 
Jediný rozdíl je ten, že místo indexu řádku tabulky (\texttt{int value}) obsahuje proxy třídu daného řádku (\texttt{RowProxy row}).
Takto sléváme pouze akumulované hodnoty a při porovnání dvou struktur porovnáváme pouze jejich položky \texttt{row}, protože indexy v poli struktury mají stejnou hodnotu klíčů porovnání.
Řešení je obsaženo v třídě \texttt{ABTreeAccumSorterHalfStreamed}.

\end{itemize}

\subsubsection{Řešení Streamed}

Řešení je obsaženo v třídě \texttt{ABTreeStreamedSorter<T>} a odpovídá řešení z sekce analýzy \ref{anal.improvement.orderby.streamed}.
\texttt{T} je zde typ prvního klíče třídění, podle kterého budeme rozdělovat rozsahy přihrádkám.
Potomci této třídy jsou řešení specializované na druh vyhledávacího stromu.
Definuje:
\begin{itemize}
\item Položku \texttt{RangeBucket[] rangeBuckets}, která odpovídá definovaným přihrádkám.
\texttt{RangeBucket} interně obsahuje \texttt{ITableResults resTable}\\* (lokální tabulka výsledků prohledávání) a \texttt{IABTree<int> tree} (lokální indexační struktura).

\item Položku \texttt{ExpressionReturnValue<T> firstKeyExpression} představující výraz prvního klíče třídění.
Výraz se vypočte a následně se jeho hodnota použije k zjištění správné přihrádky.
\item Položku \texttt{ExpressionComparer<T>[] firstKeyComparers}, která obsahuje odkaz na porovnávače prvních klíčů použitých ve stromech uvnitř přihrádek.
V moment výpočtu prvního klíče nastavíme výslednou hodnotu výrazu položkám porovnávače, aby nedocházelo k opětovnému výpočtu výrazu.
\item Metodu \texttt{RangeBucket CreateBucket()}, kterou implementují potomci a vytváří v ní specializovaný druh vyhledávacího stromu.
\item Položku \texttt{TypeRangeHasher<T> firstKeyHasher}, která na základě hodnoty prvního klíče třídění určí správnou přihrádku výsledku (volání metody \texttt{int Hash(T value)}).
\item Implementuje metodu \texttt{ProcessResult}.
V moment nalezení výsledku vlákno vypočte hodnotu \texttt{firstKeyExpression} a určí přihrádku voláním \texttt{Hash} metody výše.
Uzamkne přihrádku vloží výsledek do tabulky v přihrádce.
Nastaví položky porovnávače uvnitř stromu a následně vloží index řádku do stromu. 
\end{itemize}
Výpočet indexu přihrádky je zpracován potomky třídy \texttt{TypeRangeHasher}.
Třída pouze definuje Factory metodu \citep[str. 107]{patterns} \texttt{Factory(int threadCount, Type type)}.
\texttt{threadCount} říká kolik vláken bude přistupovat k přihrádkám a je omezen dle analýzy na 64.
\texttt{type} určuje jaký typ hodnoty třída zpracovává.
Z třídy dědí abstraktní třída \texttt{TypeRangeHasher<T>}, která definuje abstraktní metodu \texttt{int Hash(T value)}.
\texttt{T} je zde \texttt{type} z metody \texttt{Factory}.
Dále definuje položku \texttt{int BucketCount}, který určuje počet existujících přihrádek.
Potomek dané třídy je \texttt{IntRangeHasher}, která představuje rozdělení typu \texttt{Int32} dle analýzy.
Dále třídě je potomkem třída \texttt{AsciiStringRangeHasher}, která představuje rozdělení typu \texttt{string} dle analýzy.

Výsledně potomci \texttt{ABTreeSorterStreamed<T>} specializují použitý strom.
\begin{itemize}
\item Řešení \textbf{Streamed: ABTree}: využívá \texttt{ABTree} jako \texttt{IABTree}.
Řešení je obsaženo v třídě \texttt{ABTreeGenSorterStreamed<T>}.
\item Řešení \textbf{Streamed: ABTreeAcccumulator}: využívá interně strom\\* \texttt{ABTreeAccumulator} jako \texttt{IABTree}.
Řešení je obsaženo v třídě\\* \texttt{ABTreeAccumSorterStreamed<T>}.
\end{itemize}

\subsection{Úprava Group by}




%   \texttt{}
%  \begin{itemize}
%  \item \texttt{}
%  \item \texttt{}
%  \end{itemize}
