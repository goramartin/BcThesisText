\chapter{Implementace}
\label{impl}
   
Dokončili jsme analýzu, návrh a návrh úprav dotazovacího enginu.
V této kapitole popíšeme implementaci.
Začneme výběrem jazyka, obecným rozložením aplikace, popisu hlavních bloků a skončíme konkrétnějším pohledem na vybrané části aplikace.

\section{Výběr jazyka}

Aplikaci jsme se rozhodli implementovat v jazyce C\# pro .NET Framework 4.8.
K výběru jazyka jsme měli několik důvodů.
Framework nabízí množství knihoven, modulů a základních datových struktur.
Dále také poskytuje nástroje pro práci ve vícevláknovém prostředí.
Uvažovali jsme ještě o jazyku C++, který nabízí množství technik a možností optimalizace k získání rychlosti při vykonávání aplikace. 
Nyní zmíníme, že hlavním cílem práce není vyvinou co nejrychlejší dotazovací engine, ale otestovat obecný koncept vykonávání Group by a Order by v průběhu prohledávání grafu.
Myslíme, že tento koncept se dá implementovat v každém jazyce.
Navíc, v průběhu analýzy jsme si zkoušeli již implementovat určité koncepty v daném jazyce C\#, abychom měli lepší předhled o způsobech vykonání.
Z tohoto důvodu jsme měli určité části již naimplementovány.
Výsledně jsme se rozhodli z výše zmíněných důvodu použít C\# pro .NET Framework 4.8.

\section{Značení módů}

Než přistoupíme k popisu aplikace, tak si musíme vyjasnit základní značení módů.
Určili jsme, že engine bude pracovat v několika módech, které uživatel bude moct měnit.
Jsou to módy:

\begin{itemize}

\item \textbf{Normal:} reprezentuje původní způsob vykonávání.
V prvním kroku dojde k prohledání grafu a uložení výsledků do tabulky.
Teprve po dokončení dojde vykonání Group by a Order by.

\item \textbf{Half-Streamed:} Reprezentuje upravené vykonávání. 
Tento mód v paralelním vykonání ukládá výsledky nejdříve lokálně a po dokončení dojde ke slévání.

\item \textbf{Streamed:} Reprezentuje upravené vykonávání. 
Tento mód v paralelním vykonání zpracovává výsledky globálně.
\end{itemize}

Samotná individuální řešení se pro upravené módy \textbf{Half-Streamed} a \textbf{Streamed} liší pouze v paralelním vykonávání.
V určitých případech nastane, že i jednovláknová řešení jsou rozdílná.
V takovou chvíli na to upozorníme.
V průběhu této kapitoly se budeme držet tohoto značení.




\section{Rozložení aplikace}

Při implementaci aplikace jsme vycházeli z analýzy a návrhu z předchozí kapitoly.
Aplikaci jsme vyvíjeli jako projekt konzolové aplikace pro .NET Framework 4.8 v prostředí Visual Studia 2019.
Samotný projekt je rozdělený na tři hlavní řešení:

\begin{itemize}

\item \texttt{QueryEngine}, který představuje implementaci dotazovacího enginu.
\item \texttt{HPCsharp} \citep{hpcsharp} je doprovodné řešení, které poskytuje sadu mnoha výkonných jednovláknových i paralelních algoritmů.
\item \texttt{Benchmark}, který jsme implementovali pro porovnání upraveného a původního způsobu zpracování dotazu. 

\end{itemize}

V průběhu celé kapitoly se budeme věnovat pouze řešení \texttt{QueryEngine}, protože obsahuje hlavní část práce.
Řešení \texttt{Benchmark} je popsáno podrobněji v kapitole \ref{expr}. Experiment, ve které se věnujeme porovnání implementovaných řešení.
Z \texttt{HPCsharp} řešení jsme využili pouze určité algoritmy při implementaci části Order by.
Samotná implementace algoritmů lze nalézt v odkazu citovaného zdroje. 
Nyní popíšeme podrobněji rozložení řešení \texttt{QueryEngine}.

\subsection{Rozložení řešení QueryEngine}

Řešení neobsahuje další podřešení, ale pouze adresáře.
Níže popsané adresáře rozdělují engine práve na hlavní části výstavby z kapitoly analýzy.
Hlavní adresáře jsou:

\begin{itemize}

\item \texttt{DB}: obsahuje objekty grafových elementů, struktury reprezentace grafu, objekty vlastností elementů a objekty k načítání grafových dat. 

\item \texttt{DataFiles}: obsahuje datové soubory, které se při překladu projektu ve Visual Studiu překopírují k binárním souborům.

\item \texttt{Parser}: obsahuje metody parsování uživatelského dotazu, definované tokeny, objekty parsovacího stromu a objekty k procházení daného stromu.

\item \texttt{Query}: obsahuje objekty zpracování dotazu. 
Obecně představuje část, která vykonává Group by a Order by po dokončení prohledávání grafu. 

\item \texttt{QueryStreamed}: obsahuje objekty upraveného zpracování dotazu. 
Obecně představuje část, která vykonává Group by a Order by v průběhu prohledávání grafu.
Adresář částečně kopíruje strukturu adresáře \texttt{Query}.
Pokud jsou názvy složek stejné znamená to, že objekty ve složce rozšiřují právě objekty ze stejnojmenné složky uvnitř \texttt{Query}. 
Obsahuje řešení pro Streamed i Half-Streamed módy.

\end{itemize}

Podrobnější popis adresářové struktury:

\clearpage
\dirtree{%
.1 /.
.2 DB.
.3 Creator \DTcomment{Definuje api čtení vstupních souborů.}. 
.3 GraphElement \DTcomment{Definuje objekty elementů grafu.}.
.3 Processor \DTcomment{Definuje tvorbu objektů grafu.}.
.3 Table \DTcomment{Definuje typ v Property grafu.}.
.4 Property \DTcomment{Definuje vlastnosti typu v Property grafu.}.
.2 DataFiles. 
.2 Parser.
.3 ParsedPattern \DTcomment{Definuje objekty parsovaných posloupností části Match.}.
.3 Parser.
.4 ParseTree \DTcomment{Definuje objekty použité k tvorbě parsovacího stromu.}.
.5 Visitor \DTcomment{Definuje objekty procházení parsovacího stromu.}.
.4 ParserComponent \DTcomment{Definuje metody parsování tokenů dotazu.}.
.3 Tokenizer \DTcomment{Definuje tokeny a způsob tokenizace vstupu.}.
.2 Query.
.3 Expression \DTcomment{Obsahuje logiku výrazů.}.
.4 ExpressionComparer \DTcomment{Definuje porovnávání hodnot dvou výrazů.}.
.4 Reference \DTcomment{Defunuje výrazy odkazů na proměnné, jejich vlastnosti a agregační funkce.}.
.3 GroupBy \DTcomment{Definuje objekty důležité k vykonání Group by.}.
.4 Aggregate.
.5 AggregateFunction \DTcomment{Definuje logiku agregačních funkcí.}.
.4 AggregateInternalResults \DTcomment{Definuje úložiště hodnot agregačních funkcí.}.
.4 MultiGroupGroupBy \DTcomment{Definuje řešení, pokud je zadano Group by.}.
.5 EqualityComparer \DTcomment{Definuje porovnání záznamů v hašovací tabulce.}.
.5 Hasher \DTcomment{Definuje hašování výrazů.}.
.5 ParallelSolutions \DTcomment{Definuje paralelní vykonání Group by.}.
.6 GlobalGroupBy.
.6 LocalGroupByLocalTwoWayMerge.
.6 TwoStepGroupBy.
.5 ReferenceSingleThreadSolutions \DTcomment{Definuje jednovláknové vykonání Group by.}.
.4 SingleGroupGroupBy \DTcomment{Definuje řešení, pokud není zadáno Group by.}.
.3 Match \DTcomment{Definuje objekty důležité k vykonání Match.}.
.4 DFSMatch \DTcomment{Definuje obejekty DFS prohledávání.}.
.5 BaseMatch \DTcomment{Definuje objekty vzoru.}.
.5 Matcher \DTcomment{Definuje objekty algoritmu prohledávání.}.
.6 DFSParallelPatternMatcher \DTcomment{Definuje paralelní prohledávání.}.
.6 DFSPatternMatcher \DTcomment{Definuje jednovláknové prohledávání.}.
.5 Pattern \DTcomment{Definuje api vzoru.}.
.4 MatchInternalResults \DTcomment{Definuje interní struktury Match pro ukládání výsledků prohledávání.}.
.3 OrderBy \DTcomment{Definuje objekty důležité k vykonání Order by.}.
.4 Comparer \DTcomment{Definuje porovnání řádků tabulky pomocí proxy třídy.}.
.5 Wrappers \DTcomment{Definuje porovnání řádků tabulky pomocí indexu.}.
.4 Sorter \DTcomment{Definuje algoritmy třídění.}.
.6 TableSorter \DTcomment{Definuje algoritmy třídění tabulky.}.
.3 Results \DTcomment{Definuje tabulky výsledků.}.
.4 GroupByResults \DTcomment{Definuje formát tabulky výsledků Group by.}.
.4 TableResults \DTcomment{Definuje formát tabulky pouze pro elementy grafu.}.
.3 Select \DTcomment{Definuje objekty důležité k vykonání Select.}.
.4 ExpressionToStringWrapper  \DTcomment{Definuje objekt převodu hodnoty výrazu na řetězec.}.
.4 Formater  \DTcomment{Definuje formát výstupu.}.
.4 Printer  \DTcomment{Definuje kam se má výstup vypsat.}.
.2 QueryStreamed.
.3 GroupBy  \DTcomment{Definuje objekty důležité pro upravené vykonání Group by.}.
.4 AggregateInternalResults  \DTcomment{Definuje upravené úložište agregačních funkcí pro Streamed mód.}.
.4 MultiGroupGroupBy  \DTcomment{Definuje Streamed a Half-Streamed řešení, pokud je zadáno Group by.}.
.5 BucketKeyValueFactory  \DTcomment{Definuje výrobu klíče hašovací tabulky pro Streamed mód.}.
.5 Comparers  \DTcomment{Definuje porovnání využité Half-Streamed a Streamed módem.}.
.4 SingleGroupGroupBy \DTcomment{Definuje Streamed a Half-Streamed vykonání, pokud není zadáno Group by.}.
.3 Match  \DTcomment{Definuje objekty důležité pro upravené vykonání Group by.}.
.4 DFSMatch  \DTcomment{Definuje pozměněná api pro předávání výsledků částem v průběhu hledání.}.
.5 Matcher.
.6 DFSParallelPatternMatcher.
.6 DFSPatternMatcher.
.3 OrderBy \DTcomment{Definuje objekty důležité pro upravené vykonání Order by.}.
.4 ABTree \DTcomment{Definuje použité vyhledávací stromy.}.
.4 Sorter \DTcomment{Definuje Half-Streamed a Streamed vykonání pomocí vyhledávacích stromů.}.
.5 ABTreeSorterHalfStreamed.
.5 ABTreeSorterStreamed.
.6 Comparer.
.7 Wrapper \DTcomment{Definuje porovnání akumulovaných skupin pomocí proxy třídy.}.
.4 TypeRangeHasher \DTcomment{Obsahuje objekty, které rozdělují rozsah typu na přihrádky.}.
.3 Results \DTcomment{Definuje upravené fotmáty tabulek výsledků.}.
.4 GroupByResults.
.4 TableResults.
.5 ABTree \DTcomment{Formát tabulky pro řešení s normálním (a, b)-stromem.}.
.5 ABTreeAccum \DTcomment{Formát tabulky pro řešení s (a, b)-stromem, který akumuluje shodné řádky.}.
}

\section{Programátorská dokumentace}

V této sekci popíšeme postupně klíčové objekty, položky a způsoby vypracování aplikace.  

\subsection{Reprezentace grafu}
V tétto sekci popíšeme hlavní objekty, které jsme použili k reprezentaci grafových dat.
Při implementaci jsme postupovali dle návrhu z sekce analýzy \ref{anal.grafrep}.

\subsubsection{Třída Element}

Všechny druhy elementů v grafu (vrchol a hrana) dědí od abstraktní třídy \texttt{Element}.
Představuje obený základ všech elementů.
Hlavní vlastnosti jsou:
\begin{itemize}
\item \texttt{int ID} je unikátní identifikátor elementu. Definuje jej uživatel ve vstupním souboru. Není to vlastnost v Property grafu.
\item \texttt{Table Table} odkaz na typ v Property grafu.
\item \texttt{int PositionInList} pozice v \texttt{List<T>}, kde \texttt{T} je potomek třídy \texttt{Element}, protože každý potomek je obsažen ve vlastním poli.
Pole pak jsou obsažená v třídě \texttt{Graph}.
\end{itemize}

Potomek abstraktní třídy je třída \texttt{Vertex} (vrchol) a abstraktní třída \texttt{Edge} (hrana).
\texttt{Edge} přidává novou položku \texttt{Vertex EndVertex}, která odkazuje na koncový vrchol hrany.
Z dané třídy vznikají konkrétní potomci \texttt{InEdge} a \texttt{OutEdge}.
Hrany jsou orientované a spojují dva vrcholy.
Mějme hranu z vrcholu x do y.
Položka \texttt{Endvertex} pro \texttt{OutEdge} zde odkazuje na vrchol y.
Pro \texttt{InEdge} to je x.
Tedy pro každou definovanu hranu v grafu existují obě instance tříd. 
Instance sdílejí \texttt{ID}, ale záznam v \texttt{Table} je pouze jeden, tedy sdílejí i hodnoty vlastností. 
\texttt{Vertex} přidává položky dvou dvojic indexů, o kterých jsme mluvili v analýze.
První dvojice je \texttt{int OutEdgesStartPosition} a \texttt{int OutEdgesEndPosition}, které označují rozsah hran v poli \texttt{OutEdge} náležících vrcholu.
Druhá dvojice je pro typ \texttt{InEdge} ekvivalentí.
Celkově tedy třída \texttt{Graph} bude obsahovat pole \texttt{List<T>} pro každého neabstraktního potomka třídy \texttt{Element}.

\subsubsection{Třída Table}

Třída \texttt{Table} určuje typ elementu v Property grafu.
Hlavní vlastnosti jsou:
\begin{itemize}
\item Položka \texttt{string IRI} je název typu.
\item Položka \texttt{Dictionary<int, int> IDs}, kde klíčem je \texttt{ID} elementu a hodnota je pozice hodnot vlastností ve struktuře, která je obsahuje (tj. třídě \texttt{Property}).
\item Položka \texttt{Dictionary<int, Property>}, kde klíč je \texttt{ID} vlastnosti a hodnota je třída reprezentující vlasnost.
\item \texttt{bool TryGetPropertyValue<T>(int id,int propID, out T retValue)}\\* 
je metoda, která se pokusí získat hodnotu vlastnosti \texttt{propID} pro daný element s daným \texttt{id}.
Hodnota se vrací v \texttt{retValue}. Úspěšně dokončená vrací \texttt{true}, jinak \texttt{false}.
\end{itemize}

\subsubsection{Třída Property}

Samotné vlastnosti jsou reprezentovány abstraktní třídou \texttt{Property}, která má svůj nazev \texttt{string IRI}.
Z třídy vznikají abstraktní generické třídy \texttt{Property<T>}, kde \texttt{T} je typ hodnot vlastnosti.
Třída obsahuje pole hodnot \texttt{List<T> propHolder}.
Z třídy pak vznikají konkrétní třídy:
\begin{itemize}
\item \texttt{StringProperty}, kde \texttt{T} je \texttt{string}. Odpovídá typu \texttt{string} ve vstupním JSON schématu.
\item \texttt{IntProperty}, kde \texttt{T} je \texttt{Int32}. Odpovídá typu \texttt{integer} ve vstupním JSON schématu.
\end{itemize}
V analýze jsme se rozhodli implementovat pouze tyto dva typy. 
Což znamená, že v celém enginu bude možno pracovat \textbf{pouze s těmito dvěma typy}.
Tyto třídy mají metodu \texttt{void ParsePropFromStringToList(string strProp)}, která se používá při načítání hodnot ze vstupních souborů.
Převede hodnotu \texttt{strProp} na svůj typ \texttt{T} a uloží na konec pole \texttt{propHolder}.
Každý element v \texttt{Table} má svou hodnotu vlastnosti v poli na pozici \texttt{IDs[Element.ID]}.
Třídy vlastností se vytvářejí pomocí třídy \texttt{PropertyFactory}, která implementuje Factory metodu \citep[str. 107]{patterns} \texttt{Property CreateProperty(string token, string name)}.
Kde \texttt{token} je typ vlastnosti a \texttt{name} je její název.

\subsubsection{Třída Graph}

Třída \texttt{Graph} pak reprezentuje celý graf.
Můžeme se dívat na ni spíše jako na objekt držící data grafu a ne objekt se složitou logikou.
Načítá grafová data během inicializace.
Zároveň dělá kontrolu načtených vlastností a jejich typů během načítání.
Obsahuje pole všech typů elementů. Tedy \texttt{List<Vertex>}, \texttt{List<InEdge>} a \texttt{List<OutEdge>}.
Obsahuje dále:
\begin{itemize}
\item \texttt{Dictionary<string, Table> nodeTables} všechny typy vrcholů Property grafu. To samé pro hrany.
\item \texttt{Dictionary<string, Tuple<int, Type> > labels} mapa, kde klíč je název vlastnosti a \texttt{int} je její přiřaděný unikátní identifikátor, abychom nemuseli v enginu používat řetězce jako \texttt{ID} vlastnosti.
\texttt{Type} je pak typ vlastnosti, slouží pro kontrolu, protože dvě stejnojmenné vlastnosti musí mít stejný typ. 
\end{itemize}


\subsection{Čtení vstupních souborů}

Máme imlementován graf a nyní jej potřebujeme načíst.
Budeme vycházet z kapitoly analýzy sekce \ref{anal.vstup}
Rozdhodli jsme se použít totožný vstupní formát dat jako při analýze.
Při spuštění program očekává čtyři soubory.
Dva soubory se zmiňovaným JSON formátem \textit{EdgeTypes.txt} (schéma hran) a \textit{NodeTypes.txt} (schéma vrcholů), které definují typy Property grafu a jejich vlastnosti.
Další dva soubory \textit{Edge.txt} a \textit{Nodes.txt} obsahují samotná data s mezerami jako oddělovače.
Jediná úprava formátu je ta, že hrany v datovém souboru musí být seřazeny podle \texttt{ID} počátečního vrcholu hrany tak, jak jsou vrcholy seřazeny v jejich datovém souboru.
To zmanená, že pokud máme v souboru vrcholů za sebou vrcholy s \texttt{ID} 1, 2 a 3, tak soubor hran musí nejdříve obsahovat hrany začínající vrcholem s \texttt{ID} 1, pak s \texttt{2} apod.

Načítání je implementováno následovně.
\texttt{interface Creator<T>} s metodou \texttt{T Create()} je rozhraní pro tvorbu objektů \texttt{T}.
Tento vzor rozšíříme na třídu \texttt{CreatorFromFile<T>}, která symbolizuje tvorbu objektu \texttt{T} postupným čtením souboru.
Třída očekává při incializaci rozhraní \texttt{IReader} čtoucí vstupní soubor metodou \texttt{string Read()}, která přečte vždy určitý úsek souboru.
Dále rozhraní \texttt{IProcessor} vytvářející iterativně \texttt{T} na základě poskytnutých částí souboru.
Protože text je čtený po částech, tak \texttt{IProcessor} implementuje návrhový vzor State \citep[str. 305]{patterns}.
V našem případě nejdříve zpracujeme soubory schémat pomocí třídy \texttt{TableDictProcessor}, která vytváří třídy \texttt{Table}.
Následně čtením datového souboru \textit{Nodes.txt} vytvoříme třídou \texttt{VerticesListProcessor} pole vrcholů.
A posledně čtením datového souboru \textit{Edges.txt} vytvoříme dva pole \texttt{InEdge} a \texttt{OutEdge} třidou \texttt{EdgeListsProcessor}. 
Rozhraní \texttt{IProcessor} implementují všechny tyto třídy.
Samotné čtení souborů je vyvoláno při inicializaci třídy \texttt{Graph}.

\subsection{Parsování uživatelského dotazu}

Při parsování jsme vycházeli z sekce analýzy \ref{anal.parsing}.
Nejdřive dojde k tokenizaci a následně vytváření parsovacího stromu.

\subsubsection{Třída Tokenizer}

V prvním kroku dojde k tokenizaci uživatelského dotazu třídou \texttt{Tokenizer}.
Uživatel zadá aplikaci svůj dotaz a třída provede tokenizaci.
Výstupem tokenizace je pole \texttt{List<Token>}, které obsahuje všechny nalezené tokeny.
Tokenem zde myslíme \texttt{struct Token}, který obsahuje dvě položky.
První je \texttt{TokenType type}, což je typ tokenu.
Druhá je \texttt{string strValue}, která obsahuje hodnotu tokenu, pokud se jedná o token \texttt{Identifier}.
Tomu odpovída například token názevu proměnné.
Pole tokenů se předá statické třídě \texttt{Parser}.

\subsubsection{Třída Parser}

Třída postupně z tokenů vytváří parsovací stromy každé hlavní části dotazu (Match, Select, Order by a Group by).
Parsování se vyvolá veřejnou metodou \texttt{Parse(List<Token> tokens)}.
Parsování tokenů probíhá po částech.
Každá hlavní část dotazu má svou separátní metodu.
Například \texttt{ParseMatch(ref int position, .. tokens)} parsuje část Match. 
V průběhu parsování částí se rekurzivně volájí další metody.
V průběhu rekurze se používá parametr \texttt{position}, který udržuje pozici aktuálně parsovaného tokenu.

Parsovací stromy jsou tvořeny potomky asbtraktní třídy \texttt{Node}, která implementuje návrhový vzor Visitor, tj. metodu \texttt{Accept<T>(IVisitor<T>)}.
Rozhraní \texttt{IVisitor<T>} implementuje druhou část vzoru, tj. metody \texttt{Visit(..)}.
Každá část dotazu má svůj objekt implementující \texttt{IVisitor<T>}, například Match má objekt \texttt{MatchVisitor}.
Parametr \texttt{T} je zde návratová hodnota procházení parsovacího stromu.
Výstupem třídy \texttt{Parser} je množina všech vzniklých parsovacích stromů.
Samotná tokenizace a parsování se provádí při inicializaci třídy \texttt{Query}.
Procházení parsovacích stromů je rovněž prováděno při inicializaci dané třídy.

\subsection{Reprezentace dotazu}
Celý dotaz jsme reprezentovali třídou \texttt{Query}.
Exekuční plán a samotné zpracování pak bude odpovídat popisu z sekce analýzy \ref{anal.vykonanidotazu}.

\subsubsection{Třída Query}

Třída reprezentuje celý dotaz.
Obsahuje všechny struktury, které se využívají pro vykonání dotazu.
Objekt je používán uživatelem.
Poskytuje statické veřejné metody \texttt{Query Create(..)} a \texttt{void Compute()}.
Metoda \texttt{void Compute()} spustí vykonání dotazu.
Metoda \texttt{Query Create(..)} vytváří dotaz.
Daná metoda dostává množství argumentů, vypíšeme ty hlavní:
\begin{itemize}
\item \texttt{string/TextReader inputQuery}: definuje dotaz uživatele, který se má vykonat. \texttt{string} zde reprezentuje vstup jako řetězec. \texttt{TextReader} představuje vstup z konzole.
\item \texttt{QueryMode mode}: definuje jaký mód vykonávání se má provádět.
\item \texttt{Graph graph}: definuje graf, nad kterým se má dotaz provést.
\item \texttt{ThreadCount threadCount}: definuje počet vláken, které se mají využít při vykonávání.
\item \texttt{GrouperAlias grouperAlias}: definuje jaké řešení se má použít při vykonávání Group by.
\item \texttt{SorterAlias sorterAlias}: definuje jaké řešení se má puužít při vykonávání Order by.
\end{itemize}
Při zavolání metody dojde k tokenizaci \texttt{inputQuery} a kontrole všech argumentů metodou \texttt{CheckArgs}.
Zkontrolované argumenty a pole \texttt{List<Token>} se předají privátnímu konstruktoru třídy \texttt{Query}.
Upravené módy sdílí konstruktor. Mód \textbf{Normal} má separátní konstruktor.
Uvnitř obou konstruktorů dochází k parsování pole tokenů třídou \texttt{Parser}.
Výstupem jsou stromové struktury hlavních částí dotazu, které jsou dále použity k inicializaci privátních položek a exekučního plánu:
\begin{itemize}
\item \texttt{VariableMap variableMap} je seznam proměnných vyskytujících se v dotazu. Seznam obsahuje jejich přidělený identifikátor a typ, pokud byl definován.
\item \texttt{QueryObject query} je exekuční plán. Obsahuje řetězec objektů, které postupně vykonávají dotaz.
\item \texttt{QueryExecutionHelper qEhelper} obsahuje informace o způsobu vykonání dotazu. Převážne obsahuje argumenty konstruktoru. 
\item \texttt{QueryExpressionInfo exprInfo} obsahuje všechny výrazy (expressions) v dotazu.
\end{itemize}
Po inicializaci, v moment volání metody \texttt{Compute()} dojde k vyvolání metody \texttt{Compute(..)} na exekučním plánu.

\subsubsection{Třída QueryObject}

Jedná se o abstraktní třídu.
Každá hlavní část dotazu je reprezentována potomkem dané třídy (\texttt{MatchObject}, \texttt{SelectObject}, ...).
Třída definuje rozhraní exekučního plánu.
Obsahuje:
\begin{itemize}
\item Položku \texttt{QueryObject next}, která propojuje objekt s dalším objektem.
\item Metodu \texttt{void Compute(out ITableResults r,} \texttt{out GroupByResults g)}, která rekurzivné volá stejnou metodu na dalším objektu.
Každý potomek třídy si implementuje vlastní logiku zpracování této metody.
Všimněme si, že tato metoda definuje rozhraní pro předávání výsledků zpracování.
\texttt{ITableResults} definuje obecné rozhraní tabulky výsledků hledání, pokud není zadáno Group by.
\texttt{GroupByResults} definuje formát výsledků Group by.
\item Metodu \texttt{void AddToEnd(QueryObject queryObject)}, která připojí \\*poskytnutý objekt na konec řetězce.
\end{itemize}
Konkrétní potomci třídy jsou vytvářeny v konstruktoru třídy \texttt{Query}.
Navíc, každý potomek očekává v konstruktoru parsovací strom.
Uvnitř kontruktoru dojde k vytvoření adekvátního \texttt{IVisitor<T>} objektu.
Návratová hodnota \texttt{T} se využije ke konstrukci privátních objektů pro vykonání dotazu.

\subsection{Třída MatchObject}

Budeme vzcházet z sekce analýzy \ref{anal.match}.
Třída reprezentuje Match část dotazu.
Je potomkem třídy \texttt{MatchObjectBase}, která je potomkem \texttt{QueryObject}.
Daný mezikrok vznikl, protože objekt části Match upraveného zpracování používá stejnou motodu ke kontrole vzoru uživatele \texttt{ParsedPatternCorrectness}.
Metoda kontroluje uživatelem zadaný vzor, jestli splňuje podmínky jazyka PGQL. 
Metoda očekává na vstupu pole tříd, které je výstupem procházení parsovací stromové struktury objektem \texttt{MatchVisitor}. 

\subsubsection{Třída ParsedPattern}

\texttt{MatchVisitor} vytváří procházením stromu pole tříd \texttt{List<ParsedPattern>}.
Třída \texttt{ParsedPattern} reprezentuje jednu vyhledávací posloupnost Match části (např. \texttt{(x) -> (y)}).
V poli je tolik tříd, kolik je v dotazu posloupností oddělených čárkou.
Třída obsahuje:
\begin{itemize}
\item Pole abstraktních tříd \texttt{List<ParsedPatternNode> pattern}.
Třída reprezentuje jeden hledaný element v posloupnosti, tj. hrana  (\texttt{-[e]>}) nebo vrchol (\texttt{(x)}).
Obsahuje položky \texttt{string Name}, pokud je element označen proměnnou (např. vrchol \texttt{(x)}), a \texttt{Table Table} pokud je definován typ elementu (např. vrchol \texttt{(:Type)}).
Potomci specifikují konkrétní případy vrcholů a hran. Pokud vezmeme příklad výše \texttt{(x) -> (y)}, tak pole bude obsahovat tří třídy.
\texttt{pattern[0]} je třída vrcholu \texttt{x}, \texttt{pattern[1]} je třída \texttt{OutEdge} hrany,  apod.

\item Položku \texttt{string splitBy}, která označuje jméno proměnné, podle které posloupnost budeme dělit na dvě posloupnosti v průběhu vytváření objektu vzoru.
Výsledkem dělení budou tedy dvě třídy \texttt{ParsedPattern}.
Část před proměnnou, podle které dělíme, bude tvořit posloupnost převrácenou.
To znamená, pokud máme posloupnost tříd \texttt{ParsedPatternNode} \texttt{(x) -> (y) -> (z)} a dělíme podle \texttt{(y)}, pak výsledkem dělení jsou posloupnosti 
\texttt{(y) <- (x)} a \texttt{(y) -> (z)}.

\item Metodu\\* \texttt{bool TryFindEqualVariable(ParsedPattern p, out string n)}, která \\*vrátí název první sdílené proměnné s posloupností \texttt{p}, pokud nějaká existuje.
Pokud existuje, metoda vrací \texttt{true} a název v \texttt{n}.

\item Metodu \texttt{void TrySplitParsedPattern()}, která zkusí provést rozdělení posloupnosti.
Rozdělení se nemusí provést, pokud je rozdělováno podle první položky \texttt{List<ParsedPatternNode>}. 
Pokud je rozdělováno podle poslední, posloupnost se pouze převrátí.

\end{itemize}
Z daného formátu se během vytváření struktur Match části vytvoří finální hledaný vzor \texttt{DFSPattern} s pomocí zmíněný metod a položek.

\subsubsection{Třída DFSPattern}

Třída reprezentuje hledaný vzor (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{Pattern}).
Konstruktor dostane pole \texttt{ParsedPattern}.
V analýze jsme řekli, že se z posloupnosti vytvoří souvislé kompomenty.
Aplikováním výše zmíněných metod nalezneme sdílené proměnné.
Pole, která sdílejí proměnnou, seskupíme k sobě a samotné posloupnosti rozdělíme pomocí položky \texttt{splitBy}.
Výsledkem bude pole posloupností a souvislé komponenty v něm budou obsaženy postupně za sebou.
Příklad seskupení a rozdělení:
\begin{code}
Původní List<ParsedPattern> a unitř List<ParsedPatternNode>:
[[(x), ->, (z)], [(r), ->, (q)], [(y), ->, (x), ->, (w)]]
Pole po zpracovní:
[[(x), ->, (z)], [(x), <-, (y)], [(x), ->, (w)], [(r), ->, (q)]]
\end{code}
Zde vidíme, že první tři posloupnosti po zpracování tvoří souvislou komponentu, ale původně nebyli v poli za sebou.
V průběhu hledání budeme vždy iterovat po daných posloupnostech.
V moment nalezení vhodného elementu se posuneme na další prvek posloupnosti (doprava) nebo na novou posloupnost.
To symbolizuje DFS krok zanoření.
Opačně se posouváme doleva a zkoušíme ještě neprohledané elementy grafu.
Díky rozdělení můžeme při přesouvání na začátek další posloupnosti vždy navázat již nalezenou proměnnou, pokud existuje a jedná o součást aktuální komponenty.
Z pole posloupnosti nyní vytvoříme pole \texttt{DFSBaseMatch[][] patterns}.
\texttt{patterns[i]} znamená přístup k \textit{i}-té posloupnosti a \texttt{patterns[i][j]} přístup k \textit{j}-té položce  \textit{i}-té posloupnosti. 

Vzor kromě \texttt{patterns} obsahuje pole \texttt{Element[] scope}.
Pole obsahuje každou proměnnou hledání právě jednou. 
Pokud ve vzoru není žádná proměnná, tak je pole vždy prázdné.
Každá proměnná má svou pozici.
Tyto pozice budeme chápat jako \texttt{ID} proměnných v celém dotazu.
V moment nalezení vhodného elementu proměnné se element uloží do daného pole na pozici proměnné.
V moment vynořování z DFS se element z pozice smaže.
Položka se používá ke kopírování do tabulky nebo k dalšímu zpracování.

Vzor dále implementuje rozhraní \texttt{IDFSPattern} spolu s \texttt{IPattern}, které slouží k posouvání po posloupnosti.
Mají množství metod, ale vypíšeme pouze hlavní:
\begin{itemize}
\item Položka \texttt{int CurrentPatternIndex} je index aktuální posloupnosti procházení.
\texttt{patterns[CurrentPatternIndex]} vrátí aktuální posloupnost.

\item Položka \texttt{int CurrentMatchNode} je aktuální objekt \texttt{DFSBaseMatch} v posloupnosti.
\texttt{patterns[CurrentPatternIndex][CurrentMatchNode]} je aktuální objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{void PrepareNextSubPattern()} připraví k procházení následující posloupnost.
\item Metoda \texttt{void PreparePreviousSubPattern()} připraví k procházení předchozí posloupnost.
\item Metoda \texttt{void PrepareNextNode()} připraví k procházení následující objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{void PreparePreviousNode()} připraví k procházení předchozí objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{Element[] GetMatchedVariables()} vrátí \texttt{scope} vzoru.
\item Metoda \texttt{bool Apply(Element[] e)} slouží ke zjištění, zda držený element je použitelný pro aktuální pozici ve vzoru.
Vyvolá stejnojmennou funkci na třídě \texttt{DFSBaseMatch}.
\end{itemize}

\subsubsection{Třída DFSBaseMatch}

Nyní popíšeme třídu vytvářející pole posloupnosti hledání.
\texttt{DFSBaseMatch} je abstraktní třída, reprezentující jeden element procházení grafu.
Třída obsahuje:
\begin{itemize}
\item Položku \texttt{bool isAnonnymous} která říká, jestli se jedná o proměnnou.
\item Položku \texttt{bool isFirstAppearance} která říká, pokud se jedná o proměnnou, jestli už je to její první nález.
\item Položku \texttt{int positionOfRepeatedField} která říká, pokud to není první nález proměnné, tak kde v \texttt{scope} se nachází. 
\item Metodu \texttt{bool Apply(Element e, Element[] map)}, která ověřuje jestli \\*element \texttt{e} se dá použit v aktuálním kroku hledání.
\texttt{map} je pak \texttt{scope} vzoru, kde se případně ověří rovnost elementů opakující se proměnné. Při úspěchu vrací \texttt{true}.
\end{itemize}
Potomci pak specifikují, jestli se jedná o \texttt{Vertex}, \texttt{InEdge}, \texttt{OutEdge} nebo \texttt{AnyEdge}.
Ještě než popíšeme struktury algoritmu prohledávání, tak popíšeme struktury pro ukládání výsledků vláken v průběhu hledání.

\subsubsection{Třída MatchFixedResultsInternal}

Máme implementován vzor a metody k procházení vzoru.
Nyní popíšeme implementaci ukládání výsledků hledání.
Třída obsahuje lokální tabulku výsledků vlákna při prohledávání grafu (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{Výsledky}). 
Každé vlákno má odkaz na vlastní třídu v průběhu hledání.
Za finální výsledek hledání se považují hodnoty v poli \texttt{scope}.
Sloupečky zde tedy odpovídají unikáním proměnným v grafu.
Řádek je pak kopie daného pole.
Ukládáme pouze elementy grafu.
Uvnitř je:
\begin{itemize}
\item Položka \texttt{int ColumnCount}, která udává počet sloupečků tabulky. 
\item Položka \texttt{int FixedArraySize}, která udává velikost bloků uvnitř tabulky.
\item Položka \texttt{List<Element[][]> ResTable} je tabulka výsledků. 
Je složená z bloků \texttt{Element[][FixedArraySize] block} kostantní velikosti.
\texttt{block[i]} přistupuje k \textit{i}-tému sloupečku a \texttt{block[i][j]} přistupuje k \textit{j}-té pozici \textit{i}-tého sloupečku.
\item Položka \texttt{Element[][] LastBlock} je odkaz na poslední nezaplněný blok.
\item Položka \texttt{int CurrentPosition} je odkaz na první volný index v posledním bloku.
\item Metoda \texttt{void AddRow(Element[] row)} přidá nový výsledek do tabulky.
Pokud je poslední blok zaplněn, vytvoří se nový.
Při vytváření nového bloku nemusí docházet k překopírovávání výsledků hledání, protože pole \texttt{ResTable} drží odkazy na zmíněné bloky.
Očekává se, že \texttt{row} je položka \texttt{scope} vzoru. 

\end{itemize}

\subsubsection{Třída MatchFixedResults}

Třída obsahuje lokální vabulky všech vláken v položce \texttt{matcherResults}.
Takto budeme moct přistoupit k lokálním výsledkům po dokončení hledání.
Třída zároveň poskytuje rozhraní pro slévání sloupečků tabulek vláken v metodě \texttt{void MergeColumn(int columnIndex)}, která slévá jeden sloupeček.
Výsledky jsou slévány do položky \texttt{List<Element[]>[] FinalMerged}.

\subsubsection{Třída DFSPatternMatcherBase}

Implementovali jsme vzor a ukládání výsledků.
Naní popíšeme implementaci algoritmu procházení (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{Matcher}).
Abstraktní třída reprezentuje základní jednovláknový algoritmus DFS prohledávání grafu.
Prohledání jsme implementovali přesně podle analýzy.
Samotný algoritmus nebudeme popisovat, ale popíšeme jen základní položky.
Třída v konstruktoru očekává vzor \texttt{DFSPattern} a graf \texttt{Graph}.
Obsahuje dva indexy \texttt{int startVerticesIndex} a \texttt{int startVerticesEndIndex}.
Dva indexy určují rozsah vrcholů z pole vrcholů \texttt{List<Vertex>}, ze kterých se bude spouštět prohledávání.
Dané položky jsou inicializovány na celý rozsah pole, což odpovídá jednovláknovému zpracování.
Třída má rozhraní \texttt{void SetStartingVerticesIndeces( int start, int end)} nastavující dané indexy rozsahu.
Daná metoda se používá v paralelním zpracování, kdy je přidělováno malé množství vrcholů z grafu k prohledání.
Metodou \texttt{void Search()} se spustí prohledávání.
Prohledávání prochází všechny vrcholy v definovaném rozsahu a pak se ukončí.
V tento moment lze nastavit zmíněnou metodou další rozsah a opět spustit hledání.
V moment nalezení finálního výsledku se zavolá abstraktní metoda \texttt{void ProcessResult()}, která zpracuje výsledek.
Rozhraní prohledávání neposkytuje návrat nalezených výsledků.
Pokud se výsledky mají ukládat, tak potomek dané třídy musí dostat v konstruktoru objekt úložiště a přepsat metodu \texttt{void ProcessResult()}
Způsob zpracování výsledku si definují potomci.

\subsubsection{Třída DFSPatternMatcher}

Třída je potomkem třídy výše.
reprezentuje algoritmus prohledávání, které ukládá výsledky do tabulky v moment jejich nalezení.
V konstruktoru dostane tabulku \texttt{MatcherFixedResultsInternal}, kam ukládá své výsledky hledání.
Metoda \texttt{ProcessResult} tedy ukládá výsledky do dané tabulky.

\subsubsection{Třída DFSParallelPatternMatcher}

Třída představuje paralelní prohledávání grafu, které ukládá výsledky v moment nalezení do tabulky.
Paralelizaci jsme popsali v sekci \ref{anal.matchPar}.
V konstruktoru dostává počet vláken \texttt{ThreadCount}, vzor \texttt{DFSPattern}, graf \texttt{Graph} a instanci úložiště výsledků \texttt{MatchFixedResults}.
K paralelizaci prohledávání využívá instance třídy \texttt{DFSPatternMatcher} a počet instanci odpovídá hodnotě \texttt{ThreadCount}.
Tedy v konstruktoru vytvoří tyto instance a každé přidělí kopii vzoru, graf a její lokální úložiště.
Výsledně obsahuje položky:
\begin{itemize}
\item \texttt{MatchFixedResults results} obsahuje lokální tabulky výsledků vláken.
\item \texttt{DFSPatternMatcher[] matchers} obsahuje instance tříd algoritmů prohledávání.
Každá instance má svou lokální kopii vzoru a odkaz na tabulku výsledků.
\end{itemize}
Paralelní prohledávání je spuštěno metodou \texttt{void Search()}.
Zde využíváme nativní \texttt{ThreadPool}.
Je vytvořeno \texttt{ThreadCount} instancí \texttt{Task} vykonávají práci \texttt{WorkMultiThreadSearch(object o)}, kde \texttt{o} je lokální \texttt{JobMultiThreadSearch}.
Ten obsahuje instanci prohledávání a objekt \texttt{VertexDistributor}.
Objek jsme definovali v analýze (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{VertexDistributor}).
Drží odkaz na pole vrcholů grafu a index posledního přiděleného vrcholu.
Množství přidělených vrcholů je definovám v jeho položce \texttt{int verticesPerRound}.
Vklákna jej žádají o vrcholy k prohledávání, metodou \texttt{DistributeVertices(..)}.

Po dokončení hledání dojde k paralelnímu slévání tabulek.
Rozdhodli jsme se použít metodu slévání po sloupečcích tabulek, protože slévání celých tabulek po dvojicích bylo pomalejší.
Paralelizace probíhá stejně.
Přidělování sloupečků ke slévání je implementováno pomocí třídy \texttt{ColumnDistributor}.  
Třída si pamatuje index prvního nepřiděleného sloupečku \texttt{int firstFreeColumn}.
V moment dokončení slévání jsou finální výsledky v položce \texttt{results.FinalMerged}.
Tato položka je předána konstruktoru \texttt{TableResults}, která implementuje rozhraní \texttt{ITableResults}.

\subsection{Tabulka výsledků}

Objekty exekučního plánu si předávají tabulku výsledků hledání rozhraním \texttt{ITableResults}.
Ačkoliv jsme navrhli rozhraní, tak obecně používáme pouze jednu třídu \texttt{TableResults}, která rozhraní implementuje.
Tabulku jsme implementovali dle sekce analýzy \ref{anal.tables}.
Zároveň jsme ji upravili rovnou k možnosti použití pro ukládání pouze reprezentantů skupin popsaném v sekci \ref{anal.uprava.Groupby.table}.
Hlavní vlastnosti jsou:
\begin{itemize}
\item \texttt{int ColumnCount} je počet sloupečků v tabulce.
Sloupeček zde odpovídá jedné proměnné dotazu, tj. na jeden řádek se díváme jako na hodnoty v poli \texttt{scope} z průběhu hledání.
Tedy počet sloupečků je roven počtu unikátních proměnných v dotazu.
Pokud chceme přistoupit k proměnné výsledku hledání, musíme znát jeji pozici v poli \texttt{scope}.

\item \texttt{int RowCount} je počet řádků v tabulce.
\item \texttt{int FixedArraySize} je velikost bloků v tabulce.
Tabulka opět využívá princip ukládání výsledků do bloků fixní délky.
Stejný princip jsme použili při ukládání výsledků v průběhu hledání.
To nám umožní v moment dokočení slévání pouze přesunou výsledky do kostruktoru této třídy.
\item \texttt{List<Element[FixedArraySize]>[] resTable} je tabulka výsledků hledání.
\texttt{resTable[i]} je \textit{i}-tý sloupeček.
\texttt{resTable[i][j]} je \textit{j}-tý blok ve sloupečku.
\texttt{resTable[i][j][k]} je \texttt{k}-tý výsledek v bloku.
\item \texttt{Element[] tmpRow} představuje odkaz na pole elementů, ke kterému lze přistoupit skrze api, aniž by bylo pole elementů v tabulce.
\item Metoda \texttt{StoreRow(Element[])} překopíruje hodnoty do tabulky. Funguje ekvivalentně jako \texttt{AddRow} ve třídě \texttt{MatcherFixedResultsInternal}.
\item Metoda \texttt{StoreTemporaryRow()} vyvolá metodu výše pro uložení pole \texttt{tmpRow} do tabulky.
\item Metoda indexeru \texttt{RowProxy this[int i]}, která vrátí proxy třídu řádku.
\end{itemize}
V průběhu analýzy jsme navrhli způsob práce s řádky. 
Místo abychom pracovali konkrétně s řádky implementovali jsme proxy třídu řádku \texttt{struct RowProxy}.
Třída obsahuje pouze dvě položky index řádku \texttt{int index}, který reprezentuje, a odkaz na tabulku \texttt{TableResults resTable}.
Získá se voláním indexeru na tabulce.
Na struktuře se pak voláním metody \texttt{Element this[int c]} přistoupí k proměnné na řádku tabulky.
Danou třídu pak budeme používat k vyhodnocení výrazů a výpočtům agregačních funkcí.

\subsection{Expressions}

Návratová hodnota \texttt{ExpressionVisitor}, je ExpressionBase.
ExpressionBase představuje abtrakci výrazu (expression), kterým jsme v analýze věnovali značnou pozornost.
Samotná implementace je takměr totožná.

%\texttt{}
%\begin{itemize}
%\item \texttt{}
%\end{itemize}
