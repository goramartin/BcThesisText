\chapter{Implementace}
\label{impl}
   
Dokončili jsme analýzu, návrh a návrh úprav dotazovacího enginu.
V této kapitole popíšeme implementaci.
Začneme výběrem jazyka, obecným rozložením aplikace, popisu hlavních bloků a skončíme konkrétnějším pohledem na vybrané části aplikace.

\section{Výběr jazyka}

Aplikaci jsme se rozhodli implementovat v jazyce C\# pro .NET Framework 4.8.
K výběru jazyka jsme měli několik důvodů.
Framework nabízí množství knihoven, modulů a základních datových struktur.
Dále také poskytuje nástroje pro práci ve vícevláknovém prostředí.
Uvažovali jsme ještě o jazyku C++, který nabízí množství technik a možností optimalizace k získání rychlosti při vykonávání aplikace. 
Nyní zmíníme, že hlavním cílem práce není vyvinou co nejrychlejší dotazovací engine, ale otestovat obecný koncept vykonávání \textit{Group by} a \textit{Order by} v průběhu prohledávání grafu.
Myslíme, že tento koncept se dá implementovat v každém jazyce.
Navíc v průběhu analýzy jsme si zkoušeli již implementovat určité koncepty v daném jazyce C\#, abychom měli lepší přehled o způsobech vykonání.
Z tohoto důvodu jsme měli určité části již implementovány.
Výsledně jsme se rozhodli z výše zmíněných důvodu použít C\# pro .NET Framework 4.8.

\section{Značení módů} \label{impl.engine.modes}

Určili jsme, že engine bude pracovat v několika módech, které uživatel bude moct měnit.
Jsou to módy:

\begin{itemize}

\item \textbf{Normal:} reprezentuje původní způsob vykonávání.
V prvním kroku dojde k prohledání grafu a uložení výsledků do tabulky.
Teprve po dokončení dojde vykonání \textit{Group by} a \textit{Order by}.

\item \textbf{Half-Streamed:} reprezentuje upravené vykonávání. 
Tento mód v paralelním vykonání ukládá výsledky nejdříve lokálně a po dokončení dojde ke slévání.

\item \textbf{Streamed:} reprezentuje upravené vykonávání. 
Tento mód v paralelním vykonání zpracovává výsledky globálně.
\end{itemize}

Jednovláknová řešení části \textit{Order by} módů \textbf{Half-Streamed} a \textbf{Streamed} se shodují.
Rozdíl je tedy jen v paralelních řešeních.
Jednovláknová řešení části \textit{Group by} módů \textbf{Half-Streamed} a \textbf{Streamed} se neshodují.
Rozdíl je tedy v paralelních i jednovláknových řešeních.

\section{Rozložení aplikace} \label{impl.appsolution}

Při implementaci aplikace jsme vycházeli z analýzy a návrhu předchozí kapitoly.
Aplikaci jsme vyvíjeli jako projekt konzolové aplikace pro .NET Framework 4.8 v prostředí Visual Studia 2019.
Samotný projekt je rozdělený na tři hlavní řešení:

\begin{itemize}

\item Řešení \texttt{QueryEngine} představující implementaci dotazovacího enginu.
\item Řešení \texttt{HPCsharp} \citep{hpcsharp} představující doprovodnou knihovnu, která poskytuje sadu mnoha výkonných jednovláknových i paralelních algoritmů.
Z knihovny jsme využili pouze určité algoritmy při implementaci části \textit{Order by}.
Knihovna spadá pod licenci Apache License 2.0.
\item Řešení \texttt{Benchmark}, které jsme implementovali pro porovnání upraveného a původního způsobu zpracování dotazu. 

\end{itemize}

V průběhu celé kapitoly se budeme věnovat pouze řešení \texttt{QueryEngine}, protože obsahuje hlavní část práce.
Řešení \texttt{Benchmark} je popsáno podrobněji v kapitole Experiment \ref{expr}., ve které se věnujeme porovnání implementovaných řešení.
Samotná implementace algoritmů lze nalézt v odkazu citovaného zdroje. 
Nyní popíšeme podrobněji rozložení řešení \texttt{QueryEngine}.

\subsection{Rozložení řešení QueryEngine}

Řešení \texttt{QueryEngine} neobsahuje další podřešení, ale pouze adresáře.
Níže popsané adresáře rozdělují engine na hlavní části výstavby z kapitoly analýzy.
Hlavní adresáře jsou:

\begin{itemize}

\item \textit{DB}: obsahuje objekty grafových elementů, struktury reprezentace grafu, objekty vlastností elementů a objekty k načítání grafových dat. 

\item \textit{DataFiles}: obsahuje datové soubory, které se při překladu projektu ve Visual Studiu překopírují k binárním souborům.

\item \textit{Parser}: obsahuje metody načítání uživatelského dotazu, definované tokeny, objekty syntaktického stromu a objekty k procházení daného stromu.

\item \textit{Query}: obsahuje objekty zpracování dotazu. 
Obecně představuje část, která vykonává \textit{Group by} a \textit{Order by} po dokončení prohledávání grafu. 

\item \textit{QueryStreamed}: obsahuje objekty upraveného zpracování dotazu. 
Obecně představuje část, která vykonává \textit{Group by} a \textit{Order by} v průběhu prohledávání grafu.
Adresář částečně kopíruje strukturu adresáře \textit{Query}.
Pokud jsou názvy složek stejné znamená to, že objekty ve složce rozšiřují právě objekty ze stejnojmenné složky uvnitř \textit{Query}. 
Obsahuje řešení pro \textbf{Streamed} i \textbf{Half-Streamed} módy.

\end{itemize}

%%Podrobnější popis adresářové struktury:
%%
%%\clearpage
%%\dirtree{%
%%.1 /.
%%.2 DB.
%%.3 Creator \DTcomment{Definuje api čtení vstupních souborů.}. 
%%.3 GraphElement \DTcomment{Definuje objekty elementů grafu.}.
%%.3 Processor \DTcomment{Definuje tvorbu objektů grafu.}.
%%.3 Table \DTcomment{Definuje typ v Property grafu.}.
%%.4 Property \DTcomment{Definuje vlastnosti typu v Property grafu.}.
%%.2 DataFiles. 
%%.2 Parser.
%%.3 ParsedPattern \DTcomment{Definuje objekty syntaktického stromu posloupností části \textit{Match}.}.
%%.3 Parser.
%%.4 ParseTree \DTcomment{Definuje objekty použité k tvorbě syntaktického stromu.}.
%%.5 Visitor \DTcomment{Definuje objekty procházení syntaktického stromu.}.
%%.4 ParserComponent \DTcomment{Definuje metody syntaktické analýzy tokenů dotazu.}.
%%.3 Tokenizer \DTcomment{Definuje tokeny a způsob tokenizace vstupu.}.
%%.2 Query.
%%.3 Expression \DTcomment{Obsahuje logiku výrazů.}.
%%.4 ExpressionComparer \DTcomment{Definuje porovnávání hodnot dvou výrazů.}.
%%.4 Reference \DTcomment{Definuje výrazy odkazů na proměnné, jejich vlastnosti a agregační funkce.}.
%%.3 GroupBy \DTcomment{Definuje objekty důležité k vykonání Group by.}.
%%.4 Aggregate.
%%.5 AggregateFunction \DTcomment{Definuje logiku agregačních funkcí.}.
%%.4 AggregateInternalResults \DTcomment{Definuje úložiště hodnot agregačních funkcí.}.
%%.4 MultiGroupGroupBy \DTcomment{Definuje řešení, pokud je zadano Group by.}.
%%.5 EqualityComparer \DTcomment{Definuje porovnání záznamů v hašovací tabulce.}.
%%.5 Hasher \DTcomment{Definuje hašování výrazů.}.
%%.5 ParallelSolutions \DTcomment{Definuje paralelní vykonání Group by.}.
%%.6 GlobalGroupBy.
%%.6 LocalGroupByLocalTwoWayMerge.
%%.6 TwoStepGroupBy.
%%.5 ReferenceSingleThreadSolutions \DTcomment{Definuje jednovláknové vykonání Group by.}.
%%.4 SingleGroupGroupBy \DTcomment{Definuje řešení, pokud není zadáno Group by.}.
%%.3 Match \DTcomment{Definuje objekty důležité k vykonání \textit{Match}.}.
%%.4 DFSMatch \DTcomment{Definuje obejekty DFS prohledávání grafu.}.
%%.5 BaseMatch \DTcomment{Definuje objekty vzoru.}.
%%.5 Matcher \DTcomment{Definuje objekty algoritmu prohledávání grafu .}.
%%.6 DFSParallelPatternMatcher \DTcomment{Definuje paralelní prohledávání grafu.}.
%%.6 DFSPatternMatcher \DTcomment{Definuje jednovláknové prohledávání grafu.}.
%%.5 Pattern \DTcomment{Definuje api vzoru.}.
%%.4 MatchInternalResults \DTcomment{Definuje interní struktury \textit{Match} pro ukládání výsledků prohledávání grafu.}.
%%.3 OrderBy \DTcomment{Definuje objekty důležité k vykonání Order by.}.
%%.4 Comparer \DTcomment{Definuje porovnání řádků tabulky pomocí proxy třídy.}.
%%.5 Wrappers \DTcomment{Definuje porovnání řádků tabulky pomocí indexu.}.
%%.4 Sorter \DTcomment{Definuje algoritmy třídění.}.
%%.6 TableSorter \DTcomment{Definuje algoritmy třídění tabulky.}.
%%.3 Results \DTcomment{Definuje tabulky výsledků.}.
%%.4 GroupByResults \DTcomment{Definuje formát tabulky výsledků Group by.}.
%%.4 TableResults \DTcomment{Definuje formát tabulky pouze pro elementy grafu.}.
%%.3 Select \DTcomment{Definuje objekty důležité k vykonání \textit{Select}.}.
%%.4 ExpressionToStringWrapper  \DTcomment{Definuje objekt převodu hodnoty výrazu na řetězec.}.
%%.4 Formater  \DTcomment{Definuje formát výstupu.}.
%%.4 Printer  \DTcomment{Definuje kam se má výstup vypsat.}.
%%.2 QueryStreamed.
%%.3 GroupBy  \DTcomment{Definuje objekty důležité pro upravené vykonání Group by.}.
%%.4 AggregateInternalResults  \DTcomment{Definuje upravené úložište agregačních funkcí pro Streamed mód.}.
%%.4 MultiGroupGroupBy  \DTcomment{Definuje Streamed a Half-Streamed řešení, pokud je zadáno Group by.}.
%%.5 BucketKeyValueFactory  \DTcomment{Definuje výrobu klíče hašovací tabulky pro Streamed mód.}.
%%.5 Comparers  \DTcomment{Definuje porovnání využité Half-Streamed a Streamed módem.}.
%%.4 SingleGroupGroupBy \DTcomment{Definuje Streamed a Half-Streamed vykonání, pokud není zadáno Group by.}.
%%.3 Match  \DTcomment{Definuje objekty důležité pro upravené vykonání Group by.}.
%%.4 DFSMatch  \DTcomment{Definuje pozměněná api pro předávání výsledků částem v průběhu prohledávání grafu.}.
%%.5 Matcher.
%%.6 DFSParallelPatternMatcher.
%%.6 DFSPatternMatcher.
%%.3 OrderBy \DTcomment{Definuje objekty důležité pro upravené vykonání Order by.}.
%%.4 ABTree \DTcomment{Definuje použité vyhledávací stromy.}.
%%.4 Sorter \DTcomment{Definuje Half-Streamed a Streamed vykonání pomocí vyhledávacích stromů.}.
%%.5 ABTreeSorterHalfStreamed.
%%.5 ABTreeSorterStreamed.
%%.6 Comparer.
%%.7 Wrapper \DTcomment{Definuje porovnání akumulovaných skupin pomocí proxy třídy.}.
%%.4 TypeRangeHasher \DTcomment{Obsahuje objekty, které rozdělují rozsah typu na přihrádky.}.
%%.3 Results \DTcomment{Definuje upravené fotmáty tabulek výsledků.}.
%%.4 GroupByResults.
%%.4 TableResults.
%%.5 ABTree \DTcomment{Formát tabulky pro řešení s normálním (a, b)-stromem.}.
%%.5 ABTreeAccum \DTcomment{Formát tabulky pro řešení s (a, b)-stromem, který akumuluje shodné řádky.}.
%%}

\section{Programátorská dokumentace}

V této sekci popíšeme postupně klíčové objekty, položky a způsoby vypracování aplikace.  

\subsection{Reprezentace grafu}

V této sekci popíšeme implementaci hlavních objektů, které jsme použili k reprezentaci grafových dat.
Při implementaci jsme postupovali dle návrhu z sekce analýzy \ref{anal.grafrep}.

\subsubsection{Třída Element}

Všechny druhy elementů v grafu (vrchol a hrana) dědí od abstraktní třídy \texttt{Element}.
Představuje obecný základ všech elementů.
Hlavní vlastnosti jsou:
\begin{itemize}
\item \texttt{int ID} je unikátní identifikátor elementu. Definuje jej uživatel ve vstupním souboru. Není to vlastnost v Property grafu.
\item \texttt{Table Table} odkaz na typ v Property grafu.
\item \texttt{int PositionInList} pozice v \texttt{List<T>}, kde \texttt{T} je potomek třídy \texttt{Element}, protože každý potomek je obsažen ve vlastním poli.
Určili jsme v analýze, kvůli jednoduché možnosti iterace elementů.
Pole jsou pak obsažená v třídě \texttt{Graph}.
\end{itemize}

Potomek abstraktní třídy je třída \texttt{Vertex} (vrchol) a abstraktní třída \texttt{Edge} (hrana).
\texttt{Edge} přidává novou položku \texttt{Vertex EndVertex}, která odkazuje na koncový vrchol hrany.
Z dané třídy vznikají konkrétní potomci \texttt{InEdge} a \texttt{OutEdge}.
Hrany jsou orientované a spojují dva vrcholy.
Mějme hranu z vrcholu x do y.
Položka \texttt{EndVertex} pro \texttt{OutEdge} zde odkazuje na vrchol y.
Pro \texttt{InEdge} to je x.
Tedy pro každou definovanou hranu v grafu existují obě instance tříd. 
Instance sdílejí \texttt{ID}, ale záznam v \texttt{Table} je pouze jeden, tedy sdílejí i hodnoty vlastností. 
\texttt{Vertex} přidává položky dvou dvojic indexů, o kterých jsme mluvili v analýze.
První dvojice je \texttt{int OutEdgesStartPosition} a \texttt{int OutEdgesEndPosition}, které označují rozsah hran v poli \texttt{OutEdge} náležících vrcholu.
Ekvivalentně pro typ \texttt{InEdge}.
Celkově tedy třída \texttt{Graph} bude obsahovat pole \texttt{List<T>} pro každého neabstraktního potomka třídy \texttt{Element}.

\subsubsection{Třída Table}

Třída \texttt{Table} určuje typ štítku.
Hlavní vlastnosti jsou:
\begin{itemize}
\item Položka \texttt{string IRI} je název typu.
\item Položka \texttt{Dictionary<int, int> IDs}, kde klíčem je \texttt{ID} elementu a hodnota je pozice hodnot vlastností ve struktuře, která je obsahuje (tj. třídě \texttt{Property}).
\item Položka \texttt{Dictionary<int, Property> Properties}, kde klíč je \texttt{ID} vlastnosti a hodnota je třída reprezentující vlastnost.
\item \texttt{bool TryGetPropertyValue<T>(int id,int propID, out T retValue)}\\* 
je metoda, která se pokusí získat hodnotu vlastnosti \texttt{propID} pro daný element s daným \texttt{id}.
Hodnota se vrací v \texttt{retValue}. Úspěšně dokončená vrací \texttt{true}, jinak \texttt{false}.
Pro získání hodnoty vlastnosti tedy musíme znát její typ.
\end{itemize}

\subsubsection{Třída Property}

Samotné vlastnosti jsou reprezentovány abstraktní třídou \texttt{Property}, která má svůj název \texttt{string IRI}.
Z třídy vznikají abstraktní generické třídy \texttt{Property<T>}, kde \texttt{T} je typ hodnot vlastnosti.
Třída obsahuje pole hodnot \texttt{List<T> propHolder}.
Z třídy pak vznikají konkrétní třídy:
\begin{itemize}
\item \texttt{StringProperty}, kde \texttt{T} je \texttt{string}. Odpovídá typu \texttt{string} ve vstupním JSON schématu.
\item \texttt{IntProperty}, kde \texttt{T} je \texttt{Int32}. Odpovídá typu \texttt{integer} ve vstupním JSON schématu.
\end{itemize}
V analýze jsme se rozhodli implementovat pouze tyto dva typy. 
Což znamená, že v celém enginu bude možno pracovat \textbf{pouze s těmito dvěma typy}.
Tyto třídy mají metodu \texttt{void ParsePropFromStringToList(string strProp)}, která se používá při načítání hodnot ze vstupních souborů.
Převede hodnotu \texttt{strProp} na svůj typ \texttt{T} a uloží na konec pole \texttt{propHolder}.
Každý element v \texttt{Table} má svou hodnotu vlastnosti v poli na pozici \texttt{IDs[Element.ID]}.
Třídy vlastností se vytvářejí pomocí třídy \texttt{PropertyFactory}, která implementuje Factory metodu \citep[str. 107]{patterns} \texttt{Property CreateProperty(string token, string name)}.
Kde \texttt{token} je typ vlastnosti a \texttt{name} je její název.

\subsubsection{Třída Graph}

Třída \texttt{Graph} pak reprezentuje celý graf.
Můžeme se dívat na ni spíše jako na objekt držící data grafu, a ne objekt se složitou logikou.
Načítá grafová data během inicializace.
Zároveň dělá kontrolu načtených vlastností a jejich typů během načítání.
Obsahuje pole všech typů elementů. Tedy \texttt{List<Vertex>}, \texttt{List<InEdge>} a \texttt{List<OutEdge>}.
Obsahuje dále:
\begin{itemize}
\item \texttt{Dictionary<string, Table> nodeTables} všechny typy vrcholů Property grafu. To samé pro hrany v položce \texttt{edgeTables}.
\item \texttt{Dictionary<string, Tuple<int, Type> > labels} mapa, kde klíč je název vlastnosti a \texttt{int} je její přiřazený unikátní identifikátor, abychom nemuseli v enginu používat řetězce jako \texttt{ID} vlastnosti.
\texttt{Type} je pak typ vlastnosti, slouží pro kontrolu, protože dvě stejnojmenné vlastnosti musí mít stejný typ. 
\end{itemize}


\subsection{Čtení vstupních souborů} \label{impl.vstup}

Máme implementovaný graf a nyní jej potřebujeme načíst.
V této sekci popíšeme implementaci načítaní vstupních grafových dat.
Budeme vycházet z kapitoly analýzy sekce \ref{anal.vstup}.

\subsubsection{Vstupní soubory}

Rozhodli jsme se použít totožný vstupní formát dat jako při analýze.
Při spuštění program očekává čtyři soubory ve složce \textit{DataFiles}.
Dva soubory se zmiňovaným JSON formátem \textit{EdgeTypes.txt} (schéma hran) a \textit{NodeTypes.txt} (schéma vrcholů), které definují typy Property grafu a jejich vlastnosti.
Další dva soubory \textit{Edge.txt} (data hran) a \textit{Nodes.txt} (data vrcholů) obsahují samotná data s mezerami jako oddělovače.
Soubory musí mít přesně stejné názvy.
Jediná úprava formátu je ta, že hrany v datovém souboru musí být seřazeny podle \texttt{ID} počátečního vrcholu hrany tak, jak jsou vrcholy seřazeny v jejich datovém souboru.
To znamená, pokud máme v souboru vrcholů za sebou vrcholy s \texttt{ID} 1, 2 a 3, tak soubor hran musí nejdříve obsahovat hrany začínající vrcholem s \texttt{ID} 1, pak s \texttt{2} apod.
Důvodem je zjednodušení procesu načítání.

\subsubsection{Načítání vstupních souborů}

Načítání je implementováno následovně.
\texttt{interface Creator<T>} s metodou \texttt{T Create()} je rozhraní pro tvorbu objektů \texttt{T}.
Rozhraní bude implementovat třída \texttt{CreatorFromFile<T>}, která symbolizuje tvorbu objektu \texttt{T} postupným čtením souboru.
Třída očekává při inicializaci rozhraní \texttt{IReader} čtoucí vstupní soubor metodou \texttt{string Read()}, která přečte vždy určitý úsek souboru.
Dále rozhraní \texttt{IProcessor} vytvářející iterativně \texttt{T} na základě poskytnutých částí souboru.
Protože text je čtený po částech, tak \texttt{IProcessor} implementuje návrhový vzor State \citep[str. 305]{patterns}.
V našem případě nejdříve zpracujeme soubory schémat pomocí třídy \texttt{TableDictProcessor}, která vytváří třídy \texttt{Table}.
Následně čtením datového souboru \textit{Nodes.txt} vytvoříme třídou \texttt{VerticesListProcessor} pole vrcholů.
A posledně čtením datového souboru \textit{Edges.txt} vytvoříme dva pole \texttt{InEdge} a \texttt{OutEdge} třídou \texttt{EdgeListsProcessor}. 
Rozhraní \texttt{IProcessor} implementují všechny tyto třídy.
Samotné čtení souborů je vyvoláno při inicializaci třídy \texttt{Graph}.

\subsection{Načítání uživatelského dotazu} \label{impl.parsing}

V této sekci popíšeme implementaci načítání uživatelského dotazu.
Při načítání dotazu jsme vycházeli z sekce analýzy \ref{anal.parsing}.
Nejdříve dojde k tokenizaci a následně vytváření syntaktického stromu.

\subsubsection{Třída Tokenizer}

V prvním kroku dojde k tokenizaci uživatelského dotazu třídou \texttt{Tokenizer}.
Uživatel zadá aplikaci svůj dotaz a třída provede tokenizaci.
Výstupem tokenizace je pole \texttt{List<Token>}, které obsahuje všechny nalezené tokeny.
Tokenem zde myslíme \texttt{struct Token}, který obsahuje dvě položky.
První je \texttt{TokenType type}, což je typ tokenu.
Druhá je \texttt{string strValue}, která obsahuje hodnotu tokenu, pokud se jedná o token \texttt{Identifier}.
Tomu odpovídá například token názvu proměnné.
Pole tokenů se předá statické třídě \texttt{Parser}.

\subsubsection{Třída Parser}

Třída postupně z tokenů vytváří syntaktické stromy každé hlavní části dotazu (\textit{Match}, \textit{Select}, \textit{Order by} a \textit{Group by}).
Syntaktická analýza se vyvolá veřejnou metodou \texttt{Parse(List<Token> tokens)} a probíhá po částech.
Každá hlavní část dotazu má svou separátní metodu.
Například \texttt{ParseMatch(ref int position, List<Token> tokens)} parsuje část \textit{Match}. 
Během syntaktické analýzy tokenů se rekurzivně volají další metody.
Při rekurzi se používá parametr \texttt{position}, který udržuje pozici aktuálně zpracovávaného tokenu.

Syntaktické stromy jsou tvořeny potomky abstraktní třídy \texttt{Node}, která implementuje návrhový vzor Visitor \citep[str. 331]{patterns}, tj. definuje metodu \texttt{Accept<T>(...)}.
Rozhraní \texttt{IVisitor<T>} implementuje druhou část vzoru, tj. metodu \texttt{Visit(...)}, kde vstupem ja každý neabstraktní potomek třídy \texttt{Node}.
Každá část dotazu má svůj objekt implementující \texttt{IVisitor<T>}, například části \textit{Match} přináleží objekt \texttt{MatchVisitor}.
Parametr \texttt{T} je zde návratová hodnota procházení syntaktického stromu.
Výstupem třídy \texttt{Parser} je množina všech vzniklých syntaktických stromů.
Samotná tokenizace a syntaktická analýza se provádí při inicializaci třídy \texttt{Query}.
Procházení syntaktických stromů je rovněž prováděno při inicializaci dané třídy.

\subsection{Reprezentace dotazu}
Celý dotaz jsme reprezentovali třídou \texttt{Query}.
Exekuční plán a samotné zpracování pak bude odpovídat popisu z sekce analýzy \ref{anal.vykonanidotazu}.

\subsubsection{Třída Query}

Třída reprezentuje celý dotaz.
Obsahuje všechny struktury, které se využívají pro vykonání dotazu.
Objekt je používán uživatelem.
Poskytuje statické veřejné metody \texttt{Query Create(...)} a \texttt{void Compute()}.
Metoda \texttt{void Compute()} spustí vykonání dotazu.
Metoda \texttt{Query Create(...)} vytváří dotaz.
Daná metoda dostává množství argumentů, vypíšeme ty hlavní:
\begin{itemize}
\item \texttt{string/TextReader inputQuery}: definuje dotaz uživatele, který se má vykonat. \texttt{string} zde reprezentuje vstup jako řetězec. \texttt{TextReader} představuje vstup z konzole.
\item \texttt{QueryMode mode}: definuje mód vykonávání, který se má provádět (sekce \ref{impl.engine.modes}).
\item \texttt{Graph graph}: definuje graf, nad kterým se má dotaz provést.
\item \texttt{ThreadCount threadCount}: definuje počet využitých vláken v paralelním zpracování.
\item \texttt{GrouperAlias grouperAlias}: definuje řešení, které se má použít při vykonávání \textit{Group by}.
\item \texttt{SorterAlias sorterAlias}: definuje řešení, které se má použít při vykonávání \textit{Order by}.
\end{itemize}
Při zavolání metody dojde k tokenizaci \texttt{inputQuery} a kontrole všech argumentů metodou \texttt{CheckArgs}.
Zkontrolované argumenty a pole \texttt{List<Token>} se předají privátnímu konstruktoru třídy \texttt{Query}.
Upravené módy sdílí konstruktor. Mód \textbf{Normal} má separátní konstruktor.
Uvnitř obou konstruktorů dochází k syntaktické analýze pole tokenů třídou \texttt{Parser}.
Výstupem jsou stromové struktury hlavních částí dotazu, které jsou dále použity k inicializaci privátních položek a exekučního plánu:
\begin{itemize}
\item \texttt{VariableMap variableMap} je seznam proměnných vyskytujících se v dotazu. Seznam obsahuje jejich přidělený identifikátor a typ, pokud byl definován.
\item \texttt{QueryObject query} je exekuční plán. Obsahuje řetězec objektů, které postupně vykonávají dotaz.
\item \texttt{QueryExecutionHelper qEhelper} obsahuje informace o způsobu vykonání dotazu. 
\item \texttt{QueryExpressionInfo exprInfo} obsahuje všechny výrazy (expressions) v dotazu.
\end{itemize}
V moment volání metody \texttt{Compute()} dojde k vyvolání metody \texttt{Compute(...)} na položce \texttt{query}.
Tímto se spustí vykonávání dotazu.

\subsubsection{Třída QueryObject}

Jedná se o abstraktní třídu.
Každá hlavní část dotazu je reprezentována potomkem dané třídy (\texttt{MatchObject}, \texttt{SelectObject}, ...).
Třída definuje rozhraní exekučního plánu.
Obsahuje:
\begin{itemize}
\item Položku \texttt{QueryObject next}, která propojuje objekt s dalším objektem.
\item Metodu \texttt{void Compute(out ITableResults r,} \texttt{out GroupByResults g)}, která rekurzivné volá stejnou metodu na dalším objektu v \texttt{next}.
Každý potomek třídy si implementuje vlastní logiku zpracování této metody.
Všimněme si, že tato metoda definuje rozhraní pro předávání výsledků zpracování.
\texttt{ITableResults} definuje obecné rozhraní tabulky výsledků prohledávání, pokud není zadáno \textit{Group by}.
\texttt{GroupByResults} definuje formát výsledků \textit{Group by}.
\item Metodu \texttt{void AddToEnd(QueryObject queryObject)}, která připojí \\*poskytnutý objekt na konec řetězce.
\end{itemize}
Konkrétní potomci třídy jsou vytvářeny v konstruktoru třídy \texttt{Query}.
Navíc každý potomek očekává v konstruktoru syntaktický strom.
Uvnitř konstruktoru dojde k vytvoření adekvátního \texttt{IVisitor<T>} objektu.
Návratová hodnota \texttt{T} se využije ke konstrukci privátních objektů pro vykonání dotazu.

\subsection{Match} \label{impl.match}

V této sekci popíšeme implementaci části \textit{Match}.
Prvně popíšeme konstrukci vzoru a následně objekty algoritmu prohledávání.
Budeme vycházet z sekce analýzy \ref{anal.match}.

\subsubsection{Třída MatchObject}

Třída \texttt{MatchObject} reprezentuje \textit{Match} část dotazu.
Je potomkem abstraktní třídy \texttt{MatchObjectBase}, která dědí z \texttt{QueryObject}.
Obecně třída \texttt{MatchObject} obsahuje odkaz na tabulku výsledků prohledávání \texttt{MatchFixedResults} a odkaz na objekt DFS algoritmu prohledávání \texttt{DFSParallelPatternMatcher}.
V konstruktoru třídy se vytváří vzor a objekt prohledávání.
Objekt prohledávání obdrží vzor a tabulku pro ukládání výsledků.
Třída dědí z \texttt{MatchObjectBase}, protože objekt části \textit{Match} upraveného zpracování používá stejnou metodu ke kontrole vzoru uživatele (metoda \texttt{ParsedPatternCorrectness}).
Metoda kontroluje uživatelem zadaný vzor, jestli splňuje podmínky jazyka PGQL. 
Metoda očekává na vstupu pole tříd, které je výstupem procházení syntaktické stromové struktury objektem \texttt{MatchVisitor}. 

\subsubsection{Třída ParsedPattern}

\texttt{MatchVisitor} vytváří procházením stromu pole tříd \texttt{List<ParsedPattern>}.
Třída \texttt{ParsedPattern} reprezentuje jednu vyhledávací posloupnost \textit{Match} části (např. \texttt{(x) -> (y)}).
V poli je tolik tříd, kolik je v dotazu posloupností oddělených čárkou.
Třída obsahuje:
\begin{itemize}
\item Pole abstraktních tříd \texttt{List<ParsedPatternNode> pattern}.
Abstraktní \\*třída reprezentuje jeden hledaný element v posloupnosti, tj. hrana  (\texttt{-[e]>}) nebo vrchol (\texttt{(x)}).
Obsahuje položky \texttt{string Name}, pokud je element označen proměnnou (např. vrchol \texttt{(x)}), a \texttt{Table Table}, pokud je definován typ elementu (např. vrchol \texttt{(:Type)}).
Potomci specifikují konkrétní případy vrcholů a hran. 
Například pro posloupnost výše \texttt{(x) -> (y)} bude pole obsahovat tři třídy.
\texttt{pattern[0]} je třída vrcholu \texttt{x}, \texttt{pattern[1]} je třída \texttt{OutEdge} hrany a \texttt{pattern[2]} je třída vrcholu \texttt{y}.

\item Položku \texttt{string splitBy}, která označuje jméno proměnné, podle které posloupnost budeme dělit na dvě posloupnosti v průběhu vytváření objektu vzoru.
Výsledkem dělení budou tedy dvě třídy \texttt{ParsedPattern}.
Část před proměnnou, podle které dělíme, bude tvořit posloupnost převrácenou.
To znamená, pokud máme posloupnost tříd \texttt{ParsedPatternNode} \texttt{(x) -> (y) -> (z)} a dělíme podle \texttt{(y)}, pak výsledkem dělení jsou posloupnosti 
\texttt{(y) <- (x)} a \texttt{(y) -> (z)}.

\item Metodu\\* \texttt{bool TryFindEqualVariable(ParsedPattern p, out string n)}, která \\*vrátí název první sdílené proměnné s posloupností \texttt{p}, pokud nějaká existuje.
Pokud existuje, metoda vrací \texttt{true} a název v \texttt{n}.

\item Metodu \texttt{void TrySplitParsedPattern()}, která zkusí provést rozdělení posloupnosti.
Rozdělení se nemusí provést, pokud je rozdělováno podle první položky \texttt{List<ParsedPatternNode>}. 
Pokud je rozdělováno podle poslední, posloupnost se pouze převrátí.

\end{itemize}
Z daného formátu se během vytváření struktur \textit{Match} části vytvoří finální hledaný vzor \texttt{DFSPattern} s pomocí zmíněný metod a položek.

\subsubsection{Třída DFSPattern}

Třída reprezentuje hledaný vzor (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{Pattern}).
Konstruktor dostane pole \texttt{ParsedPattern}.
V analýze jsme řekli, že se z posloupností vytvoří souvislé komponenty.
Aplikováním výše zmíněných metod nalezneme sdílené proměnné.
Pole, která sdílejí proměnnou, seskupíme k sobě a samotné posloupnosti rozdělíme pomocí položky \texttt{splitBy}.
Výsledkem bude pole posloupností a souvislé komponenty v něm budou obsaženy postupně za sebou.
Příklad seskupení a rozdělení:
\begin{code}
Původní List<ParsedPattern> a uvnitř List<ParsedPatternNode>:
[[(x), ->, (z)], [(r), ->, (q)], [(y), ->, (x), ->, (w)]]
Pole po zpracování:
[[(x), ->, (z)], [(x), <-, (y)], [(x), ->, (w)], [(r), ->, (q)]]
\end{code}
Zde vidíme, že první tři posloupnosti po zpracování tvoří souvislou komponentu, protože sdílejí proměnnou \texttt{x}, ale původně nebyli v poli za sebou.
Nulté a druhé pole sdílejí proměnnou \texttt{x}, podle které jsme druhou posloupnost dělili.
V průběhu prohledávání grafu budeme vždy iterovat po daných posloupnostech.
V moment nalezení vhodného elementu se posuneme na další prvek posloupnosti (doprava) nebo na novou posloupnost.
To symbolizuje DFS krok zanoření.
Opačně se posouváme doleva a zkoušíme ještě neprohledané elementy grafu.
Díky rozdělení můžeme při přesouvání na začátek další posloupnosti vždy navázat již nalezenou proměnnou, pokud existuje a jedná o součást aktuální komponenty.
Z pole posloupnosti nyní vytvoříme pole \texttt{DFSBaseMatch[][] patterns}.
\texttt{patterns[i]} znamená přístup k \textit{i}-té posloupnosti a \texttt{patterns[i][j]} přístup k \textit{j}-té položce  \textit{i}-té posloupnosti. 

Vzor kromě \texttt{patterns} obsahuje pole \texttt{Element[] scope}.
Pole obsahuje každou proměnnou prohledávání právě jednou. 
Pokud ve vzoru není žádná proměnná, tak je pole vždy prázdné.
Každá proměnná má svou pozici.
Tyto pozice budeme chápat jako \texttt{ID} proměnných v celém dotazu.
Toto pořadí je uchováváno v třídě \texttt{QueryVariableMap}.
V moment nalezení vhodného elementu proměnné se element uloží do daného pole na pozici proměnné.
V moment vynořování z DFS se element z pozice smaže.
Položka se používá ke kopírování výsledků do tabulky nebo k dalšímu zpracování.

Vzor dále implementuje rozhraní \texttt{IDFSPattern} spolu s \texttt{IPattern}, které slouží k posouvání po posloupnosti.
Mají množství metod, ale vypíšeme pouze hlavní:
\begin{itemize}
\item Položka \texttt{int CurrentPatternIndex} je index aktuální posloupnosti procházení.
\texttt{patterns[CurrentPatternIndex]} vrátí aktuální posloupnost.

\item Položka \texttt{int CurrentMatchNode} je aktuální objekt \texttt{DFSBaseMatch} v posloupnosti.
\texttt{patterns[CurrentPatternIndex][CurrentMatchNode]} je aktuální objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{void PrepareNextSubPattern()} připraví k procházení následující posloupnost.
\item Metoda \texttt{void PreparePreviousSubPattern()} připraví k procházení předchozí posloupnost.
\item Metoda \texttt{void PrepareNextNode()} připraví k procházení následující objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{void PreparePreviousNode()} připraví k procházení předchozí objekt \texttt{DFSBaseMatch}.
\item Metoda \texttt{Element[] GetMatchedVariables()} vrátí \texttt{scope} vzoru.
\item Metoda \texttt{bool Apply(Element[] e)} slouží ke zjištění, zda držený element je použitelný pro aktuální pozici ve vzoru.
Vyvolá stejnojmennou funkci na třídě \texttt{DFSBaseMatch}.
\end{itemize}
Nyní popíšeme třídu vytvářející pole posloupností.

\subsubsection{Třída DFSBaseMatch}

\texttt{DFSBaseMatch} je abstraktní třída, reprezentující jeden element procházení grafu.
Třída obsahuje:
\begin{itemize}
\item Položku \texttt{bool isAnonnymous} která říká, jestli se jedná o proměnnou.
\item Položku \texttt{bool isFirstAppearance} která říká, pokud se jedná o proměnnou, jestli už je to její první nález.
\item Položku \texttt{int positionOfRepeatedField} která říká, pokud to není první nález proměnné, tak kde v \texttt{scope} se nachází. 
\item Metodu \texttt{bool Apply(Element element, Element[] map)}, která ověřuje jestli element \texttt{element} se dá použit v aktuálním kroku prohledávání.
\texttt{map} je pak \texttt{scope} vzoru, kde se případně ověří rovnost elementů opakující se proměnné. Při úspěchu vrací \texttt{true}.
\end{itemize}
Potomci pak specifikují, jestli se jedná o \texttt{Vertex} (vrchol), \texttt{InEdge} (hrana vedoucí do vrcholu), \texttt{OutEdge} (hrana vedoucí z vrcholu) nebo \texttt{AnyEdge} (jakýkoliv druh hrany).
Ještě než popíšeme struktury algoritmu prohledávání, tak popíšeme struktury pro ukládání výsledků vláken v průběhu prohledávání grafu.

\subsubsection{Třída MatchFixedResultsInternal} \label{impl.match.table}

Máme implementován vzor a metody k procházení vzoru.
Nyní popíšeme implementaci ukládání výsledků prohledávání.
Třída obsahuje lokální tabulku výsledků vlákna při prohledávání grafu (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{Výsledky}). 
Každé vlákno má odkaz na vlastní třídu v průběhu prohledávání grafu.
Za finální výsledek prohledávání se považují hodnoty v poli \texttt{scope}.
Sloupečky zde tedy odpovídají unikáním proměnným v grafu.
Řádek je pak kopie daného pole.
Ukládáme pouze elementy grafu.
Uvnitř je:
\begin{itemize}
\item Položka \texttt{int ColumnCount}, která udává počet sloupečků tabulky. 
\item Položka \texttt{int FixedArraySize}, která udává velikost bloků uvnitř tabulky.
\item Položka \texttt{List<Element[][]> ResTable} je tabulka výsledků. 
Je složená z bloků \texttt{Element[][FixedArraySize] block} konstantní velikosti.
\texttt{block[i]} přistupuje k \textit{i}-tému sloupečku a \texttt{block[i][j]} přistupuje k \textit{j}-té pozici \textit{i}-tého sloupečku.
\item Položka \texttt{Element[][FixedArraySize] LastBlock} je odkaz na poslední nezaplněný blok.
\item Položka \texttt{int CurrentPosition} je odkaz na první volný index v posledním bloku.
\item Metoda \texttt{void AddRow(Element[] row)} přidá nový výsledek do tabulky.
Pokud je poslední blok zaplněn, vytvoří se nový.
Při vytváření nového bloku nemusí docházet k překopírovávání výsledků prohledávání, protože pole \texttt{ResTable} drží odkazy na zmíněné bloky.
Rozšířením pak překopíruje pouze odkazy na pole.
Očekává se, že \texttt{row} je položka \texttt{scope} vzoru. 

\end{itemize}

\subsubsection{Třída MatchFixedResults}

Třída obsahuje lokální tabulky všech vláken v položce \texttt{matcherResults}.
Takto budeme moct přistoupit k lokálním výsledkům po dokončení prohledávání grafu.
Třída zároveň poskytuje rozhraní pro slévání sloupečků tabulek vláken v metodě \texttt{void MergeColumn(int columnIndex)}, která slévá jeden sloupeček.
Výsledky jsou slévány do položky \texttt{List<Element[]>[] FinalMerged}.

\subsubsection{Třída DFSPatternMatcherBase}

Implementovali jsme vzor a ukládání výsledků.
Nyní popíšeme implementaci algoritmu procházení (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{Matcher}).
Abstraktní třída reprezentuje základní jednovláknový algoritmus DFS prohledávání grafu.
Prohledání jsme implementovali přesně podle analýzy.
Samotný algoritmus nebudeme popisovat, ale popíšeme jen základní položky.
Třída v konstruktoru očekává vzor \texttt{DFSPattern} a graf \texttt{Graph}.
Obsahuje dva indexy \texttt{int startVerticesIndex} a \texttt{int startVerticesEndIndex}.
Dva indexy určují rozsah vrcholů z pole vrcholů \texttt{List<Vertex>}, ze kterých se bude spouštět prohledávání.
Dané položky jsou inicializovány na celý rozsah pole, což odpovídá jednovláknovému zpracování.
Třída má rozhraní \texttt{void SetStartingVerticesIndeces( int start, int end)} nastavující dané indexy rozsahu.
Daná metoda se používá v paralelním zpracování v momentě, kdy je přidělováno malé množství vrcholů z grafu k prohledání.
Metodou \texttt{void Search()} se spustí prohledávání grafu.
Prohledávání prochází všechny vrcholy v definovaném rozsahu a pak se ukončí.
V tento moment lze nastavit zmíněnou metodou další rozsah a opět spustit prohledávání grafu.
V moment nalezení finálního výsledku se zavolá abstraktní metoda \texttt{void ProcessResult()}, která zpracuje výsledek.
Rozhraní prohledávání neposkytuje návrat nalezených výsledků.
Pokud se výsledky mají ukládat, tak potomek dané třídy musí dostat v konstruktoru objekt úložiště a přepsat metodu \texttt{void ProcessResult()}.
Způsob zpracování výsledku si definují potomci.

\subsubsection{Třída DFSPatternMatcher}

Třída je potomkem třídy výše.
Reprezentuje algoritmus prohledávání grafu, který ukládá výsledky do tabulky v moment jejich nalezení.
V konstruktoru dostane tabulku \texttt{MatcherFixedResultsInternal}, kam ukládá své výsledky prohledávání.
Metoda \texttt{ProcessResult} tedy ukládá výsledky do dané tabulky.
V průběhu volání této metody taky dochází k počítání nalezených výsledků v položce \texttt{NumberOfMatchedElements}.
Pokud uživatel zadal pouze \texttt{count(*)} v části \textit{Select}, tak nedochází k ukládání výsledků do tabulky.

\subsubsection{Třída DFSParallelPatternMatcher} \label{impl.match.parmatch}

Třída představuje paralelní prohledávání grafu, které ukládá výsledky v moment nalezení do tabulky.
Paralelizaci jsme popsali v sekci \ref{anal.matchPar}.
V konstruktoru dostává počet vláken \texttt{ThreadCount}, vzor \texttt{DFSPattern}, graf \texttt{Graph} a instanci úložiště výsledků \texttt{MatchFixedResults}.
K paralelizaci prohledávání grafu využívá instance třídy \texttt{DFSPatternMatcher} a počet instancí odpovídá hodnotě \texttt{ThreadCount}.
Tedy v konstruktoru vytvoří tyto instance a každé přidělí kopii vzoru, graf a její lokální úložiště.
Výsledně obsahuje položky:
\begin{itemize}
\item \texttt{MatchFixedResults results} obsahuje lokální tabulky výsledků vláken.
\item \texttt{DFSPatternMatcher[] matchers} obsahuje instance tříd algoritmů prohledávání grafu.
Každá instance má svou lokální kopii vzoru a odkaz na tabulku výsledků.
\end{itemize}
Paralelní prohledávání je spuštěno metodou \texttt{void Search()}.
Zde využíváme nativní \texttt{ThreadPool}.
Je vytvořeno \texttt{ThreadCount} instancí \texttt{Task} vykonávají práci \texttt{WorkMultiThreadSearch(object o)}, kde \texttt{o} je lokální \texttt{JobMultiThreadSearch}.
Ten obsahuje instanci prohledávání a objekt \texttt{VertexDistributor}.
Objekt jsme definovali v analýze (obrázek \ref{figure.diaQueryObjectsMatchPar} blok \texttt{VertexDistributor}).
Drží odkaz na pole vrcholů grafu a index posledního přiděleného vrcholu.
Množství přidělených vrcholů je definováno v položce \texttt{int verticesPerRound}.
Vlákna jej žádají o rozsah vrcholů metodou \texttt{void DistributeVertices(out int start, out int end)} a následně spustí prohledávání z daných vrcholů.

Po dokončení prohledávání dojde k paralelnímu slévání tabulek.
Rozhodli jsme se použít metodu slévání po sloupečcích tabulek, protože slévání celých tabulek po dvojicích bylo pomalejší.
Paralelizace probíhá podobným způsobem jako paralelizace prohledávání.
Je vytvořeno $n$ instancí \texttt{Task}, kde $n$ je počet sloupečků v tabulce, které vykonávají práci \texttt{ParallelMergeColumnWork(object o)}, kde \texttt{o} je lokální \texttt{ParallelMergeColumnJob}.
Ten obsahuje odkaz na \texttt{MatchInternalResults} a \texttt{ColumnDistributor}.
Vlákna žádají objekt \texttt{ColumnDistributor} o sloupeček ke slévání.
Interně objekt funguje totožně jako \texttt{VertexDistributor} s rozdílem, že si objekt pamatuje index prvního nepřiděleného sloupečku.
Slévání probíhá voláním metody \texttt{MergeColumn} na instanci \texttt{results}.
V moment dokončení slévání jsou finální výsledky v položce \texttt{results.FinalMerged}.
Tato položka je předána konstruktoru \texttt{TableResults}, která implementuje rozhraní \texttt{ITableResults}.
Třída představuje tabulku výsledků, kterou si objekty částí dotazu (\texttt{QueryObjekt}) předávají ke zpracování.
Pokud dotaz obsahoval pouze \texttt{count(*)} v části \textit{Select}, tak se výsledky neukládaly do tabulku a místo slévání výsledků dojde pouze ke slévání položek instancí DFS algoritmů \texttt{NumberOfMatchedElements}.

\subsection{Tabulka výsledků} \label{impl.table}

V této sekci popíšeme implementaci tabulky výsledků, kterou si předávají objekty dotazu.
Tabulku jsme implementovali dle sekce analýzy \ref{anal.tables}.

\subsubsection{Třída TableResults}

Objekty exekučního plánu si předávají tabulku výsledků prohledávání rozhraním \texttt{ITableResults}.
Ačkoliv jsme navrhli rozhraní, tak obecně používáme pouze jednu třídu \texttt{TableResults}, která rozhraní implementuje.
Zároveň jsme ji upravili rovnou k možnosti použití pro ukládání pouze reprezentantů skupin popsaném v sekci \ref{anal.uprava.Groupby.table}.
Hlavní vlastnosti jsou:
\begin{itemize}
\item \texttt{int ColumnCount} je počet sloupečků v tabulce.
Sloupeček zde odpovídá jedné proměnné dotazu, tj. na jeden řádek se díváme jako na hodnoty v poli \texttt{scope} z průběhu prohledávání.
Tedy počet sloupečků je roven počtu unikátních proměnných v dotazu.
Pokud chceme přistoupit k proměnné výsledku prohledávání, musíme znát její pozici v poli \texttt{scope}.

\item \texttt{int RowCount} je počet řádků v tabulce.
\item \texttt{int FixedArraySize} je velikost bloků v tabulce.
Tabulka opět využívá princip ukládání výsledků do bloků fixní délky.
Stejný princip jsme použili při ukládání výsledků v průběhu prohledávání grafu.
To nám umožní v moment dokončení slévání pouze přesunou výsledky do konstruktoru této třídy.
\item \texttt{List<Element[FixedArraySize]>[] resTable} je tabulka výsledků prohledávání.
\texttt{resTable[i]} je \textit{i}-tý sloupeček.
\texttt{resTable[i][j]} je \textit{j}-tý blok ve sloupečku.
\texttt{resTable[i][j][k]} je \textit{k}-tý výsledek v bloku.
\item \texttt{Element[] temporaryRow} představuje odkaz na pole elementů, ke kterému lze přistoupit skrze rozhraní tabulky, aniž by bylo pole elementů v tabulce.
\item Metoda \texttt{void StoreRow(Element[])} překopíruje hodnoty do tabulky. Funguje ekvivalentně jako \texttt{AddRow} ve třídě \texttt{MatcherFixedResultsInternal}.
\item Metoda \texttt{void StoreTemporaryRow()} vyvolá metodu výše pro uložení pole \texttt{temporaryRow} do tabulky, tj. zavolá metodu \texttt{StoreRow(temporaryRow)}.
\item Funkce hranatých závorek \texttt{RowProxy this[int i]}, která vrátí proxy třídu řádku.
\item Položka \texttt{int[] order} umožní definovat vlastní pořadí řádků v tabulce bez nutnosti přesouvat řádky.
\item Položka \texttt{int NumberOfMatchedElements}, která udává počet nalezených výsledků, pokud bylo v části dotazu \textit{Select} zadáno pouze \texttt{count(*)}.
V takovém případě nedocházelo k ukládání výsledků do tabulky, ale jen počítání jejich počtu.

\end{itemize}
V průběhu analýzy jsme navrhli způsob práce s řádky. 
Místo abychom pracovali konkrétně s řádky, tak jsme implementovali proxy třídu řádku pomocí struktury \texttt{struct RowProxy}.
Struktura obsahuje pouze dvě položky. 
První je index řádku \texttt{int index}, který reprezentuje, a druhá je odkaz na tabulku \texttt{TableResults resTable}.
Získá se voláním funkce hranatých závorek na třídě tabulky.
Na získané struktuře se pak voláním metody \texttt{Element this[int c]} přistoupí k proměnné na řádku tabulky (\texttt{c} je zde sloupeček tabulky).
Danou třídu pak budeme používat k vyhodnocení výrazů a výpočtům agregačních funkcí.
Kdykoliv budeme předávat strukturu do funkce, tak ji budeme předávat pomocí parametru \texttt{in}, který vyvolá předání odkazem.
Tím vyloučíme zbytečné kopírování položek struktury.
Na struktuře existuje statická metoda \texttt{AreIdenticalVars}, která porovná dvě proxy třídy řádků, zda obsahují stejné elementy grafu na základě jejich \texttt{ID}.

\subsection{Expressions}

Než přistoupíme k implementaci \textit{Order by} a \textit{Group by} musíme implementovat způsob vyhodnocení výrazů.
K výpočtu výrazů jsme implementovali vlastní jednoduchý systém.
Postupovali jsme přesně podle sekce analýzy \ref{anal.expressions}, proto popíšeme jen tvorbu a základní objekty.

\subsubsection{Tvorba výrazů}

V části načítání dotazu \ref{impl.parsing} jsme uvedli, že výstupem načítání jsou syntaktické stromy každé části dotazu.
Tyto stromy obsahují i podstromy výrazů.
Každá část dotazu má svůj objekt implementující rozhraní \texttt{IVisitor<T>}, kterým se sbírají důležitá data.
Pokud v průběhu procházení dojde k nalezení podstromu výrazu, tak dojde k vytvoření speciálního objektu \texttt{ExpressionVisitor}.
Tento objekt procházením podstromu vytvoří stromovou strukturu výrazu, pomocí které se bude vyhodnocovat daný výraz v průběhu vykonávání dotazu.
Objekt implementuje \texttt{IVisitor<ExpressionBase>}, kde \texttt{ExpressionBase} reprezentuje výsledný výraz.
Všechny výrazy se globálně udržují v třídě \texttt{QueryExpressionInfo}, která jim přiděluje \texttt{ID} na základě jejich pořadí vytvoření.
Třída si také pamatuje výrazy agregačních funkcí a přiděluje jim rovněž \texttt{ID} na základě pořadí vzniku.

\subsubsection{Třídy výrazů}

Implementace tříd výrazů je totožná jako v analýze.
\texttt{ExpressionBase} je abstraktní třída, která definuje základní rozhraní struktur výrazů.
Definuje:
\begin{itemize}
\item Metodu \texttt{Type GetExpressionType()}, která vrací návratový typ výrazu.
\item Metodu \texttt{void CollectUsedVars(ref List<int> v)}, která vrátí \texttt{ID} proměnných potřebných k vyhodnocení stromové struktury výrazu.
\end{itemize}
Z třídy vzniká abstraktní potomek \texttt{ExpressionReturnValue<T>}, který definuje návratovou hodnotu funkce v parametru \texttt{T}.
Třída definuje rozhraní výpočtu výrazu metodami \texttt{bool TryEvaluate( ... x, out T returnValue)}.
Kde \texttt{x} jsou položky nutné k vyhodnocení výrazu, což jsou zde řádky z tabulky výsledků.
Mezi hlavní patří \texttt{Element[]} a \texttt{RowProxy}.
Z třídy následně dědí nová abstraktní třída \texttt{VariableReference<T>}, která představuje přístup k proměnné.
\texttt{ID} přistoupené proměnné je uloženo v položce \texttt{int VariableIndex}.
Z třídy finálně dědí dvě třídy.
Konkrétní třída \texttt{VariableIDReference}, která vrací \texttt{ID} elementu grafu představující proměnnou.
Druhá třída je \texttt{VariablePropertyReference<T>}, která představuje přístup k vlastnosti elementu grafu představující proměnnou a \texttt{T} je zde typ vlastnosti.
\texttt{ID} vlastnosti je uloženo v položce \texttt{int PropertyID}. 

\subsubsection{Výraz agregační funkce}

Při implementaci výrazu agregační funkce jsme postupovali jako v analýze.
Vytvořili jsme dva koncepty.
První koncept představuje logiku agregační funkcí.
Tu představuje abstraktní třída \texttt{Aggregate}, jejíž potomci implementují specifickou logiku výpočtu funkcí. 
Druhý koncept představuje odkaz na vypočtenou hodnotu funkce, ke které se může přistupovat v jiných částech dotazu.
Tento koncept představuje třída \texttt{AggregateReference<T>: ExpressionReturnValue<T>}.
Třída reprezentuje hodnotu již vypočtené agregační funkce a typ hodnoty je parametr \texttt{T}.
\texttt{ID} funkce, kterou reprezentuje, je uloženo v položce \texttt{int AggrPosition}.

Obecně jsme vytvořili třídu \texttt{ExpressionHolder}, která udržuje odkaz na třídu \texttt{ExpressionBase}.
Tato třída je používaná k předávání výrazů do funkcí a konstruktorů.

\subsection{Order by}

Implementovali jsme části nutné ke zpracování \textit{Order by} a \textit{Group by}.
Nyní popíšeme implementaci jejich řešení.
Začneme popisem části \textit{Order by}.
U implementace jsme vycházeli z sekce analýzy \ref{anal.orderby}.

\subsubsection{Třída OrderByObject}

Část \textit{Order by} je reprezentována objektem \texttt{OrderByObject: QueryObject}.
\textit{Order by} musí setřídit tabulku \texttt{TableResults} pomocí výrazů zadaných uživatelem (klíčů třídění).
Klíče jsou vytvořeny v konstruktoru objektu při procházení syntaktického stromu objektem \texttt{OrderByVisitor<List<ExpressionComparer> >}.
Výstup procházení obsahuje pole porovnávačů, které se musí použít k porovnaní řádků tabulky.

\subsubsection{Třída ExpressionComparer}

\texttt{ExpressionComparer} je abstraktní třída definující rozhraní porovnávače jednoho klíče třídění.
Jejím úkolem je vypočíst a porovnat hodnoty jednoho klíče třídění dvou řádků.
Definuje:
\begin{itemize}
\item Abstraktní metodu \texttt{int Compare(in RowProxy x, in RowProxy y)} porovnávající dva řádky tabulky.
\texttt{in} parametr zde představuje předání argumentu odkazem, aby nedocházelo ke zbytečnému kopírování struktur.
\item Položku \texttt{int[] usedVars}, která obsahuje \texttt{ID} proměnných nutných k výpočtu hodnot klíče.
\item Položku \texttt{bool isAscending}, která určuje, jestli se třídí sestupně nebo vzestupně.
\item Položku \texttt{ExpressionHolder expr}, která obsahuje výraz porovnávání.
\item Položku \texttt{bool CacheResults}, která určuje, zda se má použít optimalizace.
\texttt{true} označuje využití optimalizace.

\end{itemize}
Potomky třídy jsou třídy \texttt{ExpressionComparer<T>}, které představují porovnání konkrétních typů návratových hodnot výrazů.
Potomci budou také implementovat zmíněné optimalizace z sekce analýzy \ref{anal.orderby}.

\subsubsection{Třída ExpressionComparer<T>} \label{impl.orderby.opts}

Třída konkretizuje návratovou hodnotu výrazu porovnání v parametru \texttt{T}.
Obsahuje výraz \texttt{ExpressionReturnValue<T>}, který se vyhodnotí porovnávanými řádky.
Implementuje metodu \texttt{Compare( ... x, ... y)} rodiče.
Nyní popíšeme způsob porovnání společně s optimalizacemi:

\begin{enumerate}
\item Dojde k porovnání proxy tříd pomocí statické metody \\*\texttt{RowProxy.AreIdenticalVars(in x, in y, this.usedVars)}, \\*která
porovnává elementy na řádcích tabulky dle jejich \texttt{ID}.
Avšak, porovnáváme zde jen elementy proměnných, které se používají k výpočtu výrazu (položka \texttt{usedVars}).
Pokud jsou totožné, nemusíme vypočítávat hodnotu výrazu.
Tím vyřešíme optimalizaci porovnání stejných elementů z sekce \ref{anal.orderby.opt2}.

\item Následuje vypočtení hodnot výrazů řádků a jejich porovnání.
Pokud byla \texttt{CacheResults == false}, tak nic dalšího se neprovádí.
Opačně, při výpočtu hodnot si uložíme pozici řádku \texttt{x.index} do \texttt{int lastXRow}, zda se výraz vyhodnotil správně do \texttt{bool lastXSuccess} a hodnotu výrazu do \texttt{T lastXValue}.
To samé pro řádek \texttt{y}: \texttt{int lastYRow}, \texttt{bool lastYSuccess} a \texttt{T lastYValue}.
Pokud při příštím porovnání budou \texttt{x} nebo \texttt{y} totožné řádky, tak již máme vypočtené hodnoty výrazů. 
Tím vyřešíme optimalizaci porovnání stejných vlastností z sekce \ref{anal.orderby.opt1}.
\end{enumerate}

Optimalizace v druhém kroku je nefunkční v paralelním prostředí.
Protože by se vlákna snažila ukládat výsledky na sdílené pozice a došlo by k souběhu.
Snažili jsme se problém vyřešit třídou \texttt{ThreadLocal} (lokální úložiště vlákna).
Každá ukládaná položka by byla obsažena v dané třídě a vlákna by tak měla svá úložiště.
Dalším zkoušeným řešením bylo uzavřít celou třídu porovnávače do \texttt{ThreadLocal}.
Avšak, tyto způsoby způsobili zpomalení vykonávání, proto jsme se rozhodli optimalizaci využívat pouze v jednovláknovém prostředí.

\subsubsection{Třída RowComparer a IndexToRowProxyComparer}

Všechny třídy porovnávače využívané k porovnání dvou proxy tříd jsme uzavřeli do třídy \texttt{RowComparer}, která postupně zkouší vykonat porovnání porovnávači, než dojde ke stanovení rovnosti řádků.
Protože jsme v analýze stanovili, že se budou porovnávat pouze indexy řádků, tak jsme vytvořili třídu, která obalí \texttt{RowComparer} a umožní porovnávat řádky pomocí indexů. 
Třída se jmenuje \texttt{IndexToRowProxyComparer}.
Drží odkaz na tabulku \texttt{ResultTable} a zmíněnou \texttt{RowComparer}.
Volání metody \texttt{int Compare(int x, int y)} na třídě dojde k získání proxy tříd řádků \texttt{x} a \texttt{y}.
Následně dojde k jejich porovnání pomocí \texttt{RowComparer}.
Implementaci třídy jsme dále rozšířili dle návrhu porovnávání řádků tabulky při vkládání řádků do vyhledávacího stromu z sekce analýzy \ref{anal.improvement.orderby.storeindex}.
Existuje zde nově položka \texttt{bool allowDuplicities}.
Pokud položka je nastavená na \texttt{false}, tak při určení shodnosti hodnot klíčů dvou řádků se výsledně použije k porovnání jejich index v tabulce (což jsou zde hodnoty \texttt{x} a \texttt{y}).
Čili, položka nastavená na \texttt{true} porovnává pouze podle klíčů třídění.
\texttt{true} je nastaveno tedy vždy, pokud je třída používá s vyhledávacími stromy. 

\subsubsection{Řešení Normal: Merge sort}

Připravili jsme všechny nutné podklady pro vykonání třídění.
Samotné vykonání třídění je implementováno v třídě \texttt{MultiColumnTableSorter} v metodě \texttt{Sort}.
Třída drží odkaz na \texttt{IndexToRowProxyComparer}, který bude sloužit jako porovnávač při třídění.
Metoda vytvoří pole indexů \texttt{int[]} velikosti odpovídající počtu řádků v tabulce.
K třídění indexů v poli používáme knihovnu HPCsharp \citep{hpcsharp}.
Konkrétně využíváme algoritmus Merge sort pro jednovláknové zpracování a pro paralelní používáme paralelní verzi Merge sort.
Výsledně se pole indexu předá tabulce na položku \texttt{ResultTable.order}.
Pole nyní slouží jako indexační struktura tabulky.
Toto řešení budeme označovat v průběhu testování paralelního i jednovláknového zpracování jako \textbf{Normal: Merge sort}.
První slovo určuje mód, kterému řešení přináleží.

\subsection{Group by}

V této sekci popíšeme implementaci \textit{Group by}.
U implementace \textit{Group by} jsme vycházeli z sekce analýzy \ref{anal.groupby}.

\subsubsection{Třída GroupByObject}

Část \textit{Group by} je reprezentována objektem \texttt{GroupByObject: QueryObject}.
\textit{Group by} musí seskupit výsledky v tabulce prohledávání \texttt{TableResults} pomocí výrazů zadaných uživatelem (klíčů seskupení).
Zároveň musí provést výpočet agregačních funkcí.
Klíče jsou vytvořeny v konstruktoru objektu při procházení syntaktického stromu objektem \texttt{GroupByVisitor<List<ExpressionHolder> >}.
Výsledné pole obsahuje výrazy, které se musí použít k seskupování.
V průběhu sestavování dalších částí dotazu dochází k vytváření objektů logiky výpočtu agregačních funkcí.
Logika je obsažena v potomcích objektu \texttt{Aggregate}.
Výsledný objekt části \textit{Match} tedy obsahuje pole výrazů a pole objektů logiky agregačních funkcí.
Nejdříve popíšeme implementaci seskupování a následně implementaci agregačních funkcí.

\subsubsection{Dictionary a ConcurrentDictionary}

Abychom pochopili implementaci seskupování musíme se podívat na způsob práce s hašováním výrazů.
V analýze jsme určili, že výsledky prohledávání budeme seskupovat pomocí hašovací tabulky, ať už v jednovláknovém nebo paralelním zpracování.
Jazyk C\# obsahuje hašovací tabulku \texttt{Dictionary<Key, Value>} pro jednovláknové zpracování a \texttt{ConcurrentDictionary<Key, Value>} pro paralelní zpracování.
\texttt{ConcurrentDictionary} je thread-safe verze \texttt{Dictionary}. 
\texttt{Key} zde chápeme jako řádek tabulky a \texttt{Value} úložiště hodnot agregačních funkcí. 
\texttt{Key} zde nebude proxy třída, ale pouze index řádku.
Porovnání vyvolá získání proxy třídy jako v předchozí sekci u třídění.
Obvyklé vkládání prvků do \texttt{Dictionary} vypadá následovně:
\begin{code}
Dictionary<int, int> dict = new Dictionary<int, int>();
int x = 5;
if (!dict.TryGetValue(x, out int y)) dict.Add(x, 42);
\end{code}
Nejdříve se v podmínce otestuje, jestli vkládaný prvek ve struktuře existuje.
To znamená, že se vypočte haš prvku a nalezne se místo vložení.
Jestli na místě nějaký prvek již leží, tak dojde k porovnání hodnot a jinak funkce vrací \texttt{false}.
Funkce vrátí \texttt{true} při úspěchu porovnání prvků a při neúspěchu vrátí \texttt{false}.
Při vrácení \texttt{false} dojde k vložení funkcí \texttt{Add}, která opět vypočte haš a případně porovná prvky.
Obvyklé vkládání prvku pro \texttt{ConcurrentDictionary} vypadá následovně:
\begin{code}
ConcurrentDictionary<int, int> dict = 
    new ConcurrentDictionary<int, int>();
int x = 5;
var retVal = dict.GetOrAdd(x, 42);
\end{code}
Nyní neuvažujme žádné synchronizační koncepty.
Funkce \texttt{GetOrAdd} vypočte haš, získá místo vložení a pokud na místě jiný prvek není rovnou ho vloží.
Zde tedy dochází k hašování a porovnání pouze jednou.
V prvním případě \texttt{Dictionary} bychom byli nuceni vyhodnotit ten samý výraz 4-krát.
Obecně obě struktury pro dva rozdílné prvky se stejnou haš hodnotou mohou vytvářet spojový seznam daných prvků.
Výsledně bychom museli vypočítávat výrazy při každém porovnání v seznamu.
Navíc, pokud by docházelo ke slévání výsledků dvou hašovacích tabulek do jedné, tak bychom opět museli počítat haš a porovnávat.
Interně obě struktury používají k výpočtu haš hodnoty a porovnání objekt s rozhraním \texttt{IEqualityComparer<T>}.
Kde \texttt{T} je \texttt{Key}. 
Objekt má metodu \texttt{int GetHashCode(T o)} a \texttt{bool Equals(T x, T y)}.
První vypočte haš vkládaného objektu a při porovnání se vyvolá metoda \texttt{Equals}.
Strukturám se dá v konstruktoru poskytnou vlastní implementaci rozhraní.
Díky této implementaci jsme vymysleli dvě optimalizace:
\begin{enumerate}
\item V moment, kdy dochází k použití \texttt{Dictionary} nebo aktu slévání hašovacích tabulek, budeme jako \texttt{Key} používat strukturu \texttt{GroupDictKey}.
Struktura obsahuje dvě položky \texttt{int hash} a \texttt{int position}. 
\texttt{hash} je zde haš řádku a \texttt{position} je index řádku v tabulce výsledků.
Tedy jsme rozšířili \texttt{Key} o haš hodnotu řádku, kterou můžeme znovu použít, pokud to bude nutné.
Budeme implementovat vlastní \texttt{IEqualityComparer<T>}, který jen použije haš hodnotu ze struktury.
Tímto vypočteme haš pouze jednou za celý cyklus vkládání nebo slévání.
Pokud používáme \texttt{ConcurrentDictionary} a nedochází ke slévání, tak stačí jako \texttt{Key} volit index řádku.
\item Při výpočtu haš hodnoty se vypočítávají hodnoty výrazů.
Abychom nepočítali stejné výrazy opětovně při porovnání, tak budeme používat dvě třídy.
V prvním případě vytvoříme \texttt{ExpressionHasher}, který počítá haš hodnotu jednoho výrazu.
Třídu propojíme s již existující \texttt{ExpressionComparer<T>}.
Třída \texttt{ExpressionHasher} při výpočtu výrazu pak jen aktualizuje vnitřní hodnoty položek (\texttt{lastYRow}, \texttt{lastYValue} a \texttt{lastYSuccess}) uvnitř porovnávače a ten je následně využije.
Nastavujeme položky argumentu \texttt{y} (dle metody \texttt{Compare(x, y)}), protože vkládaný prvek při porovnání je vždy uchováván v \texttt{y}.
Toto odpovídá navržené optimalizaci z sekce analýzy \ref{anal.groupby.opt1}.
\end{enumerate}
Problémem u druhé optimalizace je opět sdílení položek v paralelním prostředí.
Jelikož jsme se v předchozí sekci \textit{Order by} rozhodli nevyužívat při paralelním zpracování optimalizaci ukládání výsledků výrazů.
Tak ani zde ji nebudeme implementovat pro paralelní zpracování. 

\subsubsection{Třída ExpressionHasher a třídy ExpressionHasher<T>}

\texttt{ExpressionHasher} je abstraktní třída reprezentující jeden klíč seskupení.
Definuje:
\begin{itemize}
\item Položku \texttt{ExpressionHolder expr}, která obsahuje výraz seskupení.
\item Abstraktní metodu \texttt{int Hash(in RowProxy row)}, která vypočte haš výrazu pro řádek tabulky. 
V průběhu výpočtu dojde k nastavení položek porovnávače.
\item Abstraktní metodu \texttt{SetCache(ExpressionComparer cache)}, ve které si potomci nastaví odkaz na \texttt{ExpressionComparer<T>}.
To umožní následně při výpočtu hodnoty výrazu přiřadit výsledky dané třídě.
\end{itemize}
Potomky třídy jsou třídy \texttt{ExpressionHasher<T>}.
Implementují výpočet výrazu pro konkrétní návratový typ \texttt{T} a výpočet haše výrazu.
Třída obsahuje položku \texttt{ExpressionComparer<T> exprComp}, která obsahuje odkaz na porovnávač nastavený v metodě \texttt{SetCache}. 
Dále obsahuje výraz \texttt{ExpressionReturnValue<T> expr} použitý k výpočtu klíče seskupení.
Všechny klíče seskupení jsou obsaženy v třídě \texttt{RowHasher}, která vypočte finální haš kombinací všech haš hodnot výrazů. 

\subsubsection{Rozhraní IEqualityComparer<T>}

V aplikaci jsme vytvořili dva objekty:
\begin{itemize}
\item \texttt{RowEqualityComparerInt: IEqualityComparer<int>} definuje porovnání a výpočet haš hodnot pomocí indexu řádku tabulky.
Třída drží odkaz na tabulku \texttt{TableResults} pro získání proxy třídy řádku indexem.
Dále má porovnávače \texttt{ExpressionComparer[]} pro zjištění rovnosti dvou prvků v hašovací tabulce a finálně \texttt{RowHasher} pro výpočet haše.
Položka \texttt{bool cacheResults} určuje zda se má použít druhá optimalizace.
\item \texttt{RowEqualityComparerGroupDictKey:} \\*\texttt{IEqualityComparer<GroupDictKey>}, který je totožný s předchozím, ale neobsahuje \texttt{RowHasher}, protože haš je uložen v objektu porovnání.
\end{itemize}

\subsubsection{Logika agregačních funkcí}

Implementovali jsme způsob seskupování.
Nyní budeme implementovat objekty logiky agregačních funkcí.
V sekci implementace výrazů jsme řekli, že logika je reprezentována abstraktní třídou \texttt{Aggregate}.
Tyto třídy jsou tvořeny v průběhu procházení syntaktických podstromů výrazů a jsou uloženy v poli \texttt{List<Aggregate>} uvnitř třídy \texttt{QueryExpressionInfo}.
Indexy funkcí v daném poli slouží jako \texttt{ID} daných funkcí.
Každá funkce potřebuje úložiště hodnot.
Úložiště pak musí být používány pro správnou funkci na základě jejich \texttt{ID}.

Každá uživatelem zadaná funkce je tedy reprezentována třídou \texttt{Aggregate}.
Třída obsahuje položku \texttt{ExpressionHolder expr}, která představuje výraz, jehož hodnota se použije k výpočtu funkce.
Dále třída definuje metody, které slouží k aplikování logiky pro specifické úložiště.
Popíšeme je obecně:
\begin{itemize}
\item Metoda \texttt{void Apply(x, druh\_úložiště y)} vypočte hodnotu výrazu \texttt{expr} pomocí \texttt{x} (\texttt{RowProxy} nebo \texttt{Element[]}), hodnotu zpracuje definovanou logikou a výsledek uloží do úložiště \texttt{y}.
Pro každé úložiště pak existuje daná metoda.
Zároveň pro úložiště existují thread-safe verze metod opatřených příponou \texttt{ThreadSafe}.

\item Metoda \texttt{void Merge(druh\_úložiště\_X x, druh\_úložiště\_Y y)}\\* sloučí výsledky dvou úložišť \texttt{x} a \texttt{y}. 
Výsledek sloučení je uložen v úložišti \texttt{x}.
Pro každé úložiště pak existuje daná metoda a opět i thread-safe verze opatřených příponou \texttt{ThreadSafe}.
\end{itemize}
Konkrétní implementace logiky je přesunuta na potomky.
Z dané třídy dědí abstraktní třída \texttt{Aggregate<T>}, která konkretizuje návratovou hodnotu výrazu parametrem \texttt{T}.
Obsahuje položku \texttt{ExpressionReturnValue<T> expr} pro výpočet hodnoty výrazu.
Zde je nutné si uvědomit, že \texttt{T} není návratová hodnota agregační funkce, ale jen hodnota výrazu.
Návratová hodnota agregační funkce je uložena v separátním úložišti a může být jiného typu. 
Z třídy následně vznikají už konkrétní implementace logiky.
Funkce \texttt{sum} a \texttt{avg} mohou na vstupu obsahovat pouze číselnou hodnotu.
To v našem případě je pouze \texttt{int}, protože jsme omezili typy vlastností ve vstupních souborech.
Funkce \texttt{count}, \texttt{min} a \texttt{max} mohou navíc mít i řetězec \texttt{string}:
\begin{itemize}

\item Třída \texttt{IntSum: Aggregate<int>} reprezentuje funkci \texttt{sum}.
Obecně metoda \texttt{Apply} vypočte hodnotu výrazu a přičte ji k hodnotě v úložišti.
Úložiště musí obsahovat sumu již vypočtených výrazů.
Thread-safe verze používá k přičtení atomickou operaci přičtení \texttt{Interlocked.Add(...)}.
\texttt{Merge} pak pouze přičte hodnotu v \texttt{y} do \texttt{x} stejným způsobem.

\item Třída \texttt{IntAvg: Aggregate<int>} reprezentuje funkci \texttt{avg}.
Úložiště musí obsahovat sumu již vypočtených výrazů společně s jejich počtem.
Zpracování pak pouze přičte hodnotu výrazu k sumě a navýší jejich počet.
Přičítání je implementováno shodně jako v \texttt{IntSum}.

\item Třída \texttt{Count<T>: Aggregate<T>} představuje funkci \texttt{count}.
Přebírá v definici parametr \texttt{T}, protože v případě nepoužití \texttt{count(*)} musí být schopna pracovat se všemi druhy návratových hodnot výrazů.
Úložiště musí obsahovat počet správně vyhodnocených výrazů a v případě \texttt{count(*)} to je pouze počet prvků skupiny.
Tedy hodnota v úložišti je vždy \texttt{int}, ale stále potřebujeme být schopni vypočíst hodnotu vstupního výrazu, který má typ \texttt{T}. 
V případě \texttt{count(*)} se nevyhodnocují žádné výrazy uvnitř metody zpracování, ale pouze navyšuje interní hodnota úložiště.
Implementace metod je stejná jako u \texttt{IntSum}.

\item Třída \texttt{MinMaxBase<T>: Aggregate<T>} představuje logiku funkcí \texttt{min} a \texttt{max}.
Očekává se, že úložiště bude mít \texttt{bool}, který říká zda již byla hodnota inicializována.
Dále má aktuální minimum nebo maximum hodnot výrazu. 
V threa-safe verzích metod je využito \texttt{Interlocked.CompareExchange(..)} jako princip \textit{Compare and Exchange}. 
Potomci dané třídy jsou \texttt{Min<T>} a \texttt{Max<T>}.
Tyto třídy specifikují způsob porovnání hodnot výrazů.
\end{itemize}

\subsubsection{Úložiště hodnot agregačních funkcí}

Objekty \texttt{Aggregate} pracují s úložišti.
V analýze jsme definovali dva druhy úložišť.
První bylo úložiště Bucket a druhé List.
V aplikaci jsme implementovali řešení reprezentující úložiště Bucket a řešení úložiště List přesně podle analýzy.
Samotná logika tříd je společná všem řešením, proto popíšeme pouze podrobněji řešení Bucket.
Zbylá řešení implementují stejnou logiku s tím, že místo jedné hodnoty obsahují pole hodnot.
Samotná úložiště jsou použita jako \texttt{value}, při vkládání do \texttt{Dictionary<key, value>} nebo \texttt{ConcurrentDictionary<key, value>}.
To znamená, že každá skupina má své úložiště.

\subsubsection{Třída AggregateBucketResult}

Představuje abstraktní třídu používající způsob ukládání Bucket.
Potomci definují typ ukládané hodnoty.
Každý potomek je využívaný určitou agregační funkcí.
Třída definuje:
\begin{itemize}
\item Metodu \\*\texttt{AggregateBucketResult Factory(Type type, string funcName)}, \\*která implementuje návrhový vzor Factory metoda \citep[str. 107]{patterns}.
\texttt{type} zde určuje typ ukládané hodnoty v úložišti a \texttt{funcName} představuje druh agregační funkce, která s úložištěm bude pracovat.
\item Metodu \\*\texttt{AggregateBucketResult[] CreateBucketResults(Aggregate[] ags)}, \\*která vytváří výsledné úložiště hodnot na základě počítaných agregačních funkcí.
Pro Bucket jsme úložiště definovali jako pole tříd, ve kterém každá třída obsahuje hodnotu počítané funkce.
Výsledek funkce označme \texttt{x}. 
Přístup \texttt{x[i]} odpovídá úložišti funkce \texttt{ags[i]}.
\end{itemize}
Z třídy dále dědí \texttt{AggregateBucketResult<T>}, která definuje ukládanou hodnotu \texttt{T aggResult}.
Třída se používá při výpočtech funkcí \texttt{count} a \texttt{sum}.
Již jsme řekli, že u funkce \texttt{count} je \texttt{T} rovno \texttt{int}.
Pro funkci \texttt{sum} je \texttt{T} rovno \texttt{long}, aby nedocházelo k přetečení.
Z této třídy dědí dvě třídy:
\begin{itemize}
\item První je \texttt{AggregateBucketResultWithSetFlag<T>}, která přidává položku \texttt{bool isSet}.
Položka určuje zda byla hodnota již inicializována.
Třída se použije při výpočtu funkcí \texttt{min} a \texttt{max}.
U daných funkcí je \texttt{T} rovno návratové hodnotě výrazu uvnitř třídy \texttt{Aggregate<T>}.

\item Druhá je \texttt{AggregateBucketAvgResult<T>}, která se použije při výpočtu funkce \texttt{avg} a přidává definici počtu vypočtených výrazů \texttt{int resultCount}.
\texttt{T} úložiště u dané funkce je \texttt{long}, ze stejného důvodu jako u funkce \texttt{sum}, tj. ukládáme sumu hodnot výrazů. 
Výsledná hodnota je vypočtena podílem \texttt{aggResult/resultCount}.
\end{itemize}

Pro řešení List je návrh totožný.
Názvy místo \texttt{Bucket} obsahují \texttt{List}.
A definované položky jsou pole místo jedné hodnoty (např. \texttt{List<T> aggResults} místo \texttt{T aggResult}).
Výsledně při používání úložiště Bucket vkládáme jako \texttt{value} do hašovací tabulky odkaz na pole vytvořené metodou \texttt{CreateBucketResult(..)}.
Při použití List nemůžeme použít odkazy na pole, protože hlavní myšlenka List je mít úložiště mimo hašovací tabulku, abychom nemuseli vytvářet spoustu tříd jako u Bucket.
V tomto případě budeme vkládat jako \texttt{value} pozici hodnot v úložišti pro danou skupinu.
Každá skupina tedy obdrží unikátní index (typ \texttt{int}).
Výsledky agregačních funkcí pro danou skupinu jsou tedy uloženy na daném indexu v úložišti.

\subsubsection{Group by zpracování}

Implementovali jsme všechny potřebné objekty k vykonání seskupení.
Nyní krátce popíšeme řešení zpracování, protože jsme zde postupovali dle analýzy.
Každému řešení rovněž přiřadíme název, kterým řešení označíme v průběhu testování.
Název bude opět obsahovat název módu, za kterým následuje název řešení.
Zde navíc uvedeme za název řešení do závorky druh úložiště, tj. Bucket nebo List.
Začneme jednovláknovým zpracováním (sekce analýzy \ref{anal.groupby.singlethread}):
\begin{itemize}

\item Řešení \textbf{Normal: SingleThreadSolution (Bucket)} odpovídá jednovláknovému zpracování \textit{Group by} pomocí úložiště Bucket.
Řešení je v třídě \texttt{GroupByWithBuckets}.
K seskupení je použit \texttt{Dictionary<key, value>}, proto je zde využit \texttt{GroupDictKey} jako \texttt{key}.
\texttt{value} je zde odkaz na pole úložiště \texttt{AggregateBucketResult[]}.
Pole úložiště hodnot agregačních funkcí se vytváří pouze v momentě, kdy je vytvářen nový záznam do hašovací tabulky.
\texttt{RowEqualityComparerGroupDictKey} je zde rozhraní pro určení rovnosti skupin.
Využívají se obě optimalizace.

\item  Řešení \textbf{Normal: SingleThreadSolution (List)} odpovídá jednovláknovému zpracování \textit{Group by} pomocí úložiště List.
Řešení je obsaženo v třídě \texttt{GroupByWithList}.
Řešení využívá \texttt{Dictionary<key, value>}, tudíž je zdě opět \texttt{GroupDictKey} jako \texttt{key}.
Úložiště výsledků agregačních funkcí je vytvořeno na začátku v položce \texttt{aggResults}.
\texttt{value} je \texttt{int}, protože úložiště hodnot agregačních funkcí leží mimo hašovací tabulku.
Při přidávání nové skupiny do hašovací tabulky je určena nová pozice pro skupinu v úložišti \texttt{aggResults} pomocí \texttt{Dictionary.Count}.
Tato hodnota se vkládá s klíčem do hašovací tabulky a skrze ni se přistoupí k výsledkům funkcí pro skupinu.
\end{itemize}
Všechna paralelní řešení využívají nativní třídu \texttt{ThreadPool}.
\texttt{Tasks} vykonávají statickou metodu \texttt{SingleThreadGroupByWork(object o)}, kde \texttt{o} je objekt obsahující lokální položky vláken.
Obecně pro všechna řešení daný objekt obsahuje odkaz na pole \texttt{Aggregate}, odkaz na tabulku výsledků prohledávání \texttt{TableResults} a dva indexy určující rozsah výsledků z tabulky ke zpracování.
Každé řešení je reprezentováno třídou, která implementuje vlastní logiku zpracování.

\begin{itemize}
\item Řešení \textbf{Normal: Global (Bucket)} odpovídá paralelnímu zpracování z sekce \ref{anal.groupby.global}.
Řešení je obsaženo v třídě \texttt{GlobalGroupByBucket}.
K seskupení vlákna využívají sdílenou hašovací tabulka \texttt{ConcurrentDictionary<key, value>}.
Není zde druhá optimalizace a \texttt{key} je zde pouze index řádku (\texttt{int}). 
\texttt{value} je zde odkaz na pole úložiště \texttt{AggregateBucketResult[]}.
Metoda \texttt{GetOrAdd(key, value)} je použita k vkládání.
Při úspěšném vložení nového záznamu vrátí odkaz na námi vkládané pole úložišť (\texttt{value}).
Při neúspěchu vrací odkaz na již dříve vložené pole.
Zda k tomu došlo ověříme pomocí rovnosti referencí na vkládané a vrácené pole. 
Samotná logika funkcí vykonává jejich thread-safe verze. 
Rozhraní pro určení rovnosti řádků je zde \texttt{RowEqualityComparerInt}.
Úložiště List jsme se snažili implementovat, ale nepodařilo se nám vytvořit efektivní řešení.
Hlavní problémem byla synchronizace při přístupu k úložišti hodnot agregačních funkcí.
Zde jsme zkoušeli využít nativní třídu \texttt{Semaphor} k omezení vstupu do kritické sekce.
Ta však při přístupu pracuje se zámky a ve výsledku řešení bylo značně pomalé.
Řešení proto nebudeme dále uvádět.

\item Řešení \textbf{Normal: Two-step (Bucket)} odpovídá paralelnímu zpracování z sekce \ref{anal.groupby.twostep} s úložištěm Bucket.
Řešení je v třídě \texttt{TwoStepGroupByBucket}.
První část je implementována stejně jako jednovláknové řešení s Bucket.
Každé vlákno drží odkaz na svou lokální tabulku \texttt{Dictionary}.
Druhá část funguje jako \textbf{Global} řešení výše s rozdílem, že klíčem je zde \texttt{GroupDictKey}.
Zde vlákna sdílejí \texttt{ConcurrentDictionary}.

\item Řešení \textbf{Normal: Two-step (List) }odpovídá paralelnímu zpracování z sekce \ref{anal.groupby.twostep} s úložištěm List.
Řešení je v třídě \texttt{TwoStepGroupByList}.
První část je implementována stejně jako jednovláknové řešení s List.
Druhá část byla problematická, jelikož se jedná o stejný problém s úložištěm List jako u \textbf{Global} řešení.
Proto jsme se rozhodli v druhé části výsledky z List přeložit do Bucket.
To znamená, že pro záznamy v List vytvoříme nová pole \texttt{AggregateBucketResult[]}, které vložíme do \texttt{ConcurrentDictionary}.
Výsledně je druhá část implementována stejně jako \textbf{Global} řešení výše s rozdílem, že klíčem je zde \texttt{GroupDictKey}.

\item \textbf{Normal: LocalGroupByLocalTwoWayMerge (Bucket)}\textbf{/(List)} odpovídají paralelním zpracováním z sekce \ref{anal.groupby.local} s úložištěm Bucket/List.
Řešení jsou v třídách \texttt{LocalGroupByLocalTwoWayMerge} s příponou \texttt{Bucket} nebo \texttt{List}.
V prvním kroku jsou implementovány stejně jako jednovláknová řešení.
Vlákna zde drží odkaz na svou lokální tabulku \texttt{Dictionary}.
Při slévání dvou tabulek dochází k překopírování záznamů z jedné hašovací tabulky do druhé.
První je poté zahozena.
Výsledně existuje pouze jedna tabulka. 
Zde má značnou výhodu Bucket řešení, protože při slévání dochází k přesunutí odkazu na pole.
Zatímco u List dochází překopírovávání prvků mezi poli. 

\item \textbf{Normal: SingleGroup} odpovídájí módu \textit{Single Group Group by} zpracování z sekce \ref{anal.groupby.singlegroup}.
Řešení je v třídě \texttt{SingleGroupGroupBy}.
Třída je využívaná pro jednovláknové i paralelní zpracování.
Každé vlákno drží odkaz na lokální pole \texttt{AggregateBucketResult[]}, do kterého ukládá hodnoty funkcí.
Není zde úložiště List, protože pro každé vlákno existuje jen jedna skupina.

\end{itemize}

\subsection{Úprava propojení}

Implementovali jsme řešení, která zpracovávají výsledky po dokončení prohledávání grafu.
V této sekci popíšeme implementaci úprav dotazovacího enginu dle zadání práce.
K realizaci zpracování v průběhu prohledávání grafu jsme postupovali podle sekce analýzy \ref{anal.improvement}.

\subsubsection{Zahrnutí úprav do třídy Query}

Celé upravené zpracování dotazu je reprezentováno již existující třídou \texttt{Query}.
Samotný způsob vykonání se definuje v metodě \texttt{Create(...)}, kde jeden vstupní argument je mód.
Při vybrání upraveného módu se spustí rozdílný privátní konstruktor.
V konstruktoru dojde k vytvoření exekučního plánu.
V analýze jsme určili, že objekt části \textit{Select} s novým objektem \textit{Match} části \texttt{MatchObjectStreamed} je propojen původním způsobem.
Nyní pouze vytvoříme objekt \texttt{ResultProcessor} a nový objekt části \textit{Match} \texttt{MatchObjectStreamed}. 

\subsubsection{Třída ResultProcessor}

Části dotazu \textit{Order/Group by} budou nyní reprezentovány potomky nové třídy \texttt{ResultProcessor}.
Metody jsou použity ke zpracování výsledků v průběhu prohledávání grafu.
Třída definuje metody dle obrázku z analýzy \ref{figure.diaStreamedResultProcessor}.
Definuje:
\begin{itemize}
\item Abstraktní metodu \texttt{void Process(int matcherID, Element[] result)}, která implementuje logiku zpracování jednoho výsledku prohledávání.
První parametr \texttt{matcherID} je zde \texttt{ID} instance algoritmu prohledávání grafu, které se použije při přístupu k lokálním výsledkům v paralelních řešeních.
Očekává se, že instance algoritmu prohledávání grafu v moment dokončení prohledávání signalizují situaci pomocí této metody s \texttt{result == null}.
Po této signalizaci může dojít k finálním úpravám výsledků.
\item Abstraktní metodu \\*\texttt{RetrieveResults(out ITableResults t, out GroupByResults g)},\\* která získá finální zpracované výsledky v podobě tabulek. 
\end{itemize}
Z dané třídy dědí dvě abstraktní třídy.
První je třída \texttt{OrderByResultProcessor} představující část dotazu \textit{Order by}.
Díváme se na ni jako na ekvivalent třídy \texttt{OrderByObject}. 
Druhá je třída \texttt{GroupByResultProcessor} představující část dotazu \textit{Group by}.
Díváme se na ni jako na ekvivalent třídy \texttt{GroupByObject}.
Samotná konstrukce daných tříd je rovněž totožná s původními.
To znamená, že při konstrukci opět dochází k procházení syntaktických stromů a tvorbě totožných výsledných struktur.
Rozdíl je ten, že potomci tříd specifikují algoritmy zpracování v metodě \texttt{Process}.   

\subsubsection{Třída MatchObjectStreamed}

Třída dědí z třídy \texttt{MatchBaseObject}.
Třídě jsme přidali položku držící odkaz na třídu zpracovávající výsledky v \texttt{ResultsProcessor resultProcessor}.
Dále jsme třídě přidali metodu \texttt{PassResultProcessor}, která uloží odkaz na objekt zpracování do dané položky.
To odpovídá návrhu z obrázku \ref{figure.diaStreamedQueryObjects} s rozdílem, že jsme upustili od vytváření rozhraní \texttt{ResultProcessorConnection}, jelikož žádná jiná třída by jej nevyužila. 
Abychom mohli vykonávat zpracování v průběhu, tak nyní musíme upravit i samotné objekty prohledávání grafu.
Řekli jsme, že původní třída části \textit{Match} obsahuje odkaz na objekt prohledávání grafu a tabulku výsledků.
Nyní vlastní pouze odkaz na objekt zpracování \texttt{ResultsProcessor} a odkaz na nový objekt \texttt{DFSParallelPatternMatcherStreamed} algoritmu prohledávání grafu.
Objekt algoritmu musíme také upravit a předat mu odkaz na objekt zpracování.

\subsubsection{Třída DFSParallelPatternMatcherStreamed}

Tato třída představuje upravené chování třídy \texttt{DFSParallelPatternMatcher}.
V konstruktoru se nepředává tabulka výsledků \texttt{MatchFixedResults} a nedochází zde ke slévání výsledků.
Při inicializaci objektů jednovláknového prohledávání grafu se vytvářejí nově instance třídy \texttt{DFSParallelPatternMatcherStreamed}. 
Tyto instance obdrží nově \texttt{ID} na základě jejich pořadí vzniku.
Samotná paralelizace zpracování prohledávání funguje totožně jako v původní třídě.
Třídu jsme dále rozšířili o metodu \texttt{PassResultProcessor}, která předá odkaz na objekt zpracování instancím jednovláknového prohledávání.

\subsubsection{Třída DFSPatternMatcherStreamed}

Třída reprezentuje jednovláknový DFS algoritmus prohledávání.
Třída je potomkem třídy \texttt{DFSPatternMatcherBase}.
V konstruktoru očekává nově \texttt{ID} objektu \texttt{int matcherID}.
To znamená, že implementuje stejný algoritmus prohledávání, ale přepisuje metodu zpracování výsledků \texttt{ProcessResult()}.
Nově třída drží odkaz na objekt zpracování \textit{Order by} a \textit{Group by} v položce \texttt{ResultProcessor resultProcessor}.
Třídě jsme opět přidali metodu \texttt{PassResultProcessor}, která uloží odkaz objektu zpracování do zmíněné položky.
Finálně upravená metoda \texttt{ProcessResult()} vyvolá předání nalezeného výsledku (pole \texttt{Element[] scope} vzoru) spolu se svým \texttt{ID} pomocí metody \\*\texttt{ResultProcessor.Process(Element[] result, int matcherID)}.

Toto propojení vyplývá z sekce \ref{anal.improvement.con2}.
Tímto jsme dokončili úpravu objektu části \textit{Match} pro pozměněné zpracování.
Nyní přistoupíme ke konkrétním implementacím zpracování a potomkům třídy \texttt{resultProcessor}.

\subsection{Úprava Order by}

V této sekci popíšeme implementaci úprav části dotazu \textit{Order by}.
Potomci specifikují navržené přístupy zpracování dle sekce analýzy \ref{anal.improvement.orderby}.
Část dotazu \textit{Order by} je reprezentována třídou \texttt{OrderByResultProcessor}.
Nejdříve popíšeme implementaci použitých vyhledávacích stromů a následně konkrétní třídy zpracování.

\subsubsection{Implementace (a, b)-stromu}

Implementovali jsme vlastní $(a, b)$-strom, protože jsme nedokázali nalézt již existující knihovnu.
Obecně při zpracovávání budeme využívat dva druhy stromů.
První je obecný $(a, b)$-strom a druhý je optimalizovaný strom z sekce \ref{anal.improvement.orderby.storeindex}, který seskupuje totožné prvky do pole místo aby je vložil do vrcholu.
Oba stromy implementují rozhraní \texttt{IABTree<T>}, který definuje metodu vložení prvku \texttt{void Insert(T key)} a položku počtu prvků ve stromě \texttt{int Count}.
Toto rozhraní použijeme pro vytvoření obecného algoritmu zpracování, kterému budeme jednoduše moct změnit druh stromu.
Při zpracování očekáváme, že vkládané prvky jsou indexy řádků tabulky.
Potřebujeme setřídit i prvky se shodnými klíči, proto u všech řešení je použit \texttt{IndexToRowProxyComparer} s \texttt{allowDuplicities == false}.
To způsobí porovnání při shodnosti klíčů pomocí indexů řádků a \texttt{cacheResults == true}, protože se stromem vždy bude pracovat jedno vlákno.

\subsubsection{Třída ABTree<T>}

Třída představuje $(a, b)$-strom \citep[str. 190]{labyrint}, u kterého jsem upravili definici na $b=2a$.
\texttt{T} je zde typ vkládaných prvků.
V konstruktoru obdrží parametr $b$.
Struktura definuje:
\begin{itemize}
\item Metodu \texttt{void Insert(T key)}, která vloží prvek \texttt{key} do stromu.
Prvky, které již jsou ve stromě nejsou vloženy.
\item Položku \texttt{int Count}, která určuje počet prvků ve stromě.
\end{itemize}
Strom implementuje pouze metodu vkládání \texttt{Insert}, protože pro naše zpracování funkce mazání \texttt{Delete} není potřebná.
Při vkládání je hledání správného podstromu realizováno binárním vyhledáváním.
Strom je interně složen z tříd \texttt{ABTreeNode<T>}, reprezentující vrcholy stromu.
Vrcholy obsahují odkaz na rodiče, abychom při iterování a procházení stromu nemuseli zaznamenávat cestu z kořene.
Vrchol obsahuje:
\begin{itemize}
\item \texttt{List<ABTreeNode<T> > children} je pole potomků. Každý potomek je zde chápán jako podstrom.
\item \texttt{List<T> keys} je pole vkládaných hodnot.
\item \texttt{ABTreeNode<T> parent} je odkaz na rodiče vrcholu.
\item \texttt{int index} je pozice vrcholu v jeho rodičovském vrcholu.
\end{itemize}
Třída implementuje rozhraní \texttt{IABTree<T>} a \texttt{IEnumerable<T>}.
Rozhraní procházení \texttt{IEnumerable<T>} iteruje prvky stromu od nejmenšího po největší.

\subsubsection{Třída ABTreeAccumulator<T>}

Třída představuje optimalizovaný $(a, b)$-strom z sekce analýzy \ref{anal.improvement.orderby.storeindex}.
Třída interně funguje totožně jako třída \texttt{ABTree<T>} a implementuje \texttt{IABTree<T>}.
Vrchol stromu \texttt{ABTreeNode<T>} nově vlastní položku \texttt{List<List<T> > accumulations}.
Každému prvku v poli \texttt{keys} na indexu \texttt{i} náleží právě jedno pole v \texttt{accumulations} na stejném indexu.
Metoda \texttt{Insert} chybějící prvek vloží do pole \texttt{keys} na index \texttt{i} a vytvoří prázdné pole v \texttt{accumulations} na indexu \texttt{i}.
Pokud se v budoucnu vkládaný prvek rovná již vloženému prvku v poli \texttt{keys} na indexu \texttt{i}, tak je vkládaný prvek vložen do pole na pozici \texttt{i} v poli \texttt{accumulations}.
Třída implementuje rozhraní \texttt{IEnumerable<ValueAccumulation<T> >}.
\texttt{ValueAccumulation<T>} je struktura, která obsahuje prvek z pole \texttt{keys} (\texttt{T value}) a jeho náležité pole v \texttt{accumulations} (\texttt{List<T> accumulation}).

\subsubsection{Řešení Half-Streamed}

Řešení je obsaženo v třídě \texttt{ABTreeSorterHalfStreamed} a odpovídá sekci analýzy \ref{anal.improvement.orderby.halfstreamed}.
Třída je abstraktním potomkem \texttt{OrderByResultProcessor}.
Potomci této třídy jsou řešení specializované na druh vyhledávacího stromu.
Definuje:
\begin{itemize}

\item Položku \texttt{SortJob[] sortJobs}, která obsahuje lokální výsledky vláken. \\*
Každému vláknu v průběhu prohledávání grafu náleží objekt algoritmu DFS \texttt{DFSPatternMatcherStreamed} s identifikátorem v položce \texttt{int matcherID}.
Tyto \texttt{ID} vznikly na základě pořadí vytvoření objektů.
Tedy vlákno vždy při volání metody \texttt{Process} přistupuje k objektu \texttt{sortJobs[matcherID]}. 
Objekt interně obsahuje \texttt{ITableResults resTable} (lokální tabulka výsledků prohledávání) a \texttt{IABTree<int> tree} (lokální indexační struktura).

\item Položku \texttt{int sortJobsFinished}, která určuje kolik vláken již dokončilo prohledávání grafu.
Vlákna při dokončení prohledávání grafu vyvolají atomické navýšení \texttt{Interlocked.Increment} na této položce.
Poslední vlákno zahájí paralelní slévání výsledků.

\item Metodu \texttt{SortJob CreateJob(..)}, kterou implemetují potomci a vytváří v ní specializovaný druh vyhledávacího stromu.

\item Implementaci metody \texttt{Process(Element[] result, int matcherID)}.\\*
V první části vlákno přistoupí k \texttt{sortJobs[matcherID]}. 
Následně překopíruje výsledek \texttt{result} do tabulky (\texttt{resTable.StoreRow(result)}) a zatřídí index nového řádku tabulky (\texttt{tree.Insert(resTable.RowCount-1)}).
V této části fungují obě optimalizace porovnání.
Po dokončení prohledávání všech vláken dochází k paralelnímu dvoucestnému slévání.
Slévání je implementováno v objektu \texttt{MergeObject<T>} v metodě \texttt{T[] Merge()}.
V jednovláknovém zpracování nedochází ke slévání.
\item Objekt \texttt{MergeObject<T>}, který implementuje paralelní dvoucestné slévání.
Interně používá metodu knihovny HPCsharp \citep{hpcsharp}.
Rozhraní metody pracuje s dvěma poli. 
\texttt{T[] source} a \texttt{T[] destination}.
V prvním kroku slévání dochází k překopírování výsledků uvnitř stromů do pole \texttt{source}.
Na pole se tedy díváme jako na několik posloupností výsledků vláken.
Posloupnosti jsou slévány knihovní metodou do pole \texttt{destination}.
V této části nefunguje druhá optimalizace z důvodu paralelizace.
\end{itemize}
Toto je implementace obecné části.
Z třídy \texttt{ABTreeSorterHalfStreamed} dědí dvě třídy, které představují dvě řešení.
Specifikují pouze implementaci \texttt{IABTree} a typ \texttt{T} třídy \texttt{MergeObject<T>}.
Budeme se držet definovaného značení:
\begin{itemize}
\item Řešení \textbf{Half-Streamed: ABTree}: využívá \texttt{ABTree} jako \texttt{IABTree}.
\texttt{T} třídy \texttt{MergeObject} je \texttt{RowProxy}, protože sléváme několik tabulek najednou a tedy použitím pouze \texttt{int} bychom nedokázali rozeznat, které tabulce index patří.
Řešení je obsaženo v třídě \texttt{ABTreeGenSorterHalfStreamed}.

\item Řešení \textbf{Half-Streamed: ABTreeAcccumulator}: využívá interně strom \texttt{ABTreeAccumulator} jako \texttt{IABTree}.
\texttt{T} třídy \texttt{MergeObject} je \texttt{RowProxyAccum}.
Jedná se o strukturu shodnou s \texttt{ValueAccumulation<int>}. 
Jediný rozdíl je ten, že místo indexu řádku tabulky (\texttt{int value}) obsahuje proxy třídu daného řádku (\texttt{RowProxy row}).
Takto sléváme pouze akumulované hodnoty a při porovnání dvou struktur porovnáváme pouze jejich položky \texttt{row}, protože indexy v poli struktury mají stejnou hodnotu klíčů porovnání.
Řešení je obsaženo v třídě \texttt{ABTreeAccumSorterHalfStreamed}.

\end{itemize}
Třídy řešení se využívají i k jednovláknovému zpracování.
V takovém případě existuje pouze jedna tabulka a jedna stromová struktura.

\subsubsection{Řešení Streamed}

Řešení je obsaženo v třídě \texttt{ABTreeStreamedSorter<T>} a odpovídá řešení z sekce analýzy \ref{anal.improvement.orderby.streamed}.
\texttt{T} je zde typ prvního klíče třídění, podle kterého budeme rozdělovat rozsahy přihrádkám.
Potomci této třídy jsou řešení specializované na druh vyhledávacího stromu.
Definuje:
\begin{itemize}
\item Položku \texttt{RangeBucket[] rangeBuckets}, která odpovídá definovaným přihrádkám.
\texttt{RangeBucket} interně obsahuje \texttt{ITableResults resTable}\\* (lokální tabulka výsledků prohledávání) a \texttt{IABTree<int> tree} (lokální indexační struktura).

\item Položku \texttt{ExpressionReturnValue<T> firstKeyExpression} představující výraz prvního klíče třídění.
Výraz se vypočte a následně se jeho hodnota použije k zjištění správné přihrádky.
\item Položku \texttt{ExpressionComparer<T>[] firstKeyComparers}, která obsahuje odkaz na porovnávače prvních klíčů použitých ve stromech uvnitř přihrádek.
V moment výpočtu prvního klíče nastavíme výslednou hodnotu výrazu položkám porovnávače, aby nedocházelo k opětovnému výpočtu výrazu.
\item Metodu \texttt{RangeBucket CreateBucket()}, kterou implementují potomci a vytváří v ní specializovaný druh vyhledávacího stromu.
\item Položku \texttt{TypeRangeHasher<T> firstKeyHasher}, která na základě hodnoty prvního klíče třídění určí správnou přihrádku výsledku (volání metody \texttt{int Hash(T value)}).
\item Implementaci metody \texttt{Process(Element[] result, int matcherID)}.
V moment nalezení výsledku vlákno vypočte hodnotu \texttt{firstKeyExpression} pomocí \texttt{result} a určí přihrádku voláním metody \texttt{Hash} s vypočtenou hodnotou výrazu.
Uzamkne přihrádku a vloží výsledek do tabulky v přihrádce.
Nastaví položky porovnávače uvnitř stromu a následně vloží index řádku do stromu. 
\end{itemize}
Výpočet indexu přihrádky je zpracován potomky třídy \texttt{TypeRangeHasher}.
Třída pouze definuje Factory metodu \citep[str. 107]{patterns} \texttt{Factory(int threadCount, Type type)}.
\texttt{threadCount} říká kolik vláken bude přistupovat k přihrádkám a je omezen dle analýzy na 64.
\texttt{type} určuje jaký typ hodnoty třída zpracovává.
Z třídy dědí abstraktní třída \texttt{TypeRangeHasher<T>}, která definuje abstraktní metodu \texttt{int Hash(T value)}.
\texttt{T} je zde \texttt{type} z metody \texttt{Factory}.
Dále definuje položku \texttt{int BucketCount}, který určuje počet existujících přihrádek.
Potomek dané třídy je \texttt{IntRangeHasher}, která představuje rozdělení typu \texttt{Int32} dle analýzy.
Dále třídě je potomkem třída \texttt{AsciiStringRangeHasher}, která představuje rozdělení typu \texttt{string} dle analýzy.

Výsledně potomci \texttt{ABTreeSorterStreamed<T>} specializují použitý strom.
\begin{itemize}
\item Řešení \textbf{Streamed: ABTree}: využívá \texttt{ABTree} jako \texttt{IABTree}.
Řešení je obsaženo v třídě \texttt{ABTreeGenSorterStreamed<T>}.
\item Řešení \textbf{Streamed: ABTreeAcccumulator}: využívá interně strom\\* \texttt{ABTreeAccumulator} jako \texttt{IABTree}.
Řešení je obsaženo v třídě\\* \texttt{ABTreeAccumSorterStreamed<T>}.
\end{itemize}

Třídy řešení se využívají i k jednovláknovému zpracování.
V takovém případě existuje pouze jedna tabulka a jedna stromová struktura.
Zároveň, v jednovláknovém zpracování se řešení shodují i s řešeními \textbf{Half-Streamed}.
Při prezentaci výsledků v kapitole \ref{expr} je na to důležité brát zřetel.

\subsection{Úprava Group by}

V této sekci popíšeme implementaci úprav části dotazu \textit{Group by}.
Část dotazu \textit{Group by} je reprezentována třídou \texttt{GroupByResultProcessor}.
Potomci specifikují navržené přístupy zpracování dle sekce analýzy \ref{anal.improvement.groupby}.

\subsubsection{Řešení Half-Streamed}

V analýze jsme se rozhodli využít seskupování způsobem \textbf{Two-step} \textit{Group by}.
Vytvořili jsme dva ekvivalenty daného řešení, které se liší využitým úložištěm: 
\begin{itemize}
\item Řešení \textbf{Half-Streamed: Two-step (Bucket)}, které využívá Bucket jako úložiště a je obsaženo v třídě \texttt{TwoStepHalfStreamedBucket}.
Je ekvivalentem řešení \textbf{Normal: Two-step (Bucket)}.
\item Řešení \textbf{Half-Streamed: Two-step (List)}, které využívá List jako úložiště a je obsaženo v třídě \texttt{TwoStepHalfStreamedListBucket}.
Je ekvivalentem řešení \textbf{Normal: Two-step (List)}.
\end{itemize}
Obě řešení ve výsledcích pro jednovláknové zpracování mají v názvu \textbf{SingleThreadSolution} místo \textbf{Two-step}.
Řešení obecně fungují totožně jako jejich ekvivalenty a rovněž používají stejná úložiště agregačních funkcí, proto popíšeme krátce rozložení třídy a hlavní rozdíly.
Obě třídy definují:

\begin{itemize}

\item Položku \texttt{GroupJob[] groupJobs}, která představuje lokální výsledky vláken.
Každému vláknu v průběhu prohledávání grafu náleží objekt algoritmu DFS \texttt{DFSParallelPatternMatcherStreamed} s identifikátorem v položce \texttt{int matcherID}.
Tyto \texttt{ID} vznikly na základě pořadí vytvoření objektů. 
Tedy vlákno vždy při volání metody \texttt{Process} přistupuje k objektu \texttt{groupJobs[matcherID]}.
Objekt obsahuje \texttt{ITableResults resTable} (lokální tabulka výsledků prohledávání) a \texttt{Dictionary<GroupDictKey, ...> groups} s úložištěm agregačních funkcí (lokální výsledky seskupování).

\item Položku \\*\texttt{ConcurrentDictionary<GroupDictKeyFull, ...> globalGroups},\\* do které se slévají výsledky, když vlákno dokončí prohledávání grafu.
Zde je první rozdíl s řešeními módu \textbf{Normal}.
V původním řešení jsme použili při slévání výsledků do paralelní hašovací tabulky strukturu \texttt{GroupDictKey} jako klíč seskupení.
Nyní využíváme \texttt{GroupDictKeyFull}.
Struktura rozšiřuje \texttt{GroupDictKey} tak, že místo indexu řádku obsahuje proxy třídu řádku.
Využíváme danou strukturu, protože při slévání výsledků je sléváno několik tabulek \texttt{ITableResults}.
Kdybychom použili původní strukturu, tak bychom nedokázali rozeznat, které tabulce řádek náleží.

\item Implementaci metody \texttt{Process(Element[] result, int matcherID)}, ve které dochází v první části k lokálnímu seskupování.
V moment, kdy vlákno dokončí prohledávání grafu, začne dané vlákno slévat své lokální výsledky do položky \texttt{globalGroups}.
Slévání vykonává metoda \texttt{MergeResults(GroupJob job, int matcherID)}.
V jednovláknovém zpracování nedochází ke slévání.
\end{itemize}
Hlavní rozdíl, kromě jiné struktury klíče při slévání, je způsob ukládání výsledků prohledávání do tabulky \texttt{ITableResults} v první části.
Místo aby se výsledek \texttt{result} překopíroval prvně do tabulky (\texttt{resTable.StoreRow(result)}), tak je uložen do položky \texttt{resTable.temporaryRow}.
Porovnání v hašovací tabulce vyvolá přístup k dané položce a ne hodnotám v tabulce.
Pokud položka neexistuje v hašovací tabulce, tak je pole \texttt{temporaryRow} překopírováno do tabulky voláním metody \texttt{resTable.StoreTemporaryRow()}.
V opačném případě je položka nastavena na \texttt{null}. To odpovídá návrhu z sekce analýzy \ref{anal.improvement.groupby}. 

\subsubsection{Řešení Streamed} \label{impl.improvement.groupby.streamed}

Řešení vychází z řešení \textbf{Global} \textit{Group by} a pojmenovali jsme jej \textbf{Streamed: Global} a je implementováno třídou \texttt{GlobalGroupByStreamed}.
Jednovláknové zpracování je rovněž obsaženo v dané třídě.
Pokud je řešení použito v jednovláknovém kontextu označíme jej \textbf{Streamed: SingleThreadSolution}.
V tomto řešení vlákna seskupují výsledky pomocí \texttt{ConcurrentDictionary<key, value>}.
V jednovláknovém řešení je seskupováno pomocí \texttt{Dictionary<key, value>}.
Hlavním rozdílem od původních řešení je typ \texttt{key} a \texttt{value}.
Zde jsou oba rovny typu \texttt{AggregateBucketResult[]}.
Metody vkládání jsou volány s odkazem na stejné pole v \texttt{key} i \texttt{value}.
Ačkoliv je to zbytečné, nenašli jsme ekvivalent thread-safe struktury, který by umožnil práci pouze s jedním záznamem.
Pro \texttt{Dictionary} existuje ekvivalent s jedním záznamem \texttt{HashSet}, ale protože již používáme původní paralelní hašovací tabulku, tak využijeme i \texttt{Dictionary}. 

Hlavní myšlenka z analýzy byla mít pole obsahující v prvních $n$ položkách hodnoty klíčů seskupení a ve zbylých $m$ výsledky agregačních funkcí.
To jsme realizovali zmíněným polem \texttt{AggregateBucketResult[]}.
Objekty úložiště agregačních funkcí jsou totožná s již navrhnutými.
Pro objekty hodnot klíčů jsme vytvořili nové objekty rozšířením třídy \texttt{AggregateBucketResult<T>}.

\subsubsection{Třída AggregateBucketResultStreamed<T>}

Třída reprezentuje hodnotu výrazu jednoho klíče seskupení a dědí z třídy \texttt{AggregateBucketResult<T>}.
Hodnota klíče je uložena ve zděděné položce \texttt{T aggResult}.
Definuje:
\begin{itemize}
\item Položku \texttt{bool isSet}, která určuje, zda výpočet výrazu byl úspěšný.
Při neúspěchu \texttt{aggResult} obsahuje hodnotu \texttt{default}. 
\item Implementaci metody \texttt{int GetHashCode()}, která vyvolává stejnojmennou metodu na zděděném prvku \texttt{aggResult}.
Metoda se používá k získání haše výsledku prohledávání při vkládání do hašovací tabulky.
\end{itemize}
Při vkládání pole do hašovací tabulky musíme prvky porovnat. 
Implementovali statickou třídu \texttt{AggregateBucketResultStreamedComparers}.
Třída má metodu \\*\texttt{bool Equals(Type type, aggBucket x, aggBucket y)}, kde \texttt{aggBucket} je roven \texttt{AggregateBucketResult}.
Na základě \texttt{type} se přetypují prvky \texttt{x} a \texttt{y} na \texttt{AggregateBucketResultStreamed<T>}.
Následně se vyvolá porovnání hodnot.

\subsubsection{Třída BucketsKeyValueFactory a třída BucketKeyFactory}

Třída vytváří pole \texttt{AggregateBucketResult[]}, které se vkládá do hašovací tabulky.
Obsahuje:
\begin{itemize}
\item Položku \texttt{int keysCount}, která obsahuje počet klíčů v poli.
\item Položku \texttt{Aggregate[] aggregates}, na základě které se vytváří úložiště hodnot agregačních funkcí.
\item Položku \texttt{AggregateBucketResult[] lastBucketsKeyValue}, která je odkaz na poslední vytvořené pole.
\item Metodu \texttt{AggregateBucketResult[] Create(Element[] result)}, která \\*vytváří pole objektů hodnot klíčů a úložišť agregačních funkcí.
\item Položku \texttt{bool lastWasInserted}, která říká, zda poslední vytvořené pole bylo vloženo do hašovací tabulky.
Pokud bylo vloženo, tak se při volání metody \texttt{Create} vytváří pole úplně nové.
Pokud nebylo, tak se nevytváří pole nové, ale pouze se přepíšou hodnoty klíčů v prvních \texttt{keysCount} objektech uvnitř pole \texttt{lastBucketsKeyValue}.
Tímto vytváříme pole, jen když je to nutné.
\item Položku \texttt{BucketKeyFactory[] factories}, je pole objektů, které vytvářejí objekty klíčů (\texttt{AggregateBucketResultStreamed<T>}).
Každý objekt v tomto poli vytváří jeden objekt hodnoty klíče pro výsledné pole uvnitř metody \texttt{Create(...)}.
\end{itemize}
Objekt \texttt{BucketKeyFactory} definuje metodu \\*\texttt{AggregateBucketResult Create(bool lastWasInserted, Element[] ..)}, \\*která vytváří jeden objekt úložiště klíče.
Z třídy dědí \texttt{BucketKeyFactory<T>}, která obsahuje výraz \texttt{ExpressionReturnValue<T> expr} použitý k získání hodnoty jednoho klíče.
Dále obsahuje odkaz na poslední vytvořený objekt hodnoty klíče \texttt{AggregateBucketResultStreamed<T> lastCreatedBucket}.
Tento objekt je obsažen v poli \texttt{lastBucketsKeyValue} uvnitř třídy \texttt{BucketsKeyValueFactory}.
Při volání metody \texttt{Create(..)} se buď vytvoří nový objekt nebo se přepíší jen jeho vnitřní hodnoty na základě položky \texttt{lastWasInserted}.

\subsubsection{Třída GlobalGroupByStreamed}

Třída obsahuje implementaci řešení \textbf{Streamed: Global}.
Třída definuje:
\begin{itemize}
\item Položku \texttt{ConcurrentDictionary<..., ...> parGroups}, která je použita k seskupování v paralelním řešení.
\item Položku \texttt{Dictionary<..., ...> groups}, která je použita k seskupování v jednovláknovém řešení.
\item Položku \texttt{BucketKeyFactory[] matcherBucketFactories}, kde každý záznam odpovídá třídě vytvářející pole vkládané do hašovací tabulky jednoho vlákna.
To znamená, že každé vlákno má svůj objekt opět přístupný pomocí \texttt{matcherID}.
Každé vlákno vlastní svůj objekt, protože při použití sdíleného objektu by vlákna přepisovala objekty uvnitř pole.
\item Implementaci metody \texttt{Process(Element[] result, int matcherID)}.\\*
Vlákno volající metodu vytvoří vkládané pole pomocí svého objektu \\*\texttt{matcherBucketFactories[matcherID]} a vloží jej do hašovací tabulky.
\end{itemize}

\subsection{Úprava Single group Group by}

V této sekci popíšeme implementaci úprav \textit{Single group Group by}.
Při úpravě \textit{Single group Group by} jsme postupovali přesně podle sekce analýzy \ref{anal.improvement.singlegroup}.
Vytvořili jsme dvě řešení.
Jedno řešení pro mód \textbf{Half-Streamed} a jedno pro mód \textbf{Streamed}.
Řešení jsou:
\begin{itemize}
\item Řešení \textbf{Half-Streamed: SingleGroup} představuje \textbf{Half-Streamed} \\*\textit{Single} \textit{group} \textit{Group by}.
Je implementováno v třídě \\*\texttt{SingleGroupGroupByHalfStreamed}.
\item Řešení \textbf{Streamed: SingleGroup} představuje \textbf{Streamed} \textit{Single group}\\* \textit{Group by}.
Je implementováno v třídě \texttt{SingleGroupGroupByStreamed}.
\end{itemize}
Řešení se liší pouze paralelním zpracování. 
V jednovláknovém zpracování jsou totožná.
U obou řešení se používá úložiště Bucket, protože se vždy jedná o jednu skupinu.
Obě třídy dědí z třídy \texttt{GroupByResultProcessor}.

\subsubsection{Třída SingleGroupGroupByHalfStreamed}

Třída definuje hlavní položky:
\begin{itemize}
\item Položku \texttt{AggregateBucketResult[][] matcherNonAsterixResults} představující lokální úložiště agregačních funkcí vláken.
Každé vlákno ukládá výsledky funkcí při volání metody \texttt{Process} do svého lokálního úložiště \texttt{matcherNonAsterixResults[matcherID]}.
Tato položka neobsahuje úložiště pro funkci \texttt{count(*)}, abychom nemuseli vyvolávat metody logiky této funkce.
\item Položku \texttt{int[] numberOfMatchedElements}, která obsahuje lokální úložiště pro výpočet funkce \texttt{count(*)}.
Vlákna tedy při zpracování této funkce vykonají pouze navýšení této položky.
\item Položku \texttt{AggregateBucketResult[] finalResults}, do kterého se budou výsledky vláken slévat.
Tato položka obsahuje již úložiště pro \texttt{count(*)}.
\item Implementaci metody \texttt{Process(Element[] result, int matcherID)}.\\*
Metoda přistoupí k lokálnímu úložišti vlákna.
Vlákno zpracuje výsledek logikou tříd \texttt{Aggregate} a následně výsledek zahodí, tj. neukládá ho do tabulky.
Volají se zde normální funkce zpracování, protože se jedná o lokální výsledky.
Vlákno po dokončení prohledávání slévá výsledky do položky \texttt{finalResults}, tj. nečeká až ostatní vlákna dokončí prohledávání.
Při slévání se využívají thread-safe verze zpracování.
\end{itemize}

\subsubsection{Třída SingleGroupGroupByStreamed}

Třída definuje hlavní položky:
\begin{itemize}
\item Položku \texttt{AggregateBucketResult[] nonAsterixResults}, která představuje globální úložiště hodnot agregačních funkcí všech vláken.
Neobsahuje úložiště pro funkci \texttt{count(*)}, abychom nemuseli vyvolávat metody logiky této funkce.
\item Položku \texttt{int numberOfMatchedElements}, která představuje globální úložiště hodnot funkce \texttt{count(*)}.
Vlákna tedy při zpracování této funkce vykonají pouze atomické navýšení této položky.
\item Položku \texttt{AggregateBucketResult[] finalResults}, která obsahuje finální výsledky agregačních funkcí.
Tyto výsledky již obsahují úložiště pro funkci \texttt{count(*)}.
\item Položku \texttt{int matchersFinished} udávající počet vláken, která dokončila prohledávání grafu.
\item Implementaci metody \texttt{Process(Element[] result, int matcherID)}.\\*
Vlákno zpracuje výsledek do úložiště \texttt{nonAsterixResults} pomocí thread-safe verzí logiky funkcí.
Výsledek se neukládá do tabulky, ale pouze zahodí.
Poslední pracující vlákno vyvolá uložení výsledků z \texttt{nonAsterixResults} do položky \texttt{finalResults}.
\end{itemize}

\section{Překlad a spuštění enginu}

\subsubsection{Překlad}

Překlad se vykonává z prostředí aplikace Visual Studia 2019.
K překladu je nutné volit \texttt{Release} mód a platformu x64.
Předpokládáme, že aplikace se používá na systému Windows 10.
Vstupní soubory v adresáři \textit{DataFiles} se při překladu překopírují do složky s přeloženou aplikací.

\subsubsection{Vstupní soubory}

Aplikace očekává čtyři vstupní soubory definované v sekcích \ref{anal.vstup} a \ref{impl.vstup} ve složce \textit{DataFiles}.
Schéma hran v souboru \textit{NodeTypes.txt}.
Schéma vrcholů v souboru \textit{EdgeTypes.txt}.
Pro schémata jsme definovali JSON formát v sekci \ref{anal.vstup}.
Obecně hrana a vrchol nemůžou mít stejný štítek.
Typy vrcholů a hran mohou však sdílet vlastnost.
Typy vlastností jsme definovali na \texttt{integer} a \texttt{string}. 
Datový soubor hran v souboru \textit{Edges.txt}.
Datový soubor vrcholů v souboru \textit{Nodes.txt}.
Soubory mají formát definovaný formát v sekci \ref{anal.vstup} a \ref{impl.vstup}.
Očekává se, že oddělovače sloupečků jsou mezery.
Každé \texttt{ID} elementu musí být unikátní.
Názvy vlastností a typů elementů v Property grafu nesmí obsahovat čísla.
Nedodržení formátu má za následek nedefinované chování.

\subsubsection{Argumenty programu} \label{impl.arguments}

Aplikace má celkově 9 argumentů.
Prvních 7 je povinných a zbylé dva jsou povinné jen v určitých situacích.
Následuje výpis argumentů.
Pořadí výpisu určuje pořadí zadání při spuštění.

\begin{enumerate}

\item Povinný argument \texttt{Mode:} argument definuje mód zpracování dotazu. 
Ve zbytku výpisu budeme využívat dané zkratky k označení módů.
\begin{table}[!htb]
\centering
\begin{tabular}{lr}
\toprule
\mc{\textbf{Hodnota argumentu}} & \mc{\textbf{Mód}}\\
\midrule
n  &  Normal \\
hs   &  Half-Streamed \\
s   &  Streamed \\
\bottomrule
\end{tabular}
\caption{Tabulka argumentu \texttt{Mode}.}
\label{tab.argument.mode}
\end{table}

\item Povinný argument \texttt{SorterAlias:} argument definuje způsob zpracování \\*části \textit{Order by}.
Každý mód má svá vlastní řešení.
Názvy řešení odpovídají názvům z implementace.
Hodnota ve sloupečku \textbf{Argument} udává hodnotu argumentu.

\begin{table}[!htb]
\centering
\begin{tabular}{lll}
\toprule
\mc{\textbf{Mód}} & \mc{\textbf{Argument}} & \mc{\textbf{Řešení}}\\
\midrule
n & mergeSort  & Normal: Merge sort \\
hs & abtreeHS & Half-Streamed: ABTree \\
hs & abtreeAccumHS & Half-Streamed: ABTreeAcccumulator \\
s & abtreeS  & Streamed: ABTree \\
s & abtreeAccumS & Streamed: ABTreeAcccumulator \\
\bottomrule
\end{tabular}
\caption{Tabulka argumentu \texttt{SorterAlias}.}
\label{tab.argument.sorteralias}
\end{table}

\item Povinný argument \texttt{GrouperAlias:} argument definuje způsob zpracování části \textit{Group by}.
Každý mód má svá vlastní řešení.
Názvy řešení odpovídají názvům z implementace.
Hodnota ve sloupečku \textbf{Argument} udává hodnotu argumentu.
Pokud bylo zadáno „refL“ nebo „refB“, pak je \textit{Group by} vykonáno jedním vláknem, přestože bylo definováno paralelní zpracování v argumentu \texttt{ThreadCount}.
Výběr zpracování \textit{Single group Group by} závisí pouze na výběru módu, protože každý mód má pravě jedno takové řešení.
\begin{table}[!htb]
\centering
\begin{tabular}{lll}
\toprule
\mc{\textbf{Mód}} & \mc{\textbf{Argument}} & \mc{\textbf{Řešení}}\\
\midrule
n & refB  & Normal: SingleThreadSolution (Bucket) \\
n & refL  & Normal: SingleThreadSolution (List) \\
n & localB  & Normal: LocalGroupByLocalTwoWayMerge (Bucket) \\
n & localL  & Normal: LocalGroupByLocalTwoWayMerge (List) \\
n & globalB  & Normal: Global (Bucket) \\
n & twpstepB  & Normal: Two-step (Bucket) \\
n & twostepL  & Normal: Two-step (List) \\
hs & twostepHSB & Half-Streamed: Two-step (Bucket) \\
hs & twostepHSL & Half-Streamed: Two-step (List) \\
s & globalS & Streamed: Global \\
\bottomrule
\end{tabular}
\caption{Tabulka argumentu \texttt{GrouperAlias}.}
\label{tab.argument.grouperalias}
\end{table}

\item Povinný argument \texttt{FixedArraySize:} definuje velikost bloků fixní velikost uvnitř tabulky výsledků
(viz sekce \ref{anal.match.merge}, \ref{impl.table} a \ref{impl.match.table}).
Argument má číselnou hodnotu.
Minimální hodnota je 1 a maximální je \texttt{Int32.MaxValue}.

\item Povinný argument \texttt{ThreadCount:} definuje počet použitých vláken k zpracování dotazu.
Argument má číselnou hodnotu.
Minimální počet je 1 a maximální počet je 64.

\item Povinný argument \texttt{Printer:} definuje místo výpisu výsledků dotazu.
Existují dvě možnosti: „console“ a „file“.
První vypíše výsledky dotazu uživateli do konzolového okna aplikace.
Druhý vypíše výsledky dotazu uživateli do souboru.
Název souboru je definován jako poslední argument programu.

\item Povinný argument \texttt{Formater:} definuje formát výpisu výsledků dotazu ve formě tabulky.
Existují dvě možnosti: „simple“ a „markdown“.
Hlavička tabulky obsahuje výrazy s \textit{Select} části dotazu.
První vypíše tabulku výsledků ve formátu, ve kterém jsou sloupečky odděleny mezerami.
Druhý vypíše tabulku výsledků ve formátu Markdown\footnote{\url{https://www.markdownguide.org/}} tabulky.

\item Nepovinný argument \texttt{VerticesPerThread:} argument je povinný, pokud je argument \texttt{ThreadCount} větší než jedna.
Argument má číselnou hodnotu.
Minimální hodnota je 1 a maximální je \texttt{Int32.MaxValue}.
Argument udává počet vrcholů přidělených vláknům k prohledání v části \textit{Match} (viz sekce \ref{anal.matchPar} a \ref{impl.match.parmatch} (\texttt{VertexDistributor})).

\item Nepovinný argument \texttt{File:} argument je povinný, pokud je \texttt{Printer} roven „file“.
Argument definuje jméno souboru, do kterého se vypíšou výsledky dotazu.
Součástí jména není koncovka souboru (např. .txt nebo .cs).
Koncovka souboru je určena na základě argumentu \texttt{Formater}.
Při hodnotě „simple“ se vytvoří soubor s koncovkou .txt a při „markdown“ se vytvoří soubor s koncovkou .md. 
\end{enumerate}

Následuje příklad argumentů programu:
\begin{code}
Jednovláknové spuštění s výpisem do konzole:
./QueryEngine.exe n globalB mergeSort 4194304 1 console simple
Paralelní spuštění s výpisem do konzole:
./QueryEngine.exe n globalB mergeSort 4194304 8 console simple 512

Spuštění s výpisem do souboru:  
./QueryEngine.exe n globalB mergeSort 4194304 1 file simple newfile
Spuštění s výpisem do souboru + paralelní zpracování:
./QueryEngine.exe n globalB mergeSort 4194304 8 file simple 512 newfile
\end{code}

\subsubsection{Zadání dotazu}

Po spuštění aplikace se načtou vstupní soubory.
Po načtení je uživatel vyzván pomocí zprávy, aby zadal \textbf{jeden} vstupní dotaz k vykonání:
\begin{code}
Enter Query:
\end{code}
Uživatel zadá dotaz pomocí jazyka PGQL z sekce \ref{req.pgql}.
Názvy proměnných, elementů Property grafu a vlastností jsou citlivé na velikost písmene.
Samotné názvy částí dotazu a funkcí nejsou citlivé na velikost písmene.
Názvy proměnných nesmí obsahovat čísla.
Zadaný dotaz musí být ukončen znakem „\textbf{;}“.
Stisknutím klávesy „Enter“ dojde k zahájení zpracování dotazu.
Výstup je zobrazen uživateli dle argumentů programu \texttt{Printer} a \texttt{Formater}.
Po dokončení zpracování dotazu je uživatel vyzván pomocí zprávy, aby zadal další dotaz nebo ukončil aplikaci:
\begin{code}
Do you want to continue with another query?
    y/n (single character answer):
\end{code}
Program očekává odpověď jedním znakem.
„y“ vyzve uživatele k zadání nového dotazu.
„n“ ukončí aplikaci.
Stisknutím klávesy „Enter“ se vykoná daná akce.